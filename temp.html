<html><head><script>
var s = "// ==ClosureCompiler==\n// @compilation_level SIMPLE_OPTIMIZATIONS\n\n/**\n * @license Highcharts JS v5.0-dev (2016-05-10)\n *\n * (c) 2009-2016 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/*(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(function () {\n            return factory(root);\n        });\n    } else if (typeof module === ___doublequote___object___doublequote___ && typeof module.exports === ___doublequote___object___doublequote___) {\n        module.exports = factory(root);\n    else {\n        factory(global);\n    }\n}(this, function(window) {\n    // @code\n}));*/\n/* global window */\n(function () {\n\n    var win = window,\n        doc = win.document;\n\n    var SVG_NS = 'http://www.w3.org/2000/svg',\n        userAgent = (win.navigator && win.navigator.userAgent) || '',\n        svg = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,\n        isMS = /(edge|msie|trident)/i.test(userAgent) && !window.opera,\n        useCanVG = doc && !svg && !isMS && !!doc.createElement('canvas').getContext,\n        vml = !svg && !useCanVG,\n        isFirefox = /Firefox/.test(userAgent),\n        hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4; // issue #38\n\n    win.Highcharts = win.Highcharts ? win.Highcharts.error(16, true) : {\n        product: 'Highcharts',\n        version: '5.0-dev',\n        deg2rad: Math.PI * 2 / 360,\n        doc: doc,\n        hasBidiBug: hasBidiBug,\n        isMS: isMS,\n        isWebKit: /AppleWebKit/.test(userAgent),\n        isFirefox: isFirefox,\n        isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),\n        SVG_NS: SVG_NS,\n        idCounter: 0,\n        chartCount: 0,\n        seriesTypes: {},\n        svg: svg,\n        useCanVG: useCanVG,\n        vml: vml,\n        win: win,\n        charts: [],\n        marginNames: ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],\n        noop: function () {\n            return undefined;\n        }\n    };\n\n    return win.Highcharts;\n}());\n(function (H) {\nvar timers = [];\n\nvar charts = H.charts,\n    doc = H.doc,\n    win = H.win;\n\n/**\n * An animator object. One instance applies to one property (attribute or style prop) \n * on one element.\n * \n * @param {object} elem    The element to animate. May be a DOM element or a Highcharts SVGElement wrapper.\n * @param {object} options Animation options, including duration, easing, step and complete.\n * @param {object} prop    The property to animate.\n */\nH.Fx = function (elem, options, prop) {\n    this.options = options;\n    this.elem = elem;\n    this.prop = prop;\n};\nH.Fx.prototype = {\n    \n    /**\n     * Animating a path definition on SVGElement\n     * @returns {undefined} \n     */\n    dSetter: function () {\n        var start = this.paths[0],\n            end = this.paths[1],\n            ret = [],\n            now = this.now,\n            i = start.length,\n            startVal;\n\n        if (now === 1) { // land on the final path without adjustment points appended in the ends\n            ret = this.toD;\n\n        } else if (i === end.length && now < 1) {\n            while (i--) {\n                startVal = parseFloat(start[i]);\n                ret[i] =\n                    isNaN(startVal) ? // a letter instruction like M or L\n                            start[i] :\n                            now * (parseFloat(end[i] - startVal)) + startVal;\n\n            }\n        } else { // if animation is finished or length not matching, land on right value\n            ret = end;\n        }\n        this.elem.attr('d', ret);\n    },\n\n    /**\n     * Update the element with the current animation step\n     * @returns {undefined}\n     */\n    update: function () {\n        var elem = this.elem,\n            prop = this.prop, // if destroyed, it is null\n            now = this.now,\n            step = this.options.step;\n\n        // Animation setter defined from outside\n        if (this[prop + 'Setter']) {\n            this[prop + 'Setter']();\n\n        // Other animations on SVGElement\n        } else if (elem.attr) {\n            if (elem.element) {\n                elem.attr(prop, now);\n            }\n\n        // HTML styles, raw HTML content like container size\n        } else {\n            elem.style[prop] = now + this.unit;\n        }\n        \n        if (step) {\n            step.call(elem, now, this);\n        }\n\n    },\n\n    /**\n     * Run an animation\n     */\n    run: function (from, to, unit) {\n        var self = this,\n            timer = function (gotoEnd) {\n                return timer.stopped ? false : self.step(gotoEnd);\n            },\n            i;\n\n        this.startTime = +new Date();\n        this.start = from;\n        this.end = to;\n        this.unit = unit;\n        this.now = this.start;\n        this.pos = 0;\n\n        timer.elem = this.elem;\n\n        if (timer() && timers.push(timer) === 1) {\n            timer.timerId = setInterval(function () {\n                \n                for (i = 0; i < timers.length; i++) {\n                    if (!timers[i]()) {\n                        timers.splice(i--, 1);\n                    }\n                }\n\n                if (!timers.length) {\n                    clearInterval(timer.timerId);\n                }\n            }, 13);\n        }\n    },\n    \n    /**\n     * Run a single step in the animation\n     * @param   {Boolean} gotoEnd Whether to go to then endpoint of the animation after abort\n     * @returns {Boolean} True if animation continues\n     */\n    step: function (gotoEnd) {\n        var t = +new Date(),\n            ret,\n            done,\n            options = this.options,\n            elem = this.elem,\n            complete = options.complete,\n            duration = options.duration,\n            curAnim = options.curAnim,\n            i;\n        \n        if (elem.attr && !elem.element) { // #2616, element including flag is destroyed\n            ret = false;\n\n        } else if (gotoEnd || t >= duration + this.startTime) {\n            this.now = this.end;\n            this.pos = 1;\n            this.update();\n\n            curAnim[this.prop] = true;\n\n            done = true;\n            for (i in curAnim) {\n                if (curAnim[i] !== true) {\n                    done = false;\n                }\n            }\n\n            if (done && complete) {\n                complete.call(elem);\n            }\n            ret = false;\n\n        } else {\n            this.pos = options.easing((t - this.startTime) / duration);\n            this.now = this.start + ((this.end - this.start) * this.pos);\n            this.update();\n            ret = true;\n        }\n        return ret;\n    },\n\n    /**\n     * Prepare start and end values so that the path can be animated one to one\n     */\n    initPath: function (elem, fromD, toD) {\n        fromD = fromD || '';\n        var shift = elem.shift,\n            bezier = fromD.indexOf('C') > -1,\n            numParams = bezier ? 7 : 3,\n            endLength,\n            slice,\n            i,\n            start = fromD.split(' '),\n            end = [].concat(toD), // copy\n            isArea = elem.isArea,\n            positionFactor = isArea ? 2 : 1,\n            sixify = function (arr) { // in splines make move points have six parameters like bezier curves\n                i = arr.length;\n                while (i--) {\n                    if (arr[i] === 'M' || arr[i] === 'L') {\n                        arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);\n                    }\n                }\n            };\n\n        if (bezier) {\n            sixify(start);\n            sixify(end);\n        }\n\n        // If shifting points, prepend a dummy point to the end path. For areas,\n        // prepend both at the beginning and end of the path.\n        if (shift <= end.length / numParams && start.length === end.length) {\n            while (shift--) {\n                end = end.slice(0, numParams).concat(end);\n                if (isArea) {\n                    end = end.concat(end.slice(end.length - numParams));\n                }\n            }\n        }\n        elem.shift = 0; // reset for following animations\n\n        \n        // Copy and append last point until the length matches the end length\n        if (start.length) {\n            endLength = end.length;\n            while (start.length < endLength) {\n\n                // Pull out the slice that is going to be appended or inserted. In a line graph,\n                // the positionFactor is 1, and the last point is sliced out. In an area graph,\n                // the positionFactor is 2, causing the middle two points to be sliced out, since\n                // an area path starts at left, follows the upper path then turns and follows the\n                // bottom back. \n                slice = start.slice().splice(\n                    (start.length / positionFactor) - numParams, \n                    numParams * positionFactor\n                );\n                \n                // Disable first control point\n                if (bezier) {\n                    slice[numParams - 6] = slice[numParams - 2];\n                    slice[numParams - 5] = slice[numParams - 1];\n                }\n                \n                // Now insert the slice, either in the middle (for areas) or at the end (for lines)\n                [].splice.apply(\n                    start, \n                    [(start.length / positionFactor), 0].concat(slice)\n                );\n\n            }\n        }\n\n        return [start, end];\n    }\n}; // End of Fx prototype\n\n\n/**\n * Extend an object with the members of another\n * @param {Object} a The object to be extended\n * @param {Object} b The object to add to the first one\n */\nH.extend = function (a, b) {\n    var n;\n    if (!a) {\n        a = {};\n    }\n    for (n in b) {\n        a[n] = b[n];\n    }\n    return a;\n};\n\n/**\n * Deep merge two or more objects and return a third object. If the first argument is\n * true, the contents of the second object is copied into the first object.\n * Previously this function redirected to jQuery.extend(true), but this had two limitations.\n * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,\n * it copied properties from extended prototypes.\n */\nH.merge = function () {\n    var i,\n        args = arguments,\n        len,\n        ret = {},\n        doCopy = function (copy, original) {\n            var value, key;\n\n            // An object is replacing a primitive\n            if (typeof copy !== 'object') {\n                copy = {};\n            }\n\n            for (key in original) {\n                if (original.hasOwnProperty(key)) {\n                    value = original[key];\n\n                    // Copy the contents of objects, but not arrays or DOM nodes\n                    if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&\n                            key !== 'renderTo' && typeof value.nodeType !== 'number') {\n                        copy[key] = doCopy(copy[key] || {}, value);\n\n                    // Primitives and arrays are copied over directly\n                    } else {\n                        copy[key] = original[key];\n                    }\n                }\n            }\n            return copy;\n        };\n\n    // If first argument is true, copy into the existing object. Used in setOptions.\n    if (args[0] === true) {\n        ret = args[1];\n        args = Array.prototype.slice.call(args, 2);\n    }\n\n    // For each argument, extend the return\n    len = args.length;\n    for (i = 0; i < len; i++) {\n        ret = doCopy(ret, args[i]);\n    }\n\n    return ret;\n};\n\n/**\n * Shortcut for parseInt\n * @param {Object} s\n * @param {Number} mag Magnitude\n */\nH.pInt = function (s, mag) {\n    return parseInt(s, mag || 10);\n};\n\n/**\n * Check for string\n * @param {Object} s\n */\nH.isString = function (s) {\n    return typeof s === 'string';\n};\n\n/**\n * Check for object\n * @param {Object} obj\n */\nH.isObject = function (obj) {\n    return obj && typeof obj === 'object';\n};\n\n/**\n * Check for array\n * @param {Object} obj\n */\nH.isArray = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\n/**\n * Check for number\n * @param {Object} n\n */\nH.isNumber = function (n) {\n    return typeof n === 'number' && !isNaN(n);\n};\n\n/**\n * Remove last occurence of an item from an array\n * @param {Array} arr\n * @param {Mixed} item\n */\nH.erase = function (arr, item) {\n    var i = arr.length;\n    while (i--) {\n        if (arr[i] === item) {\n            arr.splice(i, 1);\n            break;\n        }\n    }\n    //return arr;\n};\n\n/**\n * Returns true if the object is not null or undefined.\n * @param {Object} obj\n */\nH.defined = function (obj) {\n    return obj !== undefined && obj !== null;\n};\n\n/**\n * Set or get an attribute or an object of attributes. Can't use jQuery attr because\n * it attempts to set expando properties on the SVG element, which is not allowed.\n *\n * @param {Object} elem The DOM element to receive the attribute(s)\n * @param {String|Object} prop The property or an abject of key-value pairs\n * @param {String} value The value if a single property is set\n */\nH.attr = function (elem, prop, value) {\n    var key,\n        ret;\n\n    // if the prop is a string\n    if (H.isString(prop)) {\n        // set the value\n        if (H.defined(value)) {\n            elem.setAttribute(prop, value);\n\n        // get the value\n        } else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...\n            ret = elem.getAttribute(prop);\n        }\n\n    // else if prop is defined, it is a hash of key/value pairs\n    } else if (H.defined(prop) && H.isObject(prop)) {\n        for (key in prop) {\n            elem.setAttribute(key, prop[key]);\n        }\n    }\n    return ret;\n};\n/**\n * Check if an element is an array, and if not, make it into an array.\n */\nH.splat = function (obj) {\n    return H.isArray(obj) ? obj : [obj];\n};\n\n/**\n * Set a timeout if the delay is given, otherwise perform the function synchronously\n * @param   {Function} fn      The function to perform\n * @param   {Number}   delay   Delay in milliseconds\n * @param   {Ojbect}   context The context\n * @returns {Nubmer}           An identifier for the timeout\n */\nH.syncTimeout = function (fn, delay, context) {\n    if (delay) {\n        return setTimeout(fn, delay, context);\n    }\n    fn.call(0, context);\n};\n\n\n/**\n * Return the first value that is defined.\n */\nH.pick = function () {\n    var args = arguments,\n        i,\n        arg,\n        length = args.length;\n    for (i = 0; i < length; i++) {\n        arg = args[i];\n        if (arg !== undefined && arg !== null) {\n            return arg;\n        }\n    }\n};\n\n/**\n * Set CSS on a given element\n * @param {Object} el\n * @param {Object} styles Style object with camel case property names\n */\nH.css = function (el, styles) {\n    if (H.isMS && !H.svg) { // #2686\n        if (styles && styles.opacity !== undefined) {\n            styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';\n        }\n    }\n    H.extend(el.style, styles);\n};\n\n/**\n * Utility function to create element with attributes and styles\n * @param {Object} tag\n * @param {Object} attribs\n * @param {Object} styles\n * @param {Object} parent\n * @param {Object} nopad\n */\nH.createElement = function (tag, attribs, styles, parent, nopad) {\n    var el = doc.createElement(tag),\n        css = H.css;\n    if (attribs) {\n        H.extend(el, attribs);\n    }\n    if (nopad) {\n        css(el, { padding: 0, border: 'none', margin: 0 });\n    }\n    if (styles) {\n        css(el, styles);\n    }\n    if (parent) {\n        parent.appendChild(el);\n    }\n    return el;\n};\n\n/**\n * Extend a prototyped class by new members\n * @param {Object} parent\n * @param {Object} members\n */\nH.extendClass = function (Parent, members) {\n    var object = function () {};\n    object.prototype = new Parent();\n    H.extend(object.prototype, members);\n    return object;\n};\n\n/**\n * Pad a string to a given length by adding 0 to the beginning\n * @param {Number} number\n * @param {Number} length\n */\nH.pad = function (number, length, padder) {\n    return new Array((length || 2) + 1 - String(number).length).join(padder || 0) + number;\n};\n\n/**\n * Return a length based on either the integer value, or a percentage of a base.\n */\nH.relativeLength = function (value, base) {\n    return (/%$/).test(value) ? base * parseFloat(value) / 100 : parseFloat(value);\n};\n\n/**\n * Wrap a method with extended functionality, preserving the original function\n * @param {Object} obj The context object that the method belongs to\n * @param {String} method The name of the method to extend\n * @param {Function} func A wrapper function callback. This function is called with the same arguments\n * as the original function, except that the original function is unshifted and passed as the first\n * argument.\n */\nH.wrap = function (obj, method, func) {\n    var proceed = obj[method];\n    obj[method] = function () {\n        var args = Array.prototype.slice.call(arguments);\n        args.unshift(proceed);\n        return func.apply(this, args);\n    };\n};\n\n\nH.getTZOffset = function (timestamp) {\n    var d = H.Date;\n    return ((d.hcGetTimezoneOffset && d.hcGetTimezoneOffset(timestamp)) || d.hcTimezoneOffset || 0) * 60000;\n};\n\n/**\n * Based on http://www.php.net/manual/en/function.strftime.php\n * @param {String} format\n * @param {Number} timestamp\n * @param {Boolean} capitalize\n */\nH.dateFormat = function (format, timestamp, capitalize) {\n    if (!H.isNumber(timestamp)) {\n        return H.defaultOptions.lang.invalidDate || '';\n    }\n    format = H.pick(format, '%Y-%m-%d %H:%M:%S');\n\n    var d = H.Date,\n        date = new d(timestamp - H.getTZOffset(timestamp)),\n        key, // used in for constuct below\n        // get the basic time values\n        hours = date[d.hcGetHours](),\n        day = date[d.hcGetDay](),\n        dayOfMonth = date[d.hcGetDate](),\n        month = date[d.hcGetMonth](),\n        fullYear = date[d.hcGetFullYear](),\n        lang = H.defaultOptions.lang,\n        langWeekdays = lang.weekdays,\n        shortWeekdays = lang.shortWeekdays,\n        pad = H.pad,\n\n        // List all format keys. Custom formats can be added from the outside. \n        replacements = H.extend({\n\n            // Day\n            'a': shortWeekdays ? shortWeekdays[day] : langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'\n            'A': langWeekdays[day], // Long weekday, like 'Monday'\n            'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31\n            'e': pad(dayOfMonth, 2, ' '), // Day of the month, 1 through 31\n            'w': day,\n\n            // Week (none implemented)\n            //'W': weekNumber(),\n\n            // Month\n            'b': lang.shortMonths[month], // Short month, like 'Jan'\n            'B': lang.months[month], // Long month, like 'January'\n            'm': pad(month + 1), // Two digit month number, 01 through 12\n\n            // Year\n            'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009\n            'Y': fullYear, // Four digits year, like 2009\n\n            // Time\n            'H': pad(hours), // Two digits hours in 24h format, 00 through 23\n            'k': hours, // Hours in 24h format, 0 through 23\n            'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11\n            'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12\n            'M': pad(date[d.hcGetMinutes]()), // Two digits minutes, 00 through 59\n            'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM\n            'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM\n            'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59\n            'L': pad(Math.round(timestamp % 1000), 3) // Milliseconds (naming from Ruby)\n        }, H.dateFormats);\n\n\n    // do the replaces\n    for (key in replacements) {\n        while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster\n            format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);\n        }\n    }\n\n    // Optionally capitalize the string and return\n    return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;\n};\n\n/**\n * Format a single variable. Similar to sprintf, without the % prefix.\n */\nH.formatSingle = function (format, val) {\n    var floatRegex = /f$/,\n        decRegex = /\\.([0-9])/,\n        lang = H.defaultOptions.lang,\n        decimals;\n\n    if (floatRegex.test(format)) { // float\n        decimals = format.match(decRegex);\n        decimals = decimals ? decimals[1] : -1;\n        if (val !== null) {\n            val = H.numberFormat(\n                val,\n                decimals,\n                lang.decimalPoint,\n                format.indexOf(',') > -1 ? lang.thousandsSep : ''\n            );\n        }\n    } else {\n        val = H.dateFormat(format, val);\n    }\n    return val;\n};\n\n/**\n * Format a string according to a subset of the rules of Python's String.format method.\n */\nH.format = function (str, ctx) {\n    var splitter = '{',\n        isInside = false,\n        segment,\n        valueAndFormat,\n        path,\n        i,\n        len,\n        ret = [],\n        val,\n        index;\n\n    while (str) {\n        index = str.indexOf(splitter);\n        if (index === -1) {\n            break;\n        }\n\n        segment = str.slice(0, index);\n        if (isInside) { // we're on the closing bracket looking back\n\n            valueAndFormat = segment.split(':');\n            path = valueAndFormat.shift().split('.'); // get first and leave format\n            len = path.length;\n            val = ctx;\n\n            // Assign deeper paths\n            for (i = 0; i < len; i++) {\n                val = val[path[i]];\n            }\n\n            // Format the replacement\n            if (valueAndFormat.length) {\n                val = H.formatSingle(valueAndFormat.join(':'), val);\n            }\n\n            // Push the result and advance the cursor\n            ret.push(val);\n\n        } else {\n            ret.push(segment);\n\n        }\n        str = str.slice(index + 1); // the rest\n        isInside = !isInside; // toggle\n        splitter = isInside ? '}' : '{'; // now look for next matching bracket\n    }\n    ret.push(str);\n    return ret.join('');\n};\n\n/**\n * Get the magnitude of a number\n */\nH.getMagnitude = function (num) {\n    return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));\n};\n\n/**\n * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5\n * @param {Number} interval\n * @param {Array} multiples\n * @param {Number} magnitude\n * @param {Object} options\n */\nH.normalizeTickInterval = function (interval, multiples, magnitude, allowDecimals, preventExceed) {\n    var normalized, \n        i,\n        retInterval = interval;\n\n    // round to a tenfold of 1, 2, 2.5 or 5\n    magnitude = H.pick(magnitude, 1);\n    normalized = interval / magnitude;\n\n    // multiples for a linear scale\n    if (!multiples) {\n        multiples = [1, 2, 2.5, 5, 10];\n\n        // the allowDecimals option\n        if (allowDecimals === false) {\n            if (magnitude === 1) {\n                multiples = [1, 2, 5, 10];\n            } else if (magnitude <= 0.1) {\n                multiples = [1 / magnitude];\n            }\n        }\n    }\n\n    // normalize the interval to the nearest multiple\n    for (i = 0; i < multiples.length; i++) {\n        retInterval = multiples[i];\n        if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural\n                (!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {\n            break;\n        }\n    }\n\n    // multiply back to the correct magnitude\n    retInterval *= magnitude;\n\n    return retInterval;\n};\n\n\n/**\n * Utility method that sorts an object array and keeping the order of equal items.\n * ECMA script standard does not specify the behaviour when items are equal.\n */\nH.stableSort = function (arr, sortFunction) {\n    var length = arr.length,\n        sortValue,\n        i;\n\n    // Add index to each item\n    for (i = 0; i < length; i++) {\n        arr[i].safeI = i; // stable sort index\n    }\n\n    arr.sort(function (a, b) {\n        sortValue = sortFunction(a, b);\n        return sortValue === 0 ? a.safeI - b.safeI : sortValue;\n    });\n\n    // Remove index from items\n    for (i = 0; i < length; i++) {\n        delete arr[i].safeI; // stable sort index\n    }\n};\n\n/**\n * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n * method is slightly slower, but safe.\n */\nH.arrayMin = function (data) {\n    var i = data.length,\n        min = data[0];\n\n    while (i--) {\n        if (data[i] < min) {\n            min = data[i];\n        }\n    }\n    return min;\n};\n\n/**\n * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n * method is slightly slower, but safe.\n */\nH.arrayMax = function (data) {\n    var i = data.length,\n        max = data[0];\n\n    while (i--) {\n        if (data[i] > max) {\n            max = data[i];\n        }\n    }\n    return max;\n};\n\n/**\n * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.\n * It loops all properties and invokes destroy if there is a destroy method. The property is\n * then delete'ed.\n * @param {Object} The object to destroy properties on\n * @param {Object} Exception, do not destroy this property, only delete it.\n */\nH.destroyObjectProperties = function (obj, except) {\n    var n;\n    for (n in obj) {\n        // If the object is non-null and destroy is defined\n        if (obj[n] && obj[n] !== except && obj[n].destroy) {\n            // Invoke the destroy\n            obj[n].destroy();\n        }\n\n        // Delete the property from the object.\n        delete obj[n];\n    }\n};\n\n\n/**\n * Discard an element by moving it to the bin and delete\n * @param {Object} The HTML node to discard\n */\nH.discardElement = function (element) {\n    var garbageBin = H.garbageBin;\n    // create a garbage bin element, not part of the DOM\n    if (!garbageBin) {\n        garbageBin = H.createElement('div');\n    }\n\n    // move the node and empty bin\n    if (element) {\n        garbageBin.appendChild(element);\n    }\n    garbageBin.innerHTML = '';\n};\n\n/**\n * Fix JS round off float errors\n * @param {Number} num\n */\nH.correctFloat = function (num, prec) {\n    return parseFloat(\n        num.toPrecision(prec || 14)\n    );\n};\n\n/**\n * Set the global animation to either a given value, or fall back to the\n * given chart's animation option\n * @param {Object} animation\n * @param {Object} chart\n */\nH.setAnimation = function (animation, chart) {\n    chart.renderer.globalAnimation = H.pick(animation, chart.animation);\n};\n\n/**\n * Get the animation in object form, where a disabled animation is always\n * returned with duration: 0\n */\nH.animObject = function (animation) {\n    return H.isObject(animation) ? H.merge(animation) : { duration: animation ? 500 : 0 };\n};\n\n/**\n * The time unit lookup\n */\nH.timeUnits = {\n    millisecond: 1,\n    second: 1000,\n    minute: 60000,\n    hour: 3600000,\n    day: 24 * 3600000,\n    week: 7 * 24 * 3600000,\n    month: 28 * 24 * 3600000,\n    year: 364 * 24 * 3600000\n};\n\n/**\n * Format a number and return a string based on input settings\n * @param {Number} number The input number to format\n * @param {Number} decimals The amount of decimals\n * @param {String} decimalPoint The decimal point, defaults to the one given in the lang options\n * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options\n */\nH.numberFormat = function (number, decimals, decimalPoint, thousandsSep) {\n\n    number = +number || 0;\n    decimals = +decimals;\n\n    var lang = H.defaultOptions.lang,\n        origDec = (number.toString().split('.')[1] || '').length,\n        decimalComponent,\n        strinteger,\n        thousands,\n        absNumber = Math.abs(number),\n        ret;\n\n    if (decimals === -1) {\n        decimals = Math.min(origDec, 20); // Preserve decimals. Not huge numbers (#3793).\n    } else if (!H.isNumber(decimals)) {\n        decimals = 2;\n    }\n\n    // A string containing the positive integer component of the number\n    strinteger = String(H.pInt(absNumber.toFixed(decimals)));\n\n    // Leftover after grouping into thousands. Can be 0, 1 or 3.\n    thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;\n\n    // Language\n    decimalPoint = H.pick(decimalPoint, lang.decimalPoint);\n    thousandsSep = H.pick(thousandsSep, lang.thousandsSep);\n\n    // Start building the return\n    ret = number < 0 ? '-' : '';\n\n    // Add the leftover after grouping into thousands. For example, in the number 42 000 000,\n    // this line adds 42.\n    ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';\n\n    // Add the remaining thousands groups, joined by the thousands separator\n    ret += strinteger.substr(thousands).replace(/(\\d{3})(?=\\d)/g, '$1' + thousandsSep);\n\n    // Add the decimal point and the decimal component\n    if (decimals) {\n        // Get the decimal component, and add power to avoid rounding errors with float numbers (#4573)\n        decimalComponent = Math.abs(absNumber - strinteger + Math.pow(10, -Math.max(decimals, origDec) - 1));\n        ret += decimalPoint + decimalComponent.toFixed(decimals).slice(2);\n    }\n\n    return ret;\n};\n\n/**\n * Easing definition\n * @param   {Number} pos Current position, ranging from 0 to 1\n */\nMath.easeInOutSine = function (pos) {\n    return -0.5 * (Math.cos(Math.PI * pos) - 1);\n};\n\n/**\n * Internal method to return CSS value for given element and property\n */\nH.getStyle = function (el, prop) {\n\n    var style;\n\n    // For width and height, return the actual inner pixel size (#4913)\n    if (prop === 'width') {\n        return Math.min(el.offsetWidth, el.scrollWidth) - H.getStyle(el, 'padding-left') - H.getStyle(el, 'padding-right');\n    } else if (prop === 'height') {\n        return Math.min(el.offsetHeight, el.scrollHeight) - H.getStyle(el, 'padding-top') - H.getStyle(el, 'padding-bottom');\n    }\n\n    // Otherwise, get the computed style\n    style = win.getComputedStyle(el, undefined);\n    return style && H.pInt(style.getPropertyValue(prop));\n};\n\n/**\n * Return the index of an item in an array, or -1 if not found\n */\nH.inArray = function (item, arr) {\n    return arr.indexOf ? arr.indexOf(item) : [].indexOf.call(arr, item);\n};\n\n/**\n * Filter an array\n */\nH.grep = function (elements, callback) {\n    return [].filter.call(elements, callback);\n};\n\n/**\n * Map an array\n */\nH.map = function (arr, fn) {\n    var results = [],\n        i = 0,\n        len = arr.length;\n\n    for (; i < len; i++) {\n        results[i] = fn.call(arr[i], arr[i], i, arr);\n    }\n\n    return results;\n};\n\n/**\n * Get the element's offset position, corrected by overflow:auto.\n */\nH.offset = function (el) {\n    var docElem = doc.documentElement,\n        box = el.getBoundingClientRect();\n\n    return {\n        top: box.top  + (win.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0),\n        left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n    };\n};\n\n/**\n * Stop running animation.\n * A possible extension to this would be to stop a single property, when\n * we want to continue animating others. Then assign the prop to the timer\n * in the Fx.run method, and check for the prop here. This would be an improvement\n * in all cases where we stop the animation from .attr. Instead of stopping\n * everything, we can just stop the actual attributes we're setting.\n */\nH.stop = function (el) {\n\n    var i = timers.length;\n\n    // Remove timers related to this element (#4519)\n    while (i--) {\n        if (timers[i].elem === el) {\n            timers[i].stopped = true; // #4667\n        }\n    }\n};\n\n/**\n * Utility for iterating over an array.\n * @param {Array} arr\n * @param {Function} fn\n */\nH.each = function (arr, fn, ctx) { // modern browsers\n    return Array.prototype.forEach.call(arr, fn, ctx);\n};\n\n/**\n * Add an event listener\n */\nH.addEvent = function (el, type, fn) {\n    \n    var events = el.hcEvents = el.hcEvents || {};\n\n    function wrappedFn(e) {\n        e.target = e.srcElement || win; // #2820\n        fn.call(el, e);\n    }\n\n    // Handle DOM events in modern browsers\n    if (el.addEventListener) {\n        el.addEventListener(type, fn, false);\n\n    // Handle old IE implementation\n    } else if (el.attachEvent) {\n\n        if (!el.hcEventsIE) {\n            el.hcEventsIE = {};\n        }\n\n        // Link wrapped fn with original fn, so we can get this in removeEvent\n        el.hcEventsIE[fn.toString()] = wrappedFn;\n\n        el.attachEvent('on' + type, wrappedFn);\n    }\n\n    if (!events[type]) {\n        events[type] = [];\n    }\n\n    events[type].push(fn);\n};\n\n/**\n * Remove event added with addEvent\n */\nH.removeEvent = function (el, type, fn) {\n    \n    var events,\n        hcEvents = el.hcEvents,\n        index;\n\n    function removeOneEvent(type, fn) {\n        if (el.removeEventListener) {\n            el.removeEventListener(type, fn, false);\n        } else if (el.attachEvent) {\n            fn = el.hcEventsIE[fn.toString()];\n            el.detachEvent('on' + type, fn);\n        }\n    }\n\n    function removeAllEvents() {\n        var types,\n            len,\n            n;\n\n        if (!el.nodeName) {\n            return; // break on non-DOM events\n        }\n\n        if (type) {\n            types = {};\n            types[type] = true;\n        } else {\n            types = hcEvents;\n        }\n\n        for (n in types) {\n            if (hcEvents[n]) {\n                len = hcEvents[n].length;\n                while (len--) {\n                    removeOneEvent(n, hcEvents[n][len]);\n                }\n            }\n        }\n    }\n\n    if (hcEvents) {\n        if (type) {\n            events = hcEvents[type] || [];\n            if (fn) {\n                index = H.inArray(fn, events);\n                if (index > -1) {\n                    events.splice(index, 1);\n                    hcEvents[type] = events;\n                }\n                removeOneEvent(type, fn);\n\n            } else {\n                removeAllEvents();\n                hcEvents[type] = [];\n            }\n        } else {\n            removeAllEvents();\n            el.hcEvents = {};\n        }\n    }\n};\n\n/**\n * Fire an event on a custom object\n */\nH.fireEvent = function (el, type, eventArguments, defaultFunction) {\n    var e,\n        hcEvents = el.hcEvents,\n        events,\n        len,\n        i,\n        fn;\n\n    eventArguments = eventArguments || {};\n\n    if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {\n        e = doc.createEvent('Events');\n        e.initEvent(type, true, true);\n        e.target = el;\n\n        H.extend(e, eventArguments);\n\n        if (el.dispatchEvent) {\n            el.dispatchEvent(e);\n        } else {\n            el.fireEvent(type, e);\n        }\n\n    } else if (hcEvents) {\n        \n        events = hcEvents[type] || [];\n        len = events.length;\n\n        // Attach a simple preventDefault function to skip default handler if called. \n        // The built-in defaultPrevented property is not overwritable (#5112)\n        if (!eventArguments.preventDefault) {\n            eventArguments.preventDefault = function () {\n                eventArguments.defaultPrevented = true;\n            };\n        }\n\n        eventArguments.target = el;\n\n        // If the type is not set, we're running a custom event (#2297). If it is set,\n        // we're running a browser event, and setting it will cause en error in\n        // IE8 (#2465).\n        if (!eventArguments.type) {\n            eventArguments.type = type;\n        }\n        \n        for (i = 0; i < len; i++) {\n            fn = events[i];\n\n            // If the event handler return false, prevent the default handler from executing\n            if (fn.call(el, eventArguments) === false) {\n                eventArguments.preventDefault();\n            }\n        }\n    }\n            \n    // Run the default if not prevented\n    if (defaultFunction && !eventArguments.defaultPrevented) {\n        defaultFunction(eventArguments);\n    }\n};\n\n/**\n * The global animate method, which uses Fx to create individual animators.\n */\nH.animate = function (el, params, opt) {\n    var start,\n        unit = '',\n        end,\n        fx,\n        args,\n        prop;\n\n    if (!H.isObject(opt)) { // Number or undefined/null\n        args = arguments;\n        opt = {\n            duration: args[2],\n            easing: args[3],\n            complete: args[4]\n        };\n    }\n    if (!H.isNumber(opt.duration)) {\n        opt.duration = 400;\n    }\n    opt.easing = typeof opt.easing === 'function' ? opt.easing : (Math[opt.easing] || Math.easeInOutSine);\n    opt.curAnim = H.merge(params);\n\n    for (prop in params) {\n        fx = new H.Fx(el, opt, prop);\n        end = null;\n\n        if (prop === 'd') {\n            fx.paths = fx.initPath(\n                el,\n                el.d,\n                params.d\n            );\n            fx.toD = params.d;\n            start = 0;\n            end = 1;\n        } else if (el.attr) {\n            start = el.attr(prop);\n        } else {\n            start = parseFloat(H.getStyle(el, prop)) || 0;\n            if (prop !== 'opacity') {\n                unit = 'px';\n            }\n        }\n\n        if (!end) {\n            end = params[prop];\n        }\n        if (end.match && end.match('px')) {\n            end = end.replace(/px/g, ''); // #4351\n        }\n        fx.run(start, end, unit);\n    }\n};\n\n/**\n * Register Highcharts as a plugin in jQuery\n */\nif (win.jQuery) {\n    win.jQuery.fn.highcharts = function () {\n        var args = [].slice.call(arguments);\n\n        if (this[0]) { // this[0] is the renderTo div\n\n            // Create the chart\n            if (args[0]) {\n                new Highcharts[ // eslint-disable-line no-new\n                    H.isString(args[0]) ? args.shift() : 'Chart' // Constructor defaults to Chart\n                ](this[0], args[0], args[1]);\n                return this;\n            }\n\n            // When called without parameters or with the return argument, return an existing chart\n            return charts[H.attr(this[0], 'data-highcharts-chart')];\n        }\n    };\n}\n\n\n/**\n * Compatibility section to add support for legacy IE. This can be removed if old IE \n * support is not needed.\n */\nif (doc && !doc.defaultView) {\n    H.getStyle = function (el, prop) {\n        var val,\n            alias = { width: 'clientWidth', height: 'clientHeight' }[prop];\n            \n        if (el.style[prop]) {\n            return H.pInt(el.style[prop]);\n        }\n        if (prop === 'opacity') {\n            prop = 'filter';\n        }\n\n        // Getting the rendered width and height\n        if (alias) {\n            el.style.zoom = 1;\n            return Math.max(el[alias] - 2 * H.getStyle(el, 'padding'), 0);\n        }\n        \n        val = el.currentStyle[prop.replace(/\\-(\\w)/g, function (a, b) {\n            return b.toUpperCase();\n        })];\n        if (prop === 'filter') {\n            val = val.replace(\n                /alpha\\(opacity=([0-9]+)\\)/, \n                function (a, b) { \n                    return b / 100; \n                }\n            );\n        }\n        \n        return val === '' ? 1 : H.pInt(val);\n    };\n}\n\nif (!Array.prototype.forEach) {\n    H.each = function (arr, fn, ctx) { // legacy\n        var i = 0, \n            len = arr.length;\n        for (; i < len; i++) {\n            if (fn.call(ctx, arr[i], i, arr) === false) {\n                return i;\n            }\n        }\n    };\n}\n\nif (!Array.prototype.indexOf) {\n    H.inArray = function (item, arr) {\n        var len, \n            i = 0;\n\n        if (arr) {\n            len = arr.length;\n            \n            for (; i < len; i++) {\n                if (arr[i] === item) {\n                    return i;\n                }\n            }\n        }\n\n        return -1;\n    };\n}\n\nif (!Array.prototype.filter) {\n    H.grep = function (elements, fn) {\n        var ret = [],\n            i = 0,\n            length = elements.length;\n\n        for (; i < length; i++) {\n            if (fn(elements[i], i)) {\n                ret.push(elements[i]);\n            }\n        }\n\n        return ret;\n    };\n}\n\n//--- End compatibility section ---\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var each = H.each,\n        getTZOffset = H.getTZOffset,\n        isTouchDevice = H.isTouchDevice,\n        merge = H.merge,\n        pick = H.pick,\n        svg = H.svg,\n        win = H.win;\n        \n/* ****************************************************************************\n * Handle the options                                                         *\n *****************************************************************************/\nH.defaultOptions = {\n    ";
if (build.classic) { 
s += "\n    colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c', \n        '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],\n    ";
} 
s += "\n    symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],\n    lang: {\n        loading: 'Loading...',\n        months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',\n                'August', 'September', 'October', 'November', 'December'],\n        shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n        // invalidDate: '',\n        decimalPoint: '.',\n        numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels\n        resetZoom: 'Reset zoom',\n        resetZoomTitle: 'Reset zoom level 1:1',\n        thousandsSep: ' '\n    },\n    global: {\n        useUTC: true,\n        //timezoneOffset: 0,\n        canvasToolsURL: 'http://code.highcharts.com/modules/canvas-tools.js',\n        VMLRadialGradientURL: 'http://code.highcharts.com/5.0-dev/gfx/vml-radial-gradient.png'\n    },\n    chart: {\n        //animation: true,\n        //alignTicks: false,\n        //reflow: true,\n        //className: null,\n        //events: { load, selection },\n        //margin: [null],\n        //marginTop: null,\n        //marginRight: null,\n        //marginBottom: null,\n        //marginLeft: null,\n        borderColor: '#4572A7',\n        //borderWidth: 0,\n        borderRadius: 0,\n        defaultSeriesType: 'line',\n        ignoreHiddenSeries: true,\n        //inverted: false,\n        spacing: [10, 10, 15, 10],\n        //spacingTop: 10,\n        //spacingRight: 10,\n        //spacingBottom: 15,\n        //spacingLeft: 10,\n        //style: {\n        //    fontFamily: '___doublequote___Lucida Grande___doublequote___, ___doublequote___Lucida Sans Unicode___doublequote___, Verdana, Arial, Helvetica, sans-serif', // default font\n        //    fontSize: '12px'\n        //},\n        backgroundColor: '#FFFFFF',\n        //plotBackgroundColor: null,\n        plotBorderColor: '#C0C0C0',\n        //plotBorderWidth: 0,\n        //plotShadow: false,\n        //zoomType: ''\n        resetZoomButton: {\n            theme: {\n                zIndex: 20\n            },\n            position: {\n                align: 'right',\n                x: -10,\n                //verticalAlign: 'top',\n                y: 10\n            }\n            // relativeTo: 'plot'\n        }\n    },\n    ";
if (!build.classic) { 
s += "\n    defs: { // docs\n        dropShadow: { // used by tooltip\n            tag: 'filter',\n            id: 'drop-shadow',\n            opacity: 0.5,\n            children: [{\n                tag: 'feGaussianBlur',\n                in: 'SourceAlpha',\n                stdDeviation: 1\n            }, {\n                tag: 'feOffset',\n                dx: 1,\n                dy: 1\n            }, {\n                tag: 'feComponentTransfer',\n                children: [{\n                    tag: 'feFuncA',\n                    type: 'linear',\n                    slope: 0.3\n                }]\n            }, {\n                tag: 'feMerge',\n                children: [{\n                    tag: 'feMergeNode'\n                }, {\n                    tag: 'feMergeNode',\n                    in: 'SourceGraphic'\n                }]\n            }]\n        }\n    },\n    ";
} 
s += "\n    title: {\n        text: 'Chart title',\n        align: 'center',\n        // floating: false,\n        margin: 15,\n        // x: 0,\n        // verticalAlign: 'top',\n        // y: null,\n        ";
if (build.classic) { 
s += "\n        style: {\n            color: '#333333',\n            fontSize: '18px'\n        },\n        widthAdjust: -44\n\n    },\n    subtitle: {\n        text: '',\n        align: 'center',\n        // floating: false\n        // x: 0,\n        // verticalAlign: 'top',\n        // y: null,\n        ";
if (build.classic) { 
s += "\n        style: {\n            color: '#555555'\n        },\n        widthAdjust: -44\n    },\n\n    plotOptions: {\n        line: { // base series options\n            ";
if (build.classic) { 
s += "\n            //cursor: 'default',\n            //dashStyle: null,\n            //linecap: 'round',\n            lineWidth: 2,\n            //shadow: false,\n            ";
} 
s += "\n            allowPointSelect: false,\n            showCheckbox: false,\n            animation: {\n                duration: 1000\n            },\n            //clip: true,\n            //connectNulls: false,\n            //enableMouseTracking: true,\n            events: {},\n            //legendIndex: 0,\n            // stacking: null,\n            marker: {\n                ";
if (build.classic) { 
s += "\n                lineWidth: 0,\n                lineColor: '#FFFFFF',\n                //fillColor: null,\n                ";
} 
s += "                \n                //enabled: true,\n                //symbol: null,\n                radius: 4,\n                states: { // states for a single point\n                    hover: {\n                        enabled: true,\n                        radiusPlus: 2,\n                        ";
if (build.classic) { 
s += "\n                        lineWidthPlus: 1\n                        ";
} 
s += "\n                    },\n                    ";
if (build.classic) { 
s += "\n                    select: {\n                        fillColor: '#FFFFFF',\n                        lineColor: '#000000',\n                        lineWidth: 2\n                    }\n                    ";
} 
s += "\n                }\n            },\n            point: {\n                events: {}\n            },\n            dataLabels: {\n                align: 'center',\n                // defer: true,\n                // enabled: false,\n                formatter: function () {\n                    return this.y === null ? '' : H.numberFormat(this.y, -1);\n                },\n                ";
if (!build.classic) { 
s += "\n                /*style: {\n                    color: 'contrast',\n                    textShadow: '0 0 6px contrast, 0 0 3px contrast'\n                },*/\n                ";
} else { 
s += "\n                style: {\n                    fontSize: '11px',\n                    fontWeight: 'bold',\n                    color: 'contrast',\n                    textShadow: '0 0 6px contrast, 0 0 3px contrast'\n                },\n                // backgroundColor: undefined,\n                // borderColor: undefined,\n                // borderWidth: undefined,\n                // shadow: false\n                ";
} 
s += "\n                verticalAlign: 'bottom', // above singular point\n                x: 0,\n                y: 0,\n                // borderRadius: undefined,\n                padding: 5\n            },\n            cropThreshold: 300, // draw points outside the plot area when the number of points is less than this\n            pointRange: 0,\n            //pointStart: 0,\n            //pointInterval: 1,\n            //showInLegend: null, // auto: true for standalone series, false for linked series\n            softThreshold: true,\n            states: { // states for the entire series\n                hover: {\n                    //enabled: false,\n                    lineWidthPlus: 1,\n                    marker: {\n                        // lineWidth: base + 1,\n                        // radius: base + 1\n                    },\n                    halo: {\n                        size: 10,\n                        ";
if (build.classic) { 
s += "\n                        opacity: 0.25\n                        ";
} 
s += "\n                    }\n                },\n                select: {\n                    marker: {}\n                }\n            },\n            stickyTracking: true,\n            //tooltip: {\n                //pointFormat: '<span style=___doublequote___color:{point.color}___doublequote___>\\u25CF</span> {series.name}: <b>{point.y}</b>'\n                //valueDecimals: null,\n                //xDateFormat: '%A, %b %e, %Y',\n                //valuePrefix: '',\n                //ySuffix: ''\n            //}\n            turboThreshold: 1000\n            // zIndex: null\n        }\n    },\n    labels: {\n        //items: [],\n        style: {\n            //font: defaultFont,\n            position: 'absolute',\n            color: '#3E576F'\n        }\n    },\n    legend: {\n        enabled: true,\n        align: 'center',\n        //floating: false,\n        layout: 'horizontal',\n        labelFormatter: function () {\n            return this.name;\n        },\n        //borderWidth: 0,\n        borderColor: '#909090',\n        borderRadius: 0,\n        navigation: {\n            ";
if (build.classic) { 
s += "\n            activeColor: '#274b6d',\n            inactiveColor: '#CCC'\n            ";
} 
s += "\n            // animation: true,\n            // arrowSize: 12\n            // style: {} // text styles\n        },\n        // margin: 20,\n        // reversed: false,\n        // backgroundColor: null,\n        /*style: {\n            padding: '5px'\n        },*/\n        ";
if (build.classic) { 
s += "\n        itemStyle: {            \n            color: '#333333',\n            fontSize: '12px',\n            fontWeight: 'bold'\n        },\n        itemHoverStyle: {\n            //cursor: 'pointer', removed as of #601\n            color: '#000'\n        },\n        itemHiddenStyle: {\n            color: '#CCC'\n        },\n        shadow: false,\n        ";
} 
s += "\n        itemCheckboxStyle: {\n            position: 'absolute',\n            width: '13px', // for IE precision\n            height: '13px'\n        },\n        // itemWidth: undefined,\n        // symbolRadius: 0,\n        // symbolWidth: 16,\n        symbolPadding: 5,\n        verticalAlign: 'bottom',\n        // width: undefined,\n        x: 0,\n        y: 0,\n        title: {\n            //text: null,\n            ";
if (build.classic) { 
s += "\n            style: {\n                fontWeight: 'bold'\n            }\n            ";
} 
s += "\n        }            \n    },\n\n    loading: {\n        // hideDuration: 100,\n        // showDuration: 0,\n        ";
if (build.classic) { 
s += "\n        labelStyle: {\n            fontWeight: 'bold',\n            position: 'relative',\n            top: '45%'\n        },\n        style: {\n            position: 'absolute',\n            backgroundColor: 'white',\n            opacity: 0.5,\n            textAlign: 'center'\n        }\n        ";
} 
s += "\n    },\n\n    tooltip: {\n        enabled: true,\n        animation: svg,\n        //crosshairs: null,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n            millisecond: '%A, %b %e, %H:%M:%S.%L',\n            second: '%A, %b %e, %H:%M:%S',\n            minute: '%A, %b %e, %H:%M',\n            hour: '%A, %b %e, %H:%M',\n            day: '%A, %b %e, %Y',\n            week: 'Week from %A, %b %e, %Y',\n            month: '%B %Y',\n            year: '%Y'\n        },\n        footerFormat: '',\n        //formatter: defaultFormatter,\n        /* todo: em font-size when finished comparing against HC4\n        headerFormat: '<span style=___doublequote___font-size: 0.85em___doublequote___>{point.key}</span><br/>',\n        */\n        padding: 8, // docs\n\n        //shape: 'callout',\n        //shared: false,\n        snap: isTouchDevice ? 25 : 10,\n        ";
if (!build.classic) { 
s += "\n        headerFormat: '<span class=___doublequote___highcharts-header___doublequote___>{point.key}</span><br/>',\n        pointFormat: '<span class=___doublequote___highcharts-color-{point.colorIndex}___doublequote___>\\u25CF</span> {series.name}: <b>{point.y}</b><br/>',\n        ";
} else { 
s += "\n        backgroundColor: 'rgba(249, 249, 249, .85)',\n        borderWidth: 1,\n        headerFormat: '<span style=___doublequote___font-size: 10px___doublequote___>{point.key}</span><br/>',\n        pointFormat: '<span style=___doublequote___color:{point.color}___doublequote___>\\u25CF</span> {series.name}: <b>{point.y}</b><br/>',\n        shadow: true,\n        style: {\n            color: '#333333',\n            cursor: 'default',\n            fontSize: '12px',\n            pointerEvents: 'none', // #1686 http://caniuse.com/#feat=pointer-events\n            whiteSpace: 'nowrap'\n        }\n        ";
} 
s += "\n        //xDateFormat: '%A, %b %e, %Y',\n        //valueDecimals: null,\n        //valuePrefix: '',\n        //valueSuffix: ''\n    },\n\n    credits: {\n        enabled: true,\n        href: 'http://www.highcharts.com',\n        position: {\n            align: 'right',\n            x: -10,\n            verticalAlign: 'bottom',\n            y: -5\n        },\n        ";
if (build.classic) { 
s += "\n        style: {\n            cursor: 'pointer',\n            color: '#909090',\n            fontSize: '9px'\n        },\n        ";
} 
s += "\n        text: 'Highcharts.com'\n    }\n};\n\n\n\n/**\n * Set the time methods globally based on the useUTC option. Time method can be either\n * local time or UTC (default).\n */\nfunction setTimeMethods() {\n    var globalOptions = H.defaultOptions.global,\n        Date,\n        useUTC = globalOptions.useUTC,\n        GET = useUTC ? 'getUTC' : 'get',\n        SET = useUTC ? 'setUTC' : 'set';\n\n    H.Date = Date = globalOptions.Date || win.Date; // Allow using a different Date class\n    Date.hcTimezoneOffset = useUTC && globalOptions.timezoneOffset;\n    Date.hcGetTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;\n    Date.hcMakeTime = function (year, month, date, hours, minutes, seconds) {\n        var d;\n        if (useUTC) {\n            d = Date.UTC.apply(0, arguments);\n            d += getTZOffset(d);\n        } else {\n            d = new Date(\n                year,\n                month,\n                pick(date, 1),\n                pick(hours, 0),\n                pick(minutes, 0),\n                pick(seconds, 0)\n            ).getTime();\n        }\n        return d;\n    };\n    each(['Minutes', 'Hours', 'Day', 'Date', 'Month', 'FullYear'], function (s) {\n        Date['hcGet' + s] = GET + s;\n    });\n    each(['Milliseconds', 'Seconds', 'Minutes', 'Hours', 'Date', 'Month', 'FullYear'], function (s) {\n        Date['hcSet' + s] = SET + s;\n    });\n}\n\n/**\n * Merge the default options with custom options and return the new options structure\n * @param {Object} options The new custom options\n */\nH.setOptions = function (options) {\n    \n    // Copy in the default options\n    H.defaultOptions = merge(true, H.defaultOptions, options);\n    \n    // Apply UTC\n    setTimeMethods();\n\n    return H.defaultOptions;\n};\n\n/**\n * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules\n * wasn't enough because the setOptions method created a new object.\n */\nH.getOptions = function () {\n    return H.defaultOptions;\n};\n\n\n// Series defaults\nH.defaultPlotOptions = H.defaultOptions.plotOptions;\nH.defaultSeriesOptions = H.defaultPlotOptions.line;\n\n// set the default time methods\nsetTimeMethods();\n\n    return H;\n}(Highcharts));\n(function (H) {\n\n    var each = H.each,\n        isNumber = H.isNumber,\n        map = H.map,\n        merge = H.merge,\n        pInt = H.pInt;\n/**\n * Handle color operations. The object methods are chainable.\n * @param {String} input The input color in either rbga or hex format\n */\nH.Color = function (input) {\n    // Backwards compatibility, allow instanciation without new\n    if (!(this instanceof H.Color)) {\n        return new H.Color(input);\n    }\n    // Initialize\n    this.init(input);\n};\nH.Color.prototype = {\n\n    // Collection of parsers. This can be extended from the outside by pushing parsers\n    // to Highcharts.Colors.prototype.parsers.\n    parsers: [{\n        // RGBA color\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function (result) {\n            return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];\n        }\n    }, {\n        // HEX color\n        regex: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,\n        parse: function (result) {\n            return [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];\n        }\n    }, {\n        // RGB color\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function (result) {\n            return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];\n        }\n    }],\n\n    /**\n     * Parse the input color to rgba array\n     * @param {String} input\n     */\n    init: function (input) {\n        var result,\n            rgba,\n            i,\n            parser;\n\n        this.input = input;\n\n        // Gradients\n        if (input && input.stops) {\n            this.stops = map(input.stops, function (stop) {\n                return new H.Color(stop[1]);\n            });\n\n        // Solid colors\n        } else {\n            i = this.parsers.length;\n            while (i-- && !rgba) {\n                parser = this.parsers[i];\n                result = parser.regex.exec(input);\n                if (result) {\n                    rgba = parser.parse(result);\n                }\n            }\n        }\n        this.rgba = rgba || [];\n    },\n\n    /**\n     * Return the color a specified format\n     * @param {String} format\n     */\n    get: function (format) {\n        var input = this.input,\n            rgba = this.rgba,\n            ret;\n\n        if (this.stops) {\n            ret = merge(input);\n            ret.stops = [].concat(ret.stops);\n            each(this.stops, function (stop, i) {\n                ret.stops[i] = [ret.stops[i][0], stop.get(format)];\n            });\n\n        // it's NaN if gradient colors on a column chart\n        } else if (rgba && isNumber(rgba[0])) {\n            if (format === 'rgb' || (!format && rgba[3] === 1)) {\n                ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';\n            } else if (format === 'a') {\n                ret = rgba[3];\n            } else {\n                ret = 'rgba(' + rgba.join(',') + ')';\n            }\n        } else {\n            ret = input;\n        }\n        return ret;\n    },\n\n    /**\n     * Brighten the color\n     * @param {Number} alpha\n     */\n    brighten: function (alpha) {\n        var i, \n            rgba = this.rgba;\n\n        if (this.stops) {\n            each(this.stops, function (stop) {\n                stop.brighten(alpha);\n            });\n\n        } else if (isNumber(alpha) && alpha !== 0) {\n            for (i = 0; i < 3; i++) {\n                rgba[i] += pInt(alpha * 255);\n\n                if (rgba[i] < 0) {\n                    rgba[i] = 0;\n                }\n                if (rgba[i] > 255) {\n                    rgba[i] = 255;\n                }\n            }\n        }\n        return this;\n    },\n\n    /**\n     * Set the color's opacity to a given alpha value\n     * @param {Number} alpha\n     */\n    setOpacity: function (alpha) {\n        this.rgba[3] = alpha;\n        return this;\n    }\n};\n\n}(Highcharts));\n(function (H) {\n    var SVGElement,\n        SVGRenderer,\n\n        addEvent = H.addEvent,\n        animate = H.animate,\n        attr = H.attr,\n        charts = H.charts,\n        Color = H.Color,\n        css = H.css,\n        createElement = H.createElement,\n        defined = H.defined,\n        deg2rad = H.deg2rad,\n        destroyObjectProperties = H.destroyObjectProperties,\n        doc = H.doc,\n        each = H.each,\n        extend = H.extend,\n        erase = H.erase,\n        grep = H.grep,\n        hasTouch = H.hasTouch,\n        isArray = H.isArray,\n        isFirefox = H.isFirefox,\n        isMS = H.isMS,\n        isObject = H.isObject,\n        isString = H.isString,\n        isWebKit = H.isWebKit,\n        merge = H.merge,\n        noop = H.noop,\n        pick = H.pick,\n        pInt = H.pInt,\n        removeEvent = H.removeEvent,\n        splat = H.splat,\n        stop = H.stop,\n        svg = H.svg,\n        SVG_NS = H.SVG_NS,\n        useCanVG = H.useCanVG,\n        win = H.win;\n\n/**\n * A wrapper object for SVG elements\n */\nSVGElement = H.SVGElement = function () {\n    return this;\n};\nSVGElement.prototype = {\n\n    // Default base for animation\n    opacity: 1,\n    SVG_NS: SVG_NS,\n    // For labels, these CSS properties are applied to the <text> node directly\n    textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily', 'fontStyle', 'color',\n        'lineHeight', 'width', 'textDecoration', 'textOverflow', 'textShadow'],\n\n    /**\n     * Initialize the SVG renderer\n     * @param {Object} renderer\n     * @param {String} nodeName\n     */\n    init: function (renderer, nodeName) {\n        var wrapper = this;\n        wrapper.element = nodeName === 'span' ?\n                createElement(nodeName) :\n                doc.createElementNS(wrapper.SVG_NS, nodeName);\n        wrapper.renderer = renderer;\n    },\n\n    /**\n     * Animate a given attribute\n     * @param {Object} params\n     * @param {Number} options Options include duration, easing, step and complete\n     * @param {Function} complete Function to perform at the end of animation\n     */\n    animate: function (params, options, complete) {\n        var animOptions = pick(options, this.renderer.globalAnimation, true);\n        stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)\n        if (animOptions) {\n            if (complete) { // allows using a callback with the global animation without overwriting it\n                animOptions.complete = complete;\n            }\n            animate(this, params, animOptions);\n        } else {\n            this.attr(params, null, complete);\n        }\n        return this;\n    },\n\n    /**\n     * Build an SVG gradient out of a common JavaScript configuration object\n     */\n    colorGradient: function (color, prop, elem) {\n        var renderer = this.renderer,\n            colorObject,\n            gradName,\n            gradAttr,\n            radAttr,\n            gradients,\n            gradientObject,\n            stops,\n            stopColor,\n            stopOpacity,\n            radialReference,\n            n,\n            id,\n            key = [],\n            value;\n\n        // Apply linear or radial gradients\n        if (color.linearGradient) {\n            gradName = 'linearGradient';\n        } else if (color.radialGradient) {\n            gradName = 'radialGradient';\n        }\n\n        if (gradName) {\n            gradAttr = color[gradName];\n            gradients = renderer.gradients;\n            stops = color.stops;\n            radialReference = elem.radialReference;\n\n            // Keep < 2.2 kompatibility\n            if (isArray(gradAttr)) {\n                color[gradName] = gradAttr = {\n                    x1: gradAttr[0],\n                    y1: gradAttr[1],\n                    x2: gradAttr[2],\n                    y2: gradAttr[3],\n                    gradientUnits: 'userSpaceOnUse'\n                };\n            }\n\n            // Correct the radial gradient for the radial reference system\n            if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {\n                radAttr = gradAttr; // Save the radial attributes for updating\n                gradAttr = merge(gradAttr,\n                    renderer.getRadialAttr(radialReference, radAttr),\n                    { gradientUnits: 'userSpaceOnUse' }\n                    );\n            }\n\n            // Build the unique key to detect whether we need to create a new element (#1282)\n            for (n in gradAttr) {\n                if (n !== 'id') {\n                    key.push(n, gradAttr[n]);\n                }\n            }\n            for (n in stops) {\n                key.push(stops[n]);\n            }\n            key = key.join(',');\n\n            // Check if a gradient object with the same config object is created within this renderer\n            if (gradients[key]) {\n                id = gradients[key].attr('id');\n\n            } else {\n\n                // Set the id and create the element\n                gradAttr.id = id = 'highcharts-' + H.idCounter++;\n                gradients[key] = gradientObject = renderer.createElement(gradName)\n                    .attr(gradAttr)\n                    .add(renderer.defs);\n\n                gradientObject.radAttr = radAttr;\n\n                // The gradient needs to keep a list of stops to be able to destroy them\n                gradientObject.stops = [];\n                each(stops, function (stop) {\n                    var stopObject;\n                    if (stop[1].indexOf('rgba') === 0) {\n                        colorObject = Color(stop[1]);\n                        stopColor = colorObject.get('rgb');\n                        stopOpacity = colorObject.get('a');\n                    } else {\n                        stopColor = stop[1];\n                        stopOpacity = 1;\n                    }\n                    stopObject = renderer.createElement('stop').attr({\n                        offset: stop[0],\n                        'stop-color': stopColor,\n                        'stop-opacity': stopOpacity\n                    }).add(gradientObject);\n\n                    // Add the stop element to the gradient\n                    gradientObject.stops.push(stopObject);\n                });\n            }\n\n            // Set the reference to the gradient object\n            value = 'url(' + renderer.url + '#' + id + ')';\n            elem.setAttribute(prop, value);\n            elem.gradient = key;\n\n            // Allow the color to be concatenated into tooltips formatters etc. (#2995)\n            color.toString = function () {\n                return value;\n            };\n        }\n    },\n\n    /**\n     * Apply a polyfill to the text-stroke CSS property, by copying the text element\n     * and apply strokes to the copy.\n     *\n     * Contrast checks at http://jsfiddle.net/highcharts/43soe9m1/2/\n     */\n    applyTextShadow: function (textShadow) {\n        var elem = this.element,\n            tspans,\n            hasContrast = textShadow.indexOf('contrast') !== -1,\n            styles = {},\n            forExport = this.renderer.forExport,\n            // IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check\n            // this again with new IE release. In exports, the rendering is passed to PhantomJS.\n            supports = this.renderer.forExport || (elem.style.textShadow !== undefined && !isMS);\n\n        // When the text shadow is set to contrast, use dark stroke for light text and vice versa\n        if (hasContrast) {\n            styles.textShadow = textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));\n        }\n\n        // Safari with retina displays as well as PhantomJS bug (#3974). Firefox does not tolerate this,\n        // it removes the text shadows.\n        if (isWebKit || forExport) {\n            styles.textRendering = 'geometricPrecision';\n        }\n\n        /* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)\n        if (elem.textContent.indexOf('2.') === 0) {\n            elem.style['text-shadow'] = 'none';\n            supports = false;\n        }\n        // */\n\n        // No reason to polyfill, we've got native support\n        if (supports) {\n            this.css(styles); // Apply altered textShadow or textRendering workaround\n        } else {\n\n            this.fakeTS = true; // Fake text shadow\n\n            // In order to get the right y position of the clones,\n            // copy over the y setter\n            this.ySetter = this.xSetter;\n\n            tspans = [].slice.call(elem.getElementsByTagName('tspan'));\n            each(textShadow.split(/\\s?,\\s?/g), function (textShadow) {\n                var firstChild = elem.firstChild,\n                    color,\n                    strokeWidth;\n\n                textShadow = textShadow.split(' ');\n                color = textShadow[textShadow.length - 1];\n\n                // Approximately tune the settings to the text-shadow behaviour\n                strokeWidth = textShadow[textShadow.length - 2];\n\n                if (strokeWidth) {\n                    each(tspans, function (tspan, y) {\n                        var clone;\n\n                        // Let the first line start at the correct X position\n                        if (y === 0) {\n                            tspan.setAttribute('x', elem.getAttribute('x'));\n                            y = elem.getAttribute('y');\n                            tspan.setAttribute('y', y || 0);\n                            if (y === null) {\n                                elem.setAttribute('y', 0);\n                            }\n                        }\n\n                        // Create the clone and apply shadow properties\n                        clone = tspan.cloneNode(1);\n                        attr(clone, {\n                            'class': 'highcharts-text-shadow',\n                            'fill': color,\n                            'stroke': color,\n                            'stroke-opacity': 1 / Math.max(pInt(strokeWidth), 3),\n                            'stroke-width': strokeWidth,\n                            'stroke-linejoin': 'round'\n                        });\n                        elem.insertBefore(clone, firstChild);\n                    });\n                }\n            });\n        }\n    },\n\n    /**\n     * Set or get a given attribute\n     * @param {Object|String} hash\n     * @param {Mixed|Undefined} val\n     */\n    attr: function (hash, val, complete) {\n        var key,\n            value,\n            element = this.element,\n            hasSetSymbolSize,\n            ret = this,\n            skipAttr,\n            setter;\n\n        // single key-value pair\n        if (typeof hash === 'string' && val !== undefined) {\n            key = hash;\n            hash = {};\n            hash[key] = val;\n        }\n\n        // used as a getter: first argument is a string, second is undefined\n        if (typeof hash === 'string') {\n            ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);\n\n        // setter\n        } else {\n\n            for (key in hash) {\n                value = hash[key];\n                skipAttr = false;\n\n\n\n                if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {\n                    if (!hasSetSymbolSize) {\n                        this.symbolAttr(hash);\n                        hasSetSymbolSize = true;\n                    }\n                    skipAttr = true;\n                }\n\n                if (this.rotation && (key === 'x' || key === 'y')) {\n                    this.doTransform = true;\n                }\n\n                if (!skipAttr) {\n                    setter = this[key + 'Setter'] || this._defaultSetter;\n                    setter.call(this, value, key, element);\n\n                    ";
if (build.classic) { 
s += "\n                    // Let the shadow follow the main element\n                    if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {\n                        this.updateShadows(key, value, setter);\n                    }\n                    ";
} 
s += "\n                }\n            }\n\n            // Update transform. Do this outside the loop to prevent redundant updating for batch setting\n            // of attributes.\n            if (this.doTransform) {\n                this.updateTransform();\n                this.doTransform = false;\n            }\n\n        }\n\n        // In accordance with animate, run a complete callback\n        if (complete) {\n            complete();\n        }\n\n        return ret;\n    },\n\n    ";
if (build.classic) { 
s += "\n    /**\n     * Update the shadow elements with new attributes\n     * @param   {String}        key    The attribute name\n     * @param   {String|Number} value  The value of the attribute\n     * @param   {Function}      setter The setter function, inherited from the parent wrapper\n     * @returns {undefined}\n     */\n    updateShadows: function (key, value, setter) {\n        var shadows = this.shadows,\n            i = shadows.length;\n\n        while (i--) {\n            setter.call(\n                shadows[i], \n                key === 'height' ?\n                    Math.max(value - (shadows[i].cutHeight || 0), 0) :\n                    key === 'd' ? this.d : value, \n                key, \n                shadows[i]\n            );\n        }\n    },\n    ";
} 
s += "\n\n    /**\n     * Add a class name to an element\n     */\n    addClass: function (className, replace) {\n        var element = this.element,\n            currentClassName = attr(element, 'class') || '';\n\n        if (currentClassName.indexOf(className) === -1) {\n            if (!replace) {\n                className = (currentClassName + (currentClassName ? ' ' : '') + className).replace('  ', ' ');\n            }\n            attr(element, 'class', className);\n        }\n        return this;\n    },\n    hasClass: function (className) {\n        return attr(this.element, 'class').indexOf(className) !== -1;\n    },\n    removeClass: function (className) {\n        attr(this.element, 'class', (attr(this.element, 'class') || '').replace(className, ''));\n        return this;\n    },\n\n    /**\n     * If one of the symbol size affecting parameters are changed,\n     * check all the others only once for each call to an element's\n     * .attr() method\n     * @param {Object} hash\n     */\n    symbolAttr: function (hash) {\n        var wrapper = this;\n\n        each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {\n            wrapper[key] = pick(hash[key], wrapper[key]);\n        });\n\n        wrapper.attr({\n            d: wrapper.renderer.symbols[wrapper.symbolName](\n                wrapper.x,\n                wrapper.y,\n                wrapper.width,\n                wrapper.height,\n                wrapper\n            )\n        });\n    },\n\n    /**\n     * Apply a clipping path to this object\n     * @param {String} id\n     */\n    clip: function (clipRect) {\n        return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : 'none');\n    },\n\n    /**\n     * Calculate the coordinates needed for drawing a rectangle crisply and return the\n     * calculated attributes\n     * @param {Number} strokeWidth\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Number} width\n     * @param {Number} height\n     */\n    crisp: function (rect, strokeWidth) {\n\n        var wrapper = this,\n            key,\n            attribs = {},\n            normalizer;\n\n        strokeWidth = strokeWidth || rect.strokeWidth || 0;\n        normalizer = Math.round(strokeWidth) % 2 / 2; // Math.round because strokeWidth can sometimes have roundoff errors\n\n        // normalize for crisp edges\n        rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;\n        rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;\n        rect.width = Math.floor((rect.width || wrapper.width || 0) - 2 * normalizer);\n        rect.height = Math.floor((rect.height || wrapper.height || 0) - 2 * normalizer);\n        if (defined(rect.strokeWidth)) {\n            rect.strokeWidth = strokeWidth;\n        }\n\n        for (key in rect) {\n            if (wrapper[key] !== rect[key]) { // only set attribute if changed\n                wrapper[key] = attribs[key] = rect[key];\n            }\n        }\n\n        return attribs;\n    },\n\n    /**\n     * Set styles for the element\n     * @param {Object} styles\n     */\n    css: function (styles) {\n        var elemWrapper = this,\n            oldStyles = elemWrapper.styles,\n            newStyles = {},\n            elem = elemWrapper.element,\n            textWidth,\n            n,\n            serializedCss = '',\n            hyphenate,\n            hasNew = !oldStyles;\n\n        // convert legacy\n        if (styles && styles.color) {\n            styles.fill = styles.color;\n        }\n\n        // Filter out existing styles to increase performance (#2640)\n        if (oldStyles) {\n            for (n in styles) {\n                if (styles[n] !== oldStyles[n]) {\n                    newStyles[n] = styles[n];\n                    hasNew = true;\n                }\n            }\n        }\n        if (hasNew) {\n            textWidth = elemWrapper.textWidth =\n                (styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) ||\n                elemWrapper.textWidth; // #3501\n\n            // Merge the new styles with the old ones\n            if (oldStyles) {\n                styles = extend(\n                    oldStyles,\n                    newStyles\n                );\n            }\n\n            // store object\n            elemWrapper.styles = styles;\n\n            if (textWidth && (useCanVG || (!svg && elemWrapper.renderer.forExport))) {\n                delete styles.width;\n            }\n\n            // serialize and set style attribute\n            if (isMS && !svg) {\n                css(elemWrapper.element, styles);\n            } else {\n                hyphenate = function (a, b) {\n                    return '-' + b.toLowerCase();\n                };\n                for (n in styles) {\n                    serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';\n                }\n                attr(elem, 'style', serializedCss); // #1881\n            }\n\n\n            // re-build text\n            if (textWidth && elemWrapper.added) {\n                elemWrapper.renderer.buildText(elemWrapper);\n            }\n        }\n\n        return elemWrapper;\n    },\n\n    ";
if (build.classic) { 
s += "\n    strokeWidth: function () {\n        return this['stroke-width'] || 0;\n    },\n\n    ";
} else { 
s += "\n    /**\n     * Get a computed style\n     */\n    getStyle: function (prop) {\n        return win.getComputedStyle(this.element || this, '').getPropertyValue(prop);\n    },\n\n    /**\n     * Get a computed style in pixel values\n     */\n    strokeWidth: function () {\n        var val = this.getStyle('stroke-width'),\n            ret,\n            dummy;\n\n        // Read pixel values directly\n        if (val.indexOf('px') === val.length - 2) {\n            ret = pInt(val);\n\n        // Other values like em, pt etc need to be measured\n        } else {\n            dummy = doc.createElementNS(SVG_NS, 'rect');\n            attr(dummy, {\n                'width': val,\n                'stroke-width': 0\n            });\n            this.element.parentNode.appendChild(dummy);\n            ret = dummy.getBBox().width;\n            dummy.parentNode.removeChild(dummy);\n        }\n        return ret;\n    },\n    ";
} 
s += "\n    /**\n     * Add an event listener\n     * @param {String} eventType\n     * @param {Function} handler\n     */\n    on: function (eventType, handler) {\n        var svgElement = this,\n            element = svgElement.element;\n\n        // touch\n        if (hasTouch && eventType === 'click') {\n            element.ontouchstart = function (e) {\n                svgElement.touchEventFired = Date.now();\n                e.preventDefault();\n                handler.call(element, e);\n            };\n            element.onclick = function (e) {                                                \n                if (win.navigator.userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269\n                    handler.call(element, e);\n                }\n            };\n        } else {\n            // simplest possible event model for internal use\n            element['on' + eventType] = handler;\n        }\n        return this;\n    },\n\n    /**\n     * Set the coordinates needed to draw a consistent radial gradient across\n     * pie slices regardless of positioning inside the chart. The format is\n     * [centerX, centerY, diameter] in pixels.\n     */\n    setRadialReference: function (coordinates) {\n        var existingGradient = this.renderer.gradients[this.element.gradient];\n\n        this.element.radialReference = coordinates;\n\n        // On redrawing objects with an existing gradient, the gradient needs\n        // to be repositioned (#3801)\n        if (existingGradient && existingGradient.radAttr) {\n            existingGradient.animate(\n                this.renderer.getRadialAttr(\n                    coordinates,\n                    existingGradient.radAttr\n                )\n            );\n        }\n\n        return this;\n    },\n\n    /**\n     * Move an object and its children by x and y values\n     * @param {Number} x\n     * @param {Number} y\n     */\n    translate: function (x, y) {\n        return this.attr({\n            translateX: x,\n            translateY: y\n        });\n    },\n\n    /**\n     * Invert a group, rotate and flip\n     */\n    invert: function () {\n        var wrapper = this;\n        wrapper.inverted = true;\n        wrapper.updateTransform();\n        return wrapper;\n    },\n\n    /**\n     * Private method to update the transform attribute based on internal\n     * properties\n     */\n    updateTransform: function () {\n        var wrapper = this,\n            translateX = wrapper.translateX || 0,\n            translateY = wrapper.translateY || 0,\n            scaleX = wrapper.scaleX,\n            scaleY = wrapper.scaleY,\n            inverted = wrapper.inverted,\n            rotation = wrapper.rotation,\n            element = wrapper.element,\n            transform;\n\n        // flipping affects translate as adjustment for flipping around the group's axis\n        if (inverted) {\n            translateX += wrapper.attr('width');\n            translateY += wrapper.attr('height');\n        }\n\n        // Apply translate. Nearly all transformed elements have translation, so instead\n        // of checking for translate = 0, do it always (#1767, #1846).\n        transform = ['translate(' + translateX + ',' + translateY + ')'];\n\n        // apply rotation\n        if (inverted) {\n            transform.push('rotate(90) scale(-1,1)');\n        } else if (rotation) { // text rotation\n            transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');\n\n            // Delete bBox memo when the rotation changes\n            //delete wrapper.bBox;\n        }\n\n        // apply scale\n        if (defined(scaleX) || defined(scaleY)) {\n            transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n        }\n\n        if (transform.length) {\n            element.setAttribute('transform', transform.join(' '));\n        }\n    },\n    /**\n     * Bring the element to the front\n     */\n    toFront: function () {\n        var element = this.element;\n        element.parentNode.appendChild(element);\n        return this;\n    },\n\n\n    /**\n     * Break down alignment options like align, verticalAlign, x and y\n     * to x and y relative to the chart.\n     *\n     * @param {Object} alignOptions\n     * @param {Boolean} alignByTranslate\n     * @param {String[Object} box The box to align to, needs a width and height. When the\n     *        box is a string, it refers to an object in the Renderer. For example, when\n     *        box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height\n     *        x and y properties.\n     *\n     */\n    align: function (alignOptions, alignByTranslate, box) {\n        var align,\n            vAlign,\n            x,\n            y,\n            attribs = {},\n            alignTo,\n            renderer = this.renderer,\n            alignedObjects = renderer.alignedObjects,\n            alignFactor,\n            vAlignFactor;\n\n        // First call on instanciate\n        if (alignOptions) {\n            this.alignOptions = alignOptions;\n            this.alignByTranslate = alignByTranslate;\n            if (!box || isString(box)) { // boxes other than renderer handle this internally\n                this.alignTo = alignTo = box || 'renderer';\n                erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize\n                alignedObjects.push(this);\n                box = null; // reassign it below\n            }\n\n        // When called on resize, no arguments are supplied\n        } else {\n            alignOptions = this.alignOptions;\n            alignByTranslate = this.alignByTranslate;\n            alignTo = this.alignTo;\n        }\n\n        box = pick(box, renderer[alignTo], renderer);\n\n        // Assign variables\n        align = alignOptions.align;\n        vAlign = alignOptions.verticalAlign;\n        x = (box.x || 0) + (alignOptions.x || 0); // default: left align\n        y = (box.y || 0) + (alignOptions.y || 0); // default: top align\n\n        // Align\n        if (align === 'right') {\n            alignFactor = 1;\n        } else if (align === 'center') {\n            alignFactor = 2;\n        }\n        if (alignFactor) {\n            x += (box.width - (alignOptions.width || 0)) / alignFactor;\n        }\n        attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);\n\n\n        // Vertical align\n        if (vAlign === 'bottom') {\n            vAlignFactor = 1;\n        } else if (vAlign === 'middle') {\n            vAlignFactor = 2;\n        }\n        if (vAlignFactor) {\n            y += (box.height - (alignOptions.height || 0)) / vAlignFactor;\n        }\n        attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);\n\n        // Animate only if already placed\n        this[this.placed ? 'animate' : 'attr'](attribs);\n        this.placed = true;\n        this.alignAttr = attribs;\n\n        return this;\n    },\n\n    /**\n     * Get the bounding box (width, height, x and y) for the element\n     */\n    getBBox: function (reload, rot) {\n        var wrapper = this,\n            bBox, // = wrapper.bBox,\n            renderer = wrapper.renderer,\n            width,\n            height,\n            rotation,\n            rad,\n            element = wrapper.element,\n            styles = wrapper.styles,\n            textStr = wrapper.textStr,\n            textShadow,\n            elemStyle = element.style,\n            toggleTextShadowShim,\n            cache = renderer.cache,\n            cacheKeys = renderer.cacheKeys,\n            cacheKey;\n\n        rotation = pick(rot, wrapper.rotation);\n        rad = rotation * deg2rad;\n\n        if (textStr !== undefined) {\n\n            // Properties that affect bounding box\n            cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');\n\n            // Since numbers are monospaced, and numerical labels appear a lot in a chart,\n            // we assume that a label of n characters has the same bounding box as others\n            // of the same length.\n            if (textStr === '' || /^[0-9]+$/.test(textStr)) {\n                cacheKey = 'num:' + textStr.toString().length + cacheKey;\n\n            // Caching all strings reduces rendering time by 4-5%.\n            } else {\n                cacheKey = textStr + cacheKey;\n            }\n        }\n\n        if (cacheKey && !reload) {\n            bBox = cache[cacheKey];\n        }\n\n        // No cache found\n        if (!bBox) {\n\n            // SVG elements\n            if (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {\n                try { // Fails in Firefox if the container has display: none.\n\n                    // When the text shadow shim is used, we need to hide the fake shadows\n                    // to get the correct bounding box (#3872)\n                    toggleTextShadowShim = this.fakeTS && function (display) {\n                        each(element.querySelectorAll('.highcharts-text-shadow'), function (tspan) {\n                            tspan.style.display = display;\n                        });\n                    };\n\n                    // Workaround for #3842, Firefox reporting wrong bounding box for shadows\n                    if (isFirefox && elemStyle.textShadow) {\n                        textShadow = elemStyle.textShadow;\n                        elemStyle.textShadow = '';\n                    } else if (toggleTextShadowShim) {\n                        toggleTextShadowShim('none');\n                    }\n\n                    bBox = element.getBBox ?\n                        // SVG: use extend because IE9 is not allowed to change width and height in case\n                        // of rotation (below)\n                        extend({}, element.getBBox()) :\n                        // Canvas renderer and legacy IE in export mode\n                        {\n                            width: element.offsetWidth,\n                            height: element.offsetHeight\n                        };\n\n                    // #3842\n                    if (textShadow) {\n                        elemStyle.textShadow = textShadow;\n                    } else if (toggleTextShadowShim) {\n                        toggleTextShadowShim('');\n                    }\n                } catch (e) {}\n\n                // If the bBox is not set, the try-catch block above failed. The other condition\n                // is for Opera that returns a width of -Infinity on hidden elements.\n                if (!bBox || bBox.width < 0) {\n                    bBox = { width: 0, height: 0 };\n                }\n\n\n            // VML Renderer or useHTML within SVG\n            } else {\n\n                bBox = wrapper.htmlGetBBox();\n\n            }\n\n            // True SVG elements as well as HTML elements in modern browsers using the .useHTML option\n            // need to compensated for rotation\n            if (renderer.isSVG) {\n                width = bBox.width;\n                height = bBox.height;\n\n                // Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)\n                if (isMS && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {\n                    bBox.height = height = 14;\n                }\n\n                // Adjust for rotated text\n                if (rotation) {\n                    bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));\n                    bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));\n                }\n            }\n\n            // Cache it\n            if (cacheKey) {\n\n                // Rotate (#4681)\n                while (cacheKeys.length > 250) {\n                    delete cache[cacheKeys.shift()];\n                }\n\n                if (!cache[cacheKey]) {\n                    cacheKeys.push(cacheKey);\n                }\n                cache[cacheKey] = bBox;\n            }\n        }\n        return bBox;\n    },\n\n    /**\n     * Show the element\n     */\n    show: function (inherit) {\n        return this.attr({ visibility: inherit ? 'inherit' : 'visible' });\n    },\n\n    /**\n     * Hide the element\n     */\n    hide: function () {\n        return this.attr({ visibility: 'hidden' });\n    },\n\n    fadeOut: function (duration) {\n        var elemWrapper = this;\n        elemWrapper.animate({\n            opacity: 0\n        }, {\n            duration: duration || 150,\n            complete: function () {\n                elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips\n            }\n        });\n    },\n\n    /**\n     * Add the element\n     * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined\n     *    to append the element to the renderer.box.\n     */\n    add: function (parent) {\n\n        var renderer = this.renderer,\n            element = this.element,\n            inserted;\n\n        if (parent) {\n            this.parentGroup = parent;\n        }\n\n        // mark as inverted\n        this.parentInverted = parent && parent.inverted;\n\n        // build formatted text\n        if (this.textStr !== undefined) {\n            renderer.buildText(this);\n        }\n\n        // Mark as added\n        this.added = true;\n\n        // If we're adding to renderer root, or other elements in the group\n        // have a z index, we need to handle it\n        if (!parent || parent.handleZ || this.zIndex) {\n            inserted = this.zIndexSetter();\n        }\n\n        // If zIndex is not handled, append at the end\n        if (!inserted) {\n            (parent ? parent.element : renderer.box).appendChild(element);\n        }\n\n        // fire an event for internal hooks\n        if (this.onAdd) {\n            this.onAdd();\n        }\n\n        return this;\n    },\n\n    /**\n     * Removes a child either by removeChild or move to garbageBin.\n     * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n     */\n    safeRemoveChild: function (element) {\n        var parentNode = element.parentNode;\n        if (parentNode) {\n            parentNode.removeChild(element);\n        }\n    },\n\n    /**\n     * Destroy the element and element wrapper\n     */\n    destroy: function () {\n        var wrapper = this,\n            element = wrapper.element || {},\n            parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,\n            grandParent,\n            key,\n            i;\n\n        // remove events\n        element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;\n        stop(wrapper); // stop running animations\n\n        if (wrapper.clipPath) {\n            wrapper.clipPath = wrapper.clipPath.destroy();\n        }\n\n        // Destroy stops in case this is a gradient object\n        if (wrapper.stops) {\n            for (i = 0; i < wrapper.stops.length; i++) {\n                wrapper.stops[i] = wrapper.stops[i].destroy();\n            }\n            wrapper.stops = null;\n        }\n\n        // remove element\n        wrapper.safeRemoveChild(element);\n\n        ";
if (build.classic) { 
s += "\n        // Destroy shadows\n        var shadows = wrapper.shadows;\n        if (shadows) {\n            each(shadows, function (shadow) {\n                wrapper.safeRemoveChild(shadow);\n            });\n        }\n        ";
} 
s += "\n\n        // In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).\n        while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {\n            grandParent = parentToClean.parentGroup;\n            wrapper.safeRemoveChild(parentToClean.div);\n            delete parentToClean.div;\n            parentToClean = grandParent;\n        }\n\n        // remove from alignObjects\n        if (wrapper.alignTo) {\n            erase(wrapper.renderer.alignedObjects, wrapper);\n        }\n\n        for (key in wrapper) {\n            delete wrapper[key];\n        }\n\n        return null;\n    },\n\n    ";
if (build.classic) { 
s += "\n    /**\n     * Add a shadow to the element. Must be done after the element is added to the DOM\n     * @param {Boolean|Object} shadowOptions\n     */\n    shadow: function (shadowOptions, group, cutOff) {\n        var shadows = [],\n            i,\n            shadow,\n            element = this.element,\n            strokeWidth,\n            shadowWidth,\n            shadowElementOpacity,\n\n            // compensate for inverted plot area\n            transform;\n\n\n        if (shadowOptions) {\n            shadowWidth = pick(shadowOptions.width, 3);\n            shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n            transform = this.parentInverted ?\n                    '(-1,-1)' :\n                    '(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';\n            for (i = 1; i <= shadowWidth; i++) {\n                shadow = element.cloneNode(0);\n                strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n                attr(shadow, {\n                    'isShadow': 'true',\n                    'stroke': shadowOptions.color || 'black',\n                    'stroke-opacity': shadowElementOpacity * i,\n                    'stroke-width': strokeWidth,\n                    'transform': 'translate' + transform,\n                    'fill': 'none'\n                });\n                if (cutOff) {\n                    attr(shadow, 'height', Math.max(attr(shadow, 'height') - strokeWidth, 0));\n                    shadow.cutHeight = strokeWidth;\n                }\n\n                if (group) {\n                    group.element.appendChild(shadow);\n                } else {\n                    element.parentNode.insertBefore(shadow, element);\n                }\n\n                shadows.push(shadow);\n            }\n\n            this.shadows = shadows;\n        }\n        return this;\n\n    },\n    ";
} 
s += "\n\n    xGetter: function (key) {\n        if (this.element.nodeName === 'circle') {\n            if (key === 'x') {\n                key = 'cx';\n            } else if (key === 'y') {\n                key = 'cy';\n            }\n        }\n        return this._defaultGetter(key);\n    },\n\n    /**\n     * Get the current value of an attribute or pseudo attribute, used mainly\n     * for animation.\n     */\n    _defaultGetter: function (key) {\n        var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);\n\n        if (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n            ret = parseFloat(ret);\n        }\n        return ret;\n    },\n\n\n    dSetter: function (value, key, element) {\n        if (value && value.join) { // join path\n            value = value.join(' ');\n        }\n        if (/(NaN| {2}|^$)/.test(value)) {\n            value = 'M 0 0';\n        }\n        element.setAttribute(key, value);\n\n        this[key] = value;\n    },\n    ";
if (build.classic) { 
s += "\n    dashstyleSetter: function (value) {\n        var i,\n            strokeWidth = this['stroke-width'];\n        \n        // If ___doublequote___inherit___doublequote___, like maps in IE, assume 1 (#4981). With HC5 and the new strokeWidth \n        // function, we should be able to use that instead.\n        if (strokeWidth === 'inherit') {\n            strokeWidth = 1;\n        }\n        value = value && value.toLowerCase();\n        if (value) {\n            value = value\n                .replace('shortdashdotdot', '3,1,1,1,1,1,')\n                .replace('shortdashdot', '3,1,1,1')\n                .replace('shortdot', '1,1,')\n                .replace('shortdash', '3,1,')\n                .replace('longdash', '8,3,')\n                .replace(/dot/g, '1,3,')\n                .replace('dash', '4,3,')\n                .replace(/,$/, '')\n                .split(','); // ending comma\n\n            i = value.length;\n            while (i--) {\n                value[i] = pInt(value[i]) * strokeWidth;\n            }\n            value = value.join(',')\n                .replace(/NaN/g, 'none'); // #3226\n            this.element.setAttribute('stroke-dasharray', value);\n        }\n    },\n    ";
} 
s += "\n    alignSetter: function (value) {\n        var convert = { left: 'start', center: 'middle', right: 'end' };\n        this.element.setAttribute('text-anchor', convert[value]);\n    },\n    opacitySetter: function (value, key, element) {\n        this[key] = value;\n        element.setAttribute(key, value);\n    },\n    titleSetter: function (value) {\n        var titleNode = this.element.getElementsByTagName('title')[0];\n        if (!titleNode) {\n            titleNode = doc.createElementNS(this.SVG_NS, 'title');\n            this.element.appendChild(titleNode);\n        }\n\n        // Remove text content if it exists\n        if (titleNode.firstChild) {\n            titleNode.removeChild(titleNode.firstChild);\n        }\n\n        titleNode.appendChild(\n            doc.createTextNode(\n                (String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895\n            )\n        );\n    },\n    textSetter: function (value) {\n        if (value !== this.textStr) {\n            // Delete bBox memo when the text changes\n            delete this.bBox;\n\n            this.textStr = value;\n            if (this.added) {\n                this.renderer.buildText(this);\n            }\n        }\n    },\n    fillSetter: function (value, key, element) {\n        if (typeof value === 'string') {\n            element.setAttribute(key, value);\n        } else if (value) {\n            this.colorGradient(value, key, element);\n        }\n    },\n    visibilitySetter: function (value, key, element) {\n        // IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881, #3909)\n        if (value === 'inherit') {\n            element.removeAttribute(key);\n        } else {\n            element.setAttribute(key, value);\n        }\n    },\n    zIndexSetter: function (value, key) {\n        var renderer = this.renderer,\n            parentGroup = this.parentGroup,\n            parentWrapper = parentGroup || renderer,\n            parentNode = parentWrapper.element || renderer.box,\n            childNodes,\n            otherElement,\n            otherZIndex,\n            element = this.element,\n            inserted,\n            run = this.added,\n            i;\n\n        if (defined(value)) {\n            element.zIndex = value; // So we can read it for other elements in the group\n            value = +value;\n            if (this[key] === value) { // Only update when needed (#3865)\n                run = false;\n            }\n            this[key] = value;\n        }\n\n        // Insert according to this and other elements' zIndex. Before .add() is called,\n        // nothing is done. Then on add, or by later calls to zIndexSetter, the node\n        // is placed on the right place in the DOM.\n        if (run) {\n            value = this.zIndex;\n\n            if (value && parentGroup) {\n                parentGroup.handleZ = true;\n            }\n\n            childNodes = parentNode.childNodes;\n            for (i = 0; i < childNodes.length && !inserted; i++) {\n                otherElement = childNodes[i];\n                otherZIndex = otherElement.zIndex;\n                if (otherElement !== element && (\n                        // Insert before the first element with a higher zIndex\n                        pInt(otherZIndex) > value ||\n                        // If no zIndex given, insert before the first element with a zIndex\n                        (!defined(value) && defined(otherZIndex))\n\n                    )) {\n                    parentNode.insertBefore(element, otherElement);\n                    inserted = true;\n                }\n            }\n            if (!inserted) {\n                parentNode.appendChild(element);\n            }\n        }\n        return inserted;\n    },\n    _defaultSetter: function (value, key, element) {\n        // if (key === 'width' && isNaN(value)) debugger;\n        element.setAttribute(key, value);\n    }\n};\n\n// Some shared setters and getters\nSVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\nSVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =\n        SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =\n        SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {\n            this[key] = value;\n            this.doTransform = true;\n        };\n\n";
if (build.classic) { 
s += "\n// WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the \n// stroke attribute altogether. #1270, #1369, #3065, #3072.\nSVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {\n    this[key] = value;\n    // Only apply the stroke attribute if the stroke width is defined and larger than 0\n    if (this.stroke && this['stroke-width']) {\n        SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden\n        element.setAttribute('stroke-width', this['stroke-width']);\n        this.hasStroke = true;\n    } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {\n        element.removeAttribute('stroke');\n        this.hasStroke = false;\n    }\n};\n";
} 
s += "\n\n/**\n * The default SVG renderer\n */\nSVGRenderer = H.SVGRenderer = function () {\n    this.init.apply(this, arguments);\n};\nSVGRenderer.prototype = {\n    Element: SVGElement,\n    SVG_NS: SVG_NS,\n    /**\n     * Initialize the SVGRenderer\n     * @param {Object} container\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Boolean} forExport\n     */\n    init: function (container, width, height, style, forExport, allowHTML) {\n        var renderer = this,\n            boxWrapper,\n            element,\n            desc;\n\n        boxWrapper = renderer.createElement('svg')\n            .attr({\n                'version': '1.1',\n                'class': 'highcharts-root'\n            })\n            ";
if (build.classic) { 
s += "\n            .css(this.getStyle(style))\n            ";
} 
s += ";\n        element = boxWrapper.element;\n        container.appendChild(element);\n\n        // For browsers other than IE, add the namespace attribute (#1978)\n        if (container.innerHTML.indexOf('xmlns') === -1) {\n            attr(element, 'xmlns', this.SVG_NS);\n        }\n\n        // object properties\n        renderer.isSVG = true;\n        renderer.box = element;\n        renderer.boxWrapper = boxWrapper;\n        renderer.alignedObjects = [];\n\n        // Page url used for internal references. #24, #672, #1070\n        renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?\n                win.location.href\n                    .replace(/#.*?$/, '') // remove the hash\n                    .replace(/([\\('\\)])/g, '\\\\$1') // escape parantheses and quotes\n                    .replace(/ /g, '%20') : // replace spaces (needed for Safari only)\n                '';\n\n        // Add description\n        desc = this.createElement('desc').add();\n        desc.element.appendChild(doc.createTextNode('Created with Highcharts 5.0-dev'));\n\n\n        renderer.defs = this.createElement('defs').add();\n        renderer.allowHTML = allowHTML;\n        renderer.forExport = forExport;\n        renderer.gradients = {}; // Object where gradient SvgElements are stored\n        renderer.cache = {}; // Cache for numerical bounding boxes\n        renderer.cacheKeys = [];\n        renderer.imgCount = 0;\n\n        renderer.setSize(width, height, false);\n\n        \n\n        // Issue 110 workaround:\n        // In Firefox, if a div is positioned by percentage, its pixel position may land\n        // between pixels. The container itself doesn't display this, but an SVG element\n        // inside this container will be drawn at subpixel precision. In order to draw\n        // sharp lines, this must be compensated for. This doesn't seem to work inside\n        // iframes though (like in jsFiddle).\n        var subPixelFix, rect;\n        if (isFirefox && container.getBoundingClientRect) {\n            renderer.subPixelFix = subPixelFix = function () {\n                css(container, { left: 0, top: 0 });\n                rect = container.getBoundingClientRect();\n                css(container, {\n                    left: (Math.ceil(rect.left) - rect.left) + 'px',\n                    top: (Math.ceil(rect.top) - rect.top) + 'px'\n                });\n            };\n\n            // run the fix now\n            subPixelFix();\n\n            // run it on resize\n            addEvent(win, 'resize', subPixelFix);\n        }\n    },\n    ";
if (!build.classic) { 
s += "\n    /**\n     * General method for adding a definition. Can be used for gradients, fills, filters etc. // docs\n     */\n    addDefinition: function (def) {\n        var ren = this;\n\n        function recurse(config, parent) {\n            each(splat(config), function (item) {\n                var node = ren.createElement(item.tag),\n                    key,\n                    attr = {};\n\n                // Set attributes\n                for (key in item) {\n                    if (key !== 'tag' && key !== 'children') {\n                        attr[key] = item[key];\n                    }\n                }\n                node.attr(attr);\n\n                // Add to the tree\n                node.add(parent || ren.defs);\n\n                // Recurse\n                recurse(item.children || [], node);\n            });\n        }\n        recurse(def);\n    },\n    ";
} 
s += "\n\n    ";
if (build.classic) { 
s += "\n    getStyle: function (style) {\n        this.style = extend({\n            \n            fontFamily: '___doublequote___Lucida Grande___doublequote___, ___doublequote___Lucida Sans Unicode___doublequote___, Arial, Helvetica, sans-serif', // default font\n            fontSize: '12px'\n\n        }, style);\n        return this.style;\n    },\n    ";
} 
s += "\n\n    /**\n     * Detect whether the renderer is hidden. This happens when one of the parent elements\n     * has display: none. #608.\n     */\n    isHidden: function () {\n        return !this.boxWrapper.getBBox().width;\n    },\n\n    /**\n     * Destroys the renderer and its allocated members.\n     */\n    destroy: function () {\n        var renderer = this,\n            rendererDefs = renderer.defs;\n        renderer.box = null;\n        renderer.boxWrapper = renderer.boxWrapper.destroy();\n\n        // Call destroy on all gradient elements\n        destroyObjectProperties(renderer.gradients || {});\n        renderer.gradients = null;\n\n        // Defs are null in VMLRenderer\n        // Otherwise, destroy them here.\n        if (rendererDefs) {\n            renderer.defs = rendererDefs.destroy();\n        }\n\n        // Remove sub pixel fix handler\n        // We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed\n        // See issue #982\n        if (renderer.subPixelFix) {\n            removeEvent(win, 'resize', renderer.subPixelFix);\n        }\n\n        renderer.alignedObjects = null;\n\n        return null;\n    },\n\n    /**\n     * Create a wrapper for an SVG element\n     * @param {Object} nodeName\n     */\n    createElement: function (nodeName) {\n        var wrapper = new this.Element();\n        wrapper.init(this, nodeName);\n        return wrapper;\n    },\n\n    /**\n     * Dummy function for use in canvas renderer\n     */\n    draw: noop,\n\n    /**\n     * Get converted radial gradient attributes\n     */\n    getRadialAttr: function (radialReference, gradAttr) {\n        return {\n            cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],\n            cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],\n            r: gradAttr.r * radialReference[2]\n        };\n    },\n\n    /**\n     * Parse a simple HTML string into SVG tspans\n     *\n     * @param {Object} textNode The parent text SVG node\n     */\n    buildText: function (wrapper) {\n        var textNode = wrapper.element,\n            renderer = this,\n            forExport = renderer.forExport,\n            textStr = pick(wrapper.textStr, '').toString(),\n            hasMarkup = textStr.indexOf('<') !== -1,\n            lines,\n            childNodes = textNode.childNodes,\n            clsRegex,\n            styleRegex,\n            hrefRegex,\n            wasTooLong,\n            parentX = attr(textNode, 'x'),\n            textStyles = wrapper.styles,\n            width = wrapper.textWidth,\n            textLineHeight = textStyles && textStyles.lineHeight,\n            textShadow = textStyles && textStyles.textShadow,\n            ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n            i = childNodes.length,\n            tempParent = width && !wrapper.added && this.box,\n            getLineHeight = function (tspan) {\n                var fontSizeStyle;\n                ";
if (build.classic) { 
s += "\n                fontSizeStyle = /(px|em)$/.test(tspan && tspan.style.fontSize) ?\n                    tspan.style.fontSize :\n                    ((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12);\n                ";
} 
s += "\n\n                return textLineHeight ? \n                    pInt(textLineHeight) :\n                    renderer.fontMetrics(\n                        fontSizeStyle,\n                        tspan\n                    ).h;\n            },\n            unescapeAngleBrackets = function (inputStr) {\n                return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n            };\n\n        /// remove old text\n        while (i--) {\n            textNode.removeChild(childNodes[i]);\n        }\n\n        // Skip tspans, add text directly to text node. The forceTSpan is a hook\n        // used in text outline hack.\n        if (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {\n            textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));\n\n        // Complex strings, add more logic\n        } else {\n\n            clsRegex = /<.*class=___doublequote___([^___doublequote___]+)___doublequote___.*>/;\n            styleRegex = /<.*style=___doublequote___([^___doublequote___]+)___doublequote___.*>/;\n            hrefRegex = /<.*href=___doublequote___(http[^___doublequote___]+)___doublequote___.*>/;\n\n            if (tempParent) {\n                tempParent.appendChild(textNode); // attach it to the DOM to read offset width\n            }\n\n            if (hasMarkup) {\n                lines = textStr\n                    .replace(/<(b|strong)>/g, '<span style=___doublequote___font-weight:bold___doublequote___>')\n                    .replace(/<(i|em)>/g, '<span style=___doublequote___font-style:italic___doublequote___>')\n                    .replace(/<a/g, '<span')\n                    .replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n                    .split(/<br.*?>/g);\n\n            } else {\n                lines = [textStr];\n            }\n\n\n            // Trim empty lines (#5261)\n            lines = grep(lines, function (line) {\n                return line !== '';\n            });\n\n\n            // build the lines\n            each(lines, function buildTextLines(line, lineNo) {\n                var spans,\n                    spanNo = 0;\n                line = line\n                    .replace(/^\\s+|\\s+$/g, '') // Trim to prevent useless/costly process on the spaces (#5258)\n                    .replace(/<span/g, '|||<span')\n                    .replace(/<\\/span>/g, '</span>|||');\n                spans = line.split('|||');\n\n                each(spans, function buildTextSpans(span) {\n                    if (span !== '' || spans.length === 1) {\n                        var attributes = {},\n                            tspan = doc.createElementNS(renderer.SVG_NS, 'tspan'),\n                            spanCls,\n                            spanStyle; // #390\n                        if (clsRegex.test(span)) {\n                            spanCls = span.match(clsRegex)[1];\n                            attr(tspan, 'class', spanCls);\n                        }\n                        if (styleRegex.test(span)) {\n                            spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');\n                            attr(tspan, 'style', spanStyle);\n                        }\n                        if (hrefRegex.test(span) && !forExport) { // Not for export - #1529\n                            attr(tspan, 'onclick', 'location.href=\\___doublequote___' + span.match(hrefRegex)[1] + '\\___doublequote___');\n                            css(tspan, { cursor: 'pointer' });\n                        }\n\n                        span = unescapeAngleBrackets(span.replace(/<(.|\\n)*?>/g, '') || ' ');\n\n                        // Nested tags aren't supported, and cause crash in Safari (#1596)\n                        if (span !== ' ') {\n\n                            // add the text node\n                            tspan.appendChild(doc.createTextNode(span));\n\n                            if (!spanNo) { // first span in a line, align it to the left\n                                if (lineNo && parentX !== null) {\n                                    attributes.x = parentX;\n                                }\n                            } else {\n                                attributes.dx = 0; // #16\n                            }\n\n                            // add attributes\n                            attr(tspan, attributes);\n\n                            // Append it\n                            textNode.appendChild(tspan);\n\n                            // first span on subsequent line, add the line height\n                            if (!spanNo && lineNo) {\n\n                                // allow getting the right offset height in exporting in IE\n                                if (!svg && forExport) {\n                                    css(tspan, { display: 'block' });\n                                }\n\n                                // Set the line height based on the font size of either\n                                // the text element or the tspan element\n                                attr(\n                                    tspan,\n                                    'dy',\n                                    getLineHeight(tspan)\n                                );\n                            }\n\n                            /*if (width) {\n                                renderer.breakText(wrapper, width);\n                            }*/\n\n                            // Check width and apply soft breaks or ellipsis\n                            if (width) {\n                                var words = span.replace(/([^\\^])-/g, '$1- ').split(' '), // #1273\n                                    hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),\n                                    tooLong,\n                                    actualWidth,\n                                    rest = [],\n                                    dy = getLineHeight(tspan),\n                                    rotation = wrapper.rotation,\n                                    wordStr = span, // for ellipsis\n                                    cursor = wordStr.length, // binary search cursor\n                                    bBox;\n\n                                while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {\n                                    wrapper.rotation = 0; // discard rotation when computing box\n                                    bBox = wrapper.getBBox(true);\n                                    actualWidth = bBox.width;\n\n                                    // Old IE cannot measure the actualWidth for SVG elements (#2314)\n                                    if (!svg && renderer.forExport) {\n                                        actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);\n                                    }\n\n                                    tooLong = actualWidth > width;\n\n                                    // For ellipsis, do a binary search for the correct string length\n                                    if (wasTooLong === undefined) {\n                                        wasTooLong = tooLong; // First time\n                                    }\n                                    if (ellipsis && wasTooLong) {\n                                        cursor /= 2;\n\n                                        if (wordStr === '' || (!tooLong && cursor < 0.5)) {\n                                            words = []; // All ok, break out\n                                        } else {\n                                            wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * Math.ceil(cursor));\n                                            words = [wordStr + (width > 3 ? '\\u2026' : '')];\n                                            tspan.removeChild(tspan.firstChild);\n                                        }\n\n                                    // Looping down, this is the first word sequence that is not too long,\n                                    // so we can move on to build the next line.\n                                    } else if (!tooLong || words.length === 1) {\n                                        words = rest;\n                                        rest = [];\n\n                                        if (words.length) {\n                                            \n                                            tspan = doc.createElementNS(renderer.SVG_NS, 'tspan');\n                                            attr(tspan, {\n                                                dy: dy,\n                                                x: parentX\n                                            });\n                                            if (spanStyle) { // #390\n                                                attr(tspan, 'style', spanStyle);\n                                            }\n                                            textNode.appendChild(tspan);\n                                        }\n                                        if (actualWidth > width) { // a single word is pressing it out\n                                            width = actualWidth;\n                                        }\n                                    } else { // append to existing line tspan\n                                        tspan.removeChild(tspan.firstChild);\n                                        rest.unshift(words.pop());\n                                    }\n                                    if (words.length) {\n                                        tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));\n                                    }\n                                }\n                                wrapper.rotation = rotation;\n                            }\n\n                            spanNo++;\n                        }\n                    }\n                });\n            });\n\n            if (wasTooLong) {\n                wrapper.attr('title', wrapper.textStr);\n            }\n            if (tempParent) {\n                tempParent.removeChild(textNode); // attach it to the DOM to read offset width\n            }\n\n            // Apply the text shadow\n            if (textShadow && wrapper.applyTextShadow) {\n                wrapper.applyTextShadow(textShadow);\n            }\n        }\n    },\n\n\n\n    /*\n    breakText: function (wrapper, width) {\n        var bBox = wrapper.getBBox(),\n            node = wrapper.element,\n            textLength = node.textContent.length,\n            pos = Math.round(width * textLength / bBox.width), // try this position first, based on average character width\n            increment = 0,\n            finalPos;\n\n        if (bBox.width > width) {\n            while (finalPos === undefined) {\n                textLength = node.getSubStringLength(0, pos);\n\n                if (textLength <= width) {\n                    if (increment === -1) {\n                        finalPos = pos;\n                    } else {\n                        increment = 1;\n                    }\n                } else {\n                    if (increment === 1) {\n                        finalPos = pos - 1;\n                    } else {\n                        increment = -1;\n                    }\n                }\n                pos += increment;\n            }\n        }\n        console.log('width', width, 'stringWidth', node.getSubStringLength(0, finalPos))\n    },\n    */\n\n    /**\n     * Returns white for dark colors and black for bright colors\n     */\n    getContrast: function (color) {\n        color = Color(color).rgba;\n        return color[0] + color[1] + color[2] > 384 ? '#000000' : '#FFFFFF';\n    },\n\n    /**\n     * Create a button with preset states\n     * @param {String} text\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Function} callback\n     * @param {Object} normalState\n     * @param {Object} hoverState\n     * @param {Object} pressedState\n     */\n    button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {\n        var label = this.label(text, x, y, shape, null, null, null, null, 'button'),\n            curState = 0;\n\n        // Default, non-stylable attributes\n        label.attr(merge({\n            'padding': 2,\n            'r': 2\n        }, normalState));\n\n        ";
if (build.classic) { 
s += "\n        // Presentational\n        var normalStyle,\n            hoverStyle,\n            pressedStyle,\n            disabledStyle;\n\n        // Normal state - prepare the attributes\n        normalState = merge({\n            fill: '#f7f7f7',\n            'stroke-width': 1,\n            style: {\n                color: '#444444',\n                cursor: 'pointer',\n                fontWeight: 'normal'\n            }\n        }, normalState);\n        normalStyle = normalState.style;\n        delete normalState.style;\n\n        // Hover state\n        hoverState = merge(normalState, {\n            fill: '#e7e7e7'\n        }, hoverState);\n        hoverStyle = hoverState.style;\n        delete hoverState.style;\n\n        // Pressed state\n        pressedState = merge(normalState, {\n            fill: '#e7f0f9',\n            style: {\n                color: '#000000',\n                fontWeight: 'bold'\n            }\n        }, pressedState);\n        pressedStyle = pressedState.style;\n        delete pressedState.style;\n\n        // Disabled state\n        disabledState = merge(normalState, {\n            style: {\n                color: '#CCC'\n            }\n        }, disabledState);\n        disabledStyle = disabledState.style;\n        delete disabledState.style;\n        ";
} 
s += "\n\n        // Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).\n        addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {\n            if (curState !== 3) {\n                label.setState(1);\n            }\n        });\n        addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {\n            if (curState !== 3) {\n                label.setState(curState);\n            }\n        });\n\n        label.setState = function (state) {\n            // Hover state is temporary, don't record it\n            if (state !== 1) {\n                label.state = curState = state;\n            }\n            // Update visuals\n            label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/)\n                .addClass('highcharts-button-' + ['normal', 'hover', 'pressed', 'disabled'][state || 0]);\n            \n            ";
if (build.classic) { 
s += "\n            label.attr([normalState, hoverState, pressedState, disabledState][state || 0])\n                .css([normalStyle, hoverStyle, pressedStyle, disabledStyle][state || 0]);\n            ";
} 
s += "\n        };\n\n\n        ";
if (build.classic) { 
s += "\n        // Presentational attributes\n        label\n            .attr(normalState)\n            .css(extend({ cursor: 'default' }, normalStyle));\n        ";
} 
s += "\n\n        return label\n            .on('click', function (e) {\n                if (curState !== 3) {\n                    callback.call(label, e);\n                }\n            });\n    },\n\n    /**\n     * Make a straight line crisper by not spilling out to neighbour pixels\n     * @param {Array} points\n     * @param {Number} width\n     */\n    crispLine: function (points, width) {\n        // points format: ['M', 0, 0, 'L', 100, 0]\n        // normalize to a crisp line\n        if (points[1] === points[4]) {\n            // Substract due to #1129. Now bottom and left axis gridlines behave the same.\n            points[1] = points[4] = Math.round(points[1]) - (width % 2 / 2);\n        }\n        if (points[2] === points[5]) {\n            points[2] = points[5] = Math.round(points[2]) + (width % 2 / 2);\n        }\n        return points;\n    },\n\n\n    /**\n     * Draw a path\n     * @param {Array} path An SVG path in array form\n     */\n    path: function (path) {\n        var attribs = {\n            ";
if (build.classic) { 
s += "\n            fill: 'none'\n            ";
} 
s += "\n        };\n        if (isArray(path)) {\n            attribs.d = path;\n        } else if (isObject(path)) { // attributes\n            extend(attribs, path);\n        }\n        return this.createElement('path').attr(attribs);\n    },\n\n    /**\n     * Draw and return an SVG circle\n     * @param {Number} x The x position\n     * @param {Number} y The y position\n     * @param {Number} r The radius\n     */\n    circle: function (x, y, r) {\n        var attribs = isObject(x) ? x : { x: x, y: y, r: r },\n            wrapper = this.createElement('circle');\n\n        // Setting x or y translates to cx and cy\n        wrapper.xSetter = wrapper.ySetter = function (value, key, element) {\n            element.setAttribute('c' + key, value);\n        };\n\n        return wrapper.attr(attribs);\n    },\n\n    /**\n     * Draw and return an arc\n     * @param {Number} x X position\n     * @param {Number} y Y position\n     * @param {Number} r Radius\n     * @param {Number} innerR Inner radius like used in donut charts\n     * @param {Number} start Starting angle\n     * @param {Number} end Ending angle\n     */\n    arc: function (x, y, r, innerR, start, end) {\n        var arc;\n\n        if (isObject(x)) {\n            y = x.y;\n            r = x.r;\n            innerR = x.innerR;\n            start = x.start;\n            end = x.end;\n            x = x.x;\n        }\n\n        // Arcs are defined as symbols for the ability to set\n        // attributes in attr and animate\n        arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {\n            innerR: innerR || 0,\n            start: start || 0,\n            end: end || 0\n        });\n        arc.r = r; // #959\n        return arc;\n    },\n\n    /**\n     * Draw and return a rectangle\n     * @param {Number} x Left position\n     * @param {Number} y Top position\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Number} r Border corner radius\n     * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing\n     */\n    rect: function (x, y, width, height, r, strokeWidth) {\n\n        r = isObject(x) ? x.r : r;\n\n        var wrapper = this.createElement('rect'),\n            attribs = isObject(x) ? x : x === undefined ? {} : {\n                x: x,\n                y: y,\n                width: Math.max(width, 0),\n                height: Math.max(height, 0)\n            };\n\n        ";
if (build.classic) { 
s += "\n        if (strokeWidth !== undefined) {\n            attribs.strokeWidth = strokeWidth;\n            attribs = wrapper.crisp(attribs);\n        }\n        attribs.fill = 'none';\n        ";
} 
s += "\n\n        if (r) {\n            attribs.r = r;\n        }\n\n        wrapper.rSetter = function (value, key, element) {\n            attr(element, {\n                rx: value,\n                ry: value\n            });\n        };\n\n        return wrapper.attr(attribs);\n    },\n\n    /**\n     * Resize the box and re-align all aligned elements\n     * @param {Object} width\n     * @param {Object} height\n     * @param {Boolean} animate\n     *\n     */\n    setSize: function (width, height, animate) {\n        var renderer = this,\n            alignedObjects = renderer.alignedObjects,\n            i = alignedObjects.length;\n\n        renderer.width = width;\n        renderer.height = height;\n\n        /* = if (build.classic) { = */\n        renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({\n            width: width,\n            height: height\n        });\n        /* = } = */\n        renderer.boxWrapper.attr({\n            viewBox: '0 0 ' + width + ' ' + height\n        });\n\n        while (i--) {\n            alignedObjects[i].align();\n        }\n    },\n\n    /**\n     * Create a group\n     * @param {String} name The group will be given a class name of 'highcharts-{name}'.\n     *     This can be used for styling and scripting.\n     */\n    g: function (name) {\n        var elem = this.createElement('g');\n        return defined(name) ? elem.attr({ 'class': 'highcharts-' + name }) : elem;\n    },\n\n    /**\n     * Display an image\n     * @param {String} src\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Number} width\n     * @param {Number} height\n     */\n    image: function (src, x, y, width, height) {\n        var attribs = {\n                preserveAspectRatio: 'none'\n            },\n            elemWrapper;\n\n        // optional properties\n        if (arguments.length > 1) {\n            extend(attribs, {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            });\n        }\n\n        elemWrapper = this.createElement('image').attr(attribs);\n\n        // set the href in the xlink namespace\n        if (elemWrapper.element.setAttributeNS) {\n            elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',\n                'href', src);\n        } else {\n            // could be exporting in IE\n            // using href throws ___doublequote___not supported___doublequote___ in ie7 and under, requries regex shim to fix later\n            elemWrapper.element.setAttribute('hc-svg-href', src);\n        }\n        return elemWrapper;\n    },\n\n    /**\n     * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.\n     *\n     * @param {Object} symbol\n     * @param {Object} x\n     * @param {Object} y\n     * @param {Object} radius\n     * @param {Object} options\n     */\n    symbol: function (symbol, x, y, width, height, options) {\n\n        var ren = this,\n            obj,\n\n            // get the symbol definition function\n            symbolFn = this.symbols[symbol],\n\n            // check if there's a path defined for this symbol\n            path = defined(x) && symbolFn && symbolFn(\n                Math.round(x),\n                Math.round(y),\n                width,\n                height,\n                options\n            ),\n\n            imageRegex = /^url\\((.*?)\\)$/,\n            imageSrc,\n            centerImage,\n            symbolSizes = {};\n\n        if (symbolFn) {\n            obj = this.path(path);\n\n            ";
if (build.classic) { 
s += "\n            obj.attr('fill', 'none');\n            ";
} 
s += "\n            \n            // expando properties for use in animate and attr\n            extend(obj, {\n                symbolName: symbol,\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            });\n            if (options) {\n                extend(obj, options);\n            }\n\n\n        // image symbols\n        } else if (imageRegex.test(symbol)) {\n\n            \n            imageSrc = symbol.match(imageRegex)[1];\n\n            // Create the image synchronously, add attribs async\n            obj = this.image(imageSrc);\n\n            // The image width is not always the same as the symbol width. The image may be centered within the symbol,\n            // as is the case when image shapes are used as label backgrounds, for example in flags.\n            obj.imgWidth = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].width, options && options.width);\n            obj.imgHeight = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].height, options && options.height);\n\n            /**\n             * Set the size and position\n             */\n            centerImage = function () {\n                obj.attr({\n                    width: obj.width,\n                    height: obj.height\n                });\n            };\n\n            /**\n             * Width and height setters that take both the image's physical size and the label size into \n             * consideration, and translates the image to center within the label.\n             */\n            each(['width', 'height'], function (key) {\n                obj[key + 'Setter'] = function (value, key) {\n                    var attribs = {},\n                        imgSize = this['img' + key];\n                    this[key] = value;\n                    if (defined(imgSize)) {\n                        if (this.element) {\n                            this.element.setAttribute(key, imgSize);\n                        }\n                        if (!this.alignByTranslate) {\n                            attribs[key === 'width' ? 'translateX' : 'translateY'] = (this[key] - imgSize) / 2;\n                            this.attr(attribs);\n                        }\n                    }\n                };\n            });\n            \n\n            if (defined(x)) {\n                obj.attr({\n                    x: x,\n                    y: y\n                });\n            }\n            obj.isImg = true;\n\n            if (defined(obj.imgwidth) && defined(obj.imgheight)) {\n                centerImage();\n            } else {\n                // Initialize image to be 0 size so export will still function if there's no cached sizes.\n                obj.attr({ width: 0, height: 0 });\n\n                // Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,\n                // the created element must be assigned to a variable in order to load (#292).\n                createElement('img', {\n                    onload: function () {\n\n                        // Special case for SVGs on IE11, the width is not accessible until the image is \n                        // part of the DOM (#2854).\n                        if (this.width === 0) {\n                            css(this, {\n                                position: 'absolute',\n                                top: '-999em'\n                            });\n                            doc.body.appendChild(this);\n                        }\n\n                        // Center the image\n                        centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);\n\n                        // Clean up after #2854 workaround.\n                        if (this.parentNode) {\n                            this.parentNode.removeChild(this);\n                        }\n\n                        // Fire the load event when all external images are loaded\n                        ren.imgCount--;\n                        if (!ren.imgCount && charts[ren.chartIndex].onload) {\n                            charts[ren.chartIndex].onload();\n                        }\n                    },\n                    src: imageSrc\n                });\n                this.imgCount++;\n            }\n        }\n\n        return obj;\n    },\n\n    /**\n     * An extendable collection of functions for defining symbol paths.\n     */\n    symbols: {\n        'circle': function (x, y, w, h) {\n            var cpw = 0.166 * w;\n            return [\n                'M', x + w / 2, y,\n                'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,\n                'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,\n                'Z'\n            ];\n        },\n\n        'square': function (x, y, w, h) {\n            return [\n                'M', x, y,\n                'L', x + w, y,\n                x + w, y + h,\n                x, y + h,\n                'Z'\n            ];\n        },\n\n        'triangle': function (x, y, w, h) {\n            return [\n                'M', x + w / 2, y,\n                'L', x + w, y + h,\n                x, y + h,\n                'Z'\n            ];\n        },\n\n        'triangle-down': function (x, y, w, h) {\n            return [\n                'M', x, y,\n                'L', x + w, y,\n                x + w / 2, y + h,\n                'Z'\n            ];\n        },\n        'diamond': function (x, y, w, h) {\n            return [\n                'M', x + w / 2, y,\n                'L', x + w, y + h / 2,\n                x + w / 2, y + h,\n                x, y + h / 2,\n                'Z'\n            ];\n        },\n        'arc': function (x, y, w, h, options) {\n            var start = options.start,\n                radius = options.r || w || h,\n                end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)\n                innerRadius = options.innerR,\n                open = options.open,\n                cosStart = Math.cos(start),\n                sinStart = Math.sin(start),\n                cosEnd = Math.cos(end),\n                sinEnd = Math.sin(end),\n                longArc = options.end - start < Math.PI ? 0 : 1;\n\n            return [\n                'M',\n                x + radius * cosStart,\n                y + radius * sinStart,\n                'A', // arcTo\n                radius, // x radius\n                radius, // y radius\n                0, // slanting\n                longArc, // long or short arc\n                1, // clockwise\n                x + radius * cosEnd,\n                y + radius * sinEnd,\n                open ? 'M' : 'L',\n                x + innerRadius * cosEnd,\n                y + innerRadius * sinEnd,\n                'A', // arcTo\n                innerRadius, // x radius\n                innerRadius, // y radius\n                0, // slanting\n                longArc, // long or short arc\n                0, // clockwise\n                x + innerRadius * cosStart,\n                y + innerRadius * sinStart,\n\n                open ? '' : 'Z' // close\n            ];\n        },\n\n        /**\n         * Callout shape used for default tooltips, also used for rounded rectangles in VML\n         */\n        callout: function (x, y, w, h, options) {\n            var arrowLength = 6,\n                halfDistance = 6,\n                r = Math.min((options && options.r) || 0, w, h),\n                safeDistance = r + halfDistance,\n                anchorX = options && options.anchorX,\n                anchorY = options && options.anchorY,\n                path;\n\n            path = [\n                'M', x + r, y,\n                'L', x + w - r, y, // top side\n                'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n                'L', x + w, y + h - r, // right side\n                'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner\n                'L', x + r, y + h, // bottom side\n                'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n                'L', x, y + r, // left side\n                'C', x, y, x, y, x + r, y // top-right corner\n            ];\n\n            if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side\n                path.splice(13, 3,\n                    'L', x + w, anchorY - halfDistance,\n                    x + w + arrowLength, anchorY,\n                    x + w, anchorY + halfDistance,\n                    x + w, y + h - r\n                    );\n            } else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side\n                path.splice(33, 3,\n                    'L', x, anchorY + halfDistance,\n                    x - arrowLength, anchorY,\n                    x, anchorY - halfDistance,\n                    x, y + r\n                    );\n            } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom\n                path.splice(23, 3,\n                    'L', anchorX + halfDistance, y + h,\n                    anchorX, y + h + arrowLength,\n                    anchorX - halfDistance, y + h,\n                    x + r, y + h\n                    );\n            } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top\n                path.splice(3, 3,\n                    'L', anchorX - halfDistance, y,\n                    anchorX, y - arrowLength,\n                    anchorX + halfDistance, y,\n                    w - r, y\n                    );\n            }\n            return path;\n        }\n    },\n\n    /**\n     * Define a clipping rectangle\n     * @param {String} id\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Number} width\n     * @param {Number} height\n     */\n    clipRect: function (x, y, width, height) {\n        var wrapper,\n            id = 'highcharts-' + H.idCounter++,\n\n            clipPath = this.createElement('clipPath').attr({\n                id: id\n            }).add(this.defs);\n\n        wrapper = this.rect(x, y, width, height, 0).add(clipPath);\n        wrapper.id = id;\n        wrapper.clipPath = clipPath;\n        wrapper.count = 0;\n\n        return wrapper;\n    },\n\n\n\n\n\n    /**\n     * Add text to the SVG object\n     * @param {String} str\n     * @param {Number} x Left position\n     * @param {Number} y Top position\n     * @param {Boolean} useHTML Use HTML to render the text\n     */\n    text: function (str, x, y, useHTML) {\n\n        // declare variables\n        var renderer = this,\n            fakeSVG = useCanVG || (!svg && renderer.forExport),\n            wrapper,\n            attribs = {};\n\n        if (useHTML && (renderer.allowHTML || !renderer.forExport)) {\n            return renderer.html(str, x, y);\n        }\n\n        attribs.x = Math.round(x || 0); // X is always needed for line-wrap logic\n        if (y) {\n            attribs.y = Math.round(y);\n        }\n        if (str || str === 0) {\n            attribs.text = str;\n        }\n\n        wrapper = renderer.createElement('text')\n            .attr(attribs);\n\n        // Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)\n        if (fakeSVG) {\n            wrapper.css({\n                position: 'absolute'\n            });\n        }\n\n        if (!useHTML) {\n            wrapper.xSetter = function (value, key, element) {\n                var tspans = element.getElementsByTagName('tspan'),\n                    tspan,\n                    parentVal = element.getAttribute(key),\n                    i;\n                for (i = 0; i < tspans.length; i++) {\n                    tspan = tspans[i];\n                    // If the x values are equal, the tspan represents a linebreak\n                    if (tspan.getAttribute(key) === parentVal) {\n                        tspan.setAttribute(key, value);\n                    }\n                }\n                element.setAttribute(key, value);\n            };\n        }\n\n        return wrapper;\n    },\n\n    /**\n     * Utility to return the baseline offset and total line height from the font size\n     */\n    fontMetrics: function (fontSize, elem) { // eslint-disable-line no-unused-vars\n        var lineHeight,\n            baseline;\n\n        ";
if (build.classic) { 
s += "\n        fontSize = fontSize || (this.style && this.style.fontSize);\n        ";
} else { 
s += "\n        fontSize = elem && SVGElement.prototype.getStyle.call(elem, 'font-size');\n        ";
} 
s += "\n\n        fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;\n\n        // Empirical values found by comparing font size and bounding box height.\n        // Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/\n        lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);\n        baseline = Math.round(lineHeight * 0.8);\n\n        return {\n            h: lineHeight,\n            b: baseline,\n            f: fontSize\n        };\n    },\n\n    /**\n     * Correct X and Y positioning of a label for rotation (#1764)\n     */\n    rotCorr: function (baseline, rotation, alterY) {\n        var y = baseline;\n        if (rotation && alterY) {\n            y = Math.max(y * Math.cos(rotation * deg2rad), 4);\n        }\n        return {\n            x: (-baseline / 3) * Math.sin(rotation * deg2rad),\n            y: y\n        };\n    },\n\n    /**\n     * Add a label, a text item that can hold a colored or gradient background\n     * as well as a border and shadow.\n     * @param {string} str\n     * @param {Number} x\n     * @param {Number} y\n     * @param {String} shape\n     * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the\n     *    coordinates it should be pinned to\n     * @param {Number} anchorY\n     * @param {Boolean} baseline Whether to position the label relative to the text baseline,\n     *    like renderer.text, or to the upper border of the rectangle.\n     * @param {String} className Class name for the group\n     */\n    label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n\n        var renderer = this,\n            wrapper = renderer.g('label'),\n            text = renderer.text('', 0, 0, useHTML)\n                .attr({\n                    zIndex: 1\n                }),\n            box,\n            bBox,\n            alignFactor = 0,\n            padding = 3,\n            paddingLeft = 0,\n            width,\n            height,\n            wrapperX,\n            wrapperY,\n            textAlign,\n            deferredAttr = {},\n            strokeWidth,\n            baselineOffset,\n            needsBox,\n            getCrispAdjust,\n            updateBoxSize,\n            updateTextPadding,\n            boxAttr;\n\n        if (className) {\n            wrapper.addClass('highcharts-' + className);\n        }\n\n        ";
if (!build.classic) { 
s += "\n        needsBox = true; // for styling\n        getCrispAdjust = function () {\n            return box.strokeWidth() % 2 / 2;\n        };\n        ";
} else { 
s += "\n        needsBox = false;\n        getCrispAdjust = function () {\n            return (strokeWidth || 0) % 2 / 2;\n        };\n\n        ";
} 
s += "\n\n        /**\n         * This function runs after the label is added to the DOM (when the bounding box is\n         * available), and after the text of the label is updated to detect the new bounding\n         * box and reflect it in the border box.\n         */\n        updateBoxSize = function () {\n            var style = text.element.style,\n                crispAdjust,\n                attribs = {};\n\n            bBox = (width === undefined || height === undefined || textAlign) && defined(text.textStr) &&\n                text.getBBox(); //#3295 && 3514 box failure when string equals 0\n            wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;\n            wrapper.height = (height || bBox.height || 0) + 2 * padding;\n\n            // Update the label-scoped y offset\n            baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;\n\n\n            if (needsBox) {\n\n                // Create the border box if it is not already present\n                if (!box) {\n                    wrapper.box = box = shape ?\n                        renderer.symbol(shape) :\n                        renderer.rect();\n                    \n                    box.addClass('highcharts-label-box' + (className ? ' highcharts-' + className + '-box' : ''));\n\n                    box.add(wrapper);\n\n                    crispAdjust = getCrispAdjust();\n                    attribs.x = Math.round(-alignFactor * padding) + crispAdjust;\n                    attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;\n                }\n\n                // Apply the box attributes\n                attribs.width = Math.round(wrapper.width);\n                attribs.height = Math.round(wrapper.height);\n                \n                box.attr(extend(attribs, deferredAttr));\n                deferredAttr = {};\n            }\n        };\n\n        /**\n         * This function runs after setting text or padding, but only if padding is changed\n         */\n        updateTextPadding = function () {\n            var textX = paddingLeft + padding,\n                textY;\n\n            // determin y based on the baseline\n            textY = baseline ? 0 : baselineOffset;\n\n            // compensate for alignment\n            if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {\n                textX += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);\n            }\n\n            // update if anything changed\n            if (textX !== text.x || textY !== text.y) {\n                text.attr('x', textX);\n                if (textY !== undefined) {\n                    text.attr('y', textY);\n                }\n            }\n\n            // record current values\n            text.x = textX;\n            text.y = textY;\n        };\n\n        /**\n         * Set a box attribute, or defer it if the box is not yet created\n         * @param {Object} key\n         * @param {Object} value\n         */\n        boxAttr = function (key, value) {\n            if (box) {\n                box.attr(key, value);\n            } else {\n                deferredAttr[key] = value;\n            }\n        };\n\n        /**\n         * After the text element is added, get the desired size of the border box\n         * and add it before the text in the DOM.\n         */\n        wrapper.onAdd = function () {\n            text.add(wrapper);\n            wrapper.attr({\n                text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value\n                x: x,\n                y: y\n            });\n\n            if (box && defined(anchorX)) {\n                wrapper.attr({\n                    anchorX: anchorX,\n                    anchorY: anchorY\n                });\n            }\n        };\n\n        /*\n         * Add specific attribute setters.\n         */\n\n        // only change local variables\n        wrapper.widthSetter = function (value) {\n            width = value;\n        };\n        wrapper.heightSetter = function (value) {\n            height = value;\n        };\n        wrapper['text-alignSetter'] = function (value) {\n            textAlign = value;\n        };\n        wrapper.paddingSetter =  function (value) {\n            if (defined(value) && value !== padding) {\n                padding = wrapper.padding = value;\n                updateTextPadding();\n            }\n        };\n        wrapper.paddingLeftSetter =  function (value) {\n            if (defined(value) && value !== paddingLeft) {\n                paddingLeft = value;\n                updateTextPadding();\n            }\n        };\n\n\n        // change local variable and prevent setting attribute on the group\n        wrapper.alignSetter = function (value) {\n            value = { left: 0, center: 0.5, right: 1 }[value];\n            if (value !== alignFactor) {\n                alignFactor = value;\n                if (bBox) { // Bounding box exists, means we're dynamically changing\n                    wrapper.attr({ x: wrapperX }); // #5134\n                }\n            }\n        };\n\n        // apply these to the box and the text alike\n        wrapper.textSetter = function (value) {\n            if (value !== undefined) {\n                text.textSetter(value);\n            }\n            updateBoxSize();\n            updateTextPadding();\n        };\n\n        // apply these to the box but not to the text\n        wrapper['stroke-widthSetter'] = function (value, key) {\n            if (value) {\n                needsBox = true;\n            }\n            strokeWidth = this['stroke-width'] = value;\n            boxAttr(key, value);\n        };\n        ";
if (!build.classic) { 
s += "\n        wrapper.rSetter = function (value, key) {\n            boxAttr(key, value);\n        };\n        ";
} else { 
s += "\n        wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {\n            if (key === 'fill' && value) {\n                needsBox = true;\n            }\n            boxAttr(key, value);\n        };\n        ";
} 
s += "\n        wrapper.anchorXSetter = function (value, key) {\n            anchorX = value;\n            boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);\n        };\n        wrapper.anchorYSetter = function (value, key) {\n            anchorY = value;\n            boxAttr(key, value - wrapperY);\n        };\n\n        // rename attributes\n        wrapper.xSetter = function (value) {\n            wrapper.x = value; // for animation getter\n            if (alignFactor) {\n                value -= alignFactor * ((width || bBox.width) + 2 * padding);\n            }\n            wrapperX = Math.round(value);\n            wrapper.attr('translateX', wrapperX);\n        };\n        wrapper.ySetter = function (value) {\n            wrapperY = wrapper.y = Math.round(value);\n            wrapper.attr('translateY', wrapperY);\n        };\n\n        // Redirect certain methods to either the box or the text\n        var baseCss = wrapper.css;\n        return extend(wrapper, {\n            /**\n             * Pick up some properties and apply them to the text instead of the wrapper\n             */\n            css: function (styles) {\n                if (styles) {\n                    var textStyles = {};\n                    styles = merge(styles); // create a copy to avoid altering the original object (#537)\n                    each(wrapper.textProps, function (prop) {\n                        if (styles[prop] !== undefined) {\n                            textStyles[prop] = styles[prop];\n                            delete styles[prop];\n                        }\n                    });\n                    text.css(textStyles);\n                }\n                return baseCss.call(wrapper, styles);\n            },\n            /**\n             * Return the bounding box of the box, not the group\n             */\n            getBBox: function () {\n                return {\n                    width: bBox.width + 2 * padding,\n                    height: bBox.height + 2 * padding,\n                    x: bBox.x - padding,\n                    y: bBox.y - padding\n                };\n            },\n            ";
if (build.classic) { 
s += "\n            /**\n             * Apply the shadow to the box\n             */\n            shadow: function (b) {\n                if (b) {\n                    updateBoxSize();\n                    if (box) {\n                        box.shadow(b);\n                    }\n                }\n                return wrapper;\n            },\n            ";
} 
s += "\n            /**\n             * Destroy and release memory.\n             */\n            destroy: function () {\n                \n                // Added by button implementation\n                removeEvent(wrapper.element, 'mouseenter');\n                removeEvent(wrapper.element, 'mouseleave');\n\n                if (text) {\n                    text = text.destroy();\n                }\n                if (box) {\n                    box = box.destroy();\n                }\n                // Call base implementation to destroy the rest\n                SVGElement.prototype.destroy.call(wrapper);\n\n                // Release local pointers (#1298)\n                wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;\n            }\n        });\n    }\n}; // end SVGRenderer\n\n\n// general renderer\nH.Renderer = SVGRenderer;\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var attr = H.attr,\n        createElement = H.createElement,\n        css = H.css,\n        defined = H.defined,\n        each = H.each,\n        extend = H.extend,\n        isFirefox = H.isFirefox,\n        isMS = H.isMS,\n        isWebKit = H.isWebKit,\n        pInt = H.pInt,\n        SVGElement = H.SVGElement,\n        SVGRenderer = H.SVGRenderer,\n        win = H.win,\n        wrap = H.wrap;\n\n// extend SvgElement for useHTML option\nextend(SVGElement.prototype, {\n    /**\n     * Apply CSS to HTML elements. This is used in text within SVG rendering and\n     * by the VML renderer\n     */\n    htmlCss: function (styles) {\n        var wrapper = this,\n            element = wrapper.element,\n            textWidth = styles && element.tagName === 'SPAN' && styles.width;\n\n        if (textWidth) {\n            delete styles.width;\n            wrapper.textWidth = textWidth;\n            wrapper.updateTransform();\n        }\n        if (styles && styles.textOverflow === 'ellipsis') {\n            styles.whiteSpace = 'nowrap';\n            styles.overflow = 'hidden';\n        }\n        wrapper.styles = extend(wrapper.styles, styles);\n        css(wrapper.element, styles);\n\n        return wrapper;\n    },\n\n    /**\n     * VML and useHTML method for calculating the bounding box based on offsets\n     * @param {Boolean} refresh Whether to force a fresh value from the DOM or to\n     * use the cached value\n     *\n     * @return {Object} A hash containing values for x, y, width and height\n     */\n\n    htmlGetBBox: function () {\n        var wrapper = this,\n            element = wrapper.element;\n\n        // faking getBBox in exported SVG in legacy IE\n        // faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)\n        if (element.nodeName === 'text') {\n            element.style.position = 'absolute';\n        }\n\n        return {\n            x: element.offsetLeft,\n            y: element.offsetTop,\n            width: element.offsetWidth,\n            height: element.offsetHeight\n        };\n    },\n\n    /**\n     * VML override private method to update elements based on internal\n     * properties based on SVG transform\n     */\n    htmlUpdateTransform: function () {\n        // aligning non added elements is expensive\n        if (!this.added) {\n            this.alignOnAdd = true;\n            return;\n        }\n\n        var wrapper = this,\n            renderer = wrapper.renderer,\n            elem = wrapper.element,\n            translateX = wrapper.translateX || 0,\n            translateY = wrapper.translateY || 0,\n            x = wrapper.x || 0,\n            y = wrapper.y || 0,\n            align = wrapper.textAlign || 'left',\n            alignCorrection = { left: 0, center: 0.5, right: 1 }[align],\n            styles = wrapper.styles;\n\n        // apply translate\n        css(elem, {\n            marginLeft: translateX,\n            marginTop: translateY\n        });\n\n        ";
if (build.classic) { 
s += "\n        if (wrapper.shadows) { // used in labels/tooltip\n            each(wrapper.shadows, function (shadow) {\n                css(shadow, {\n                    marginLeft: translateX + 1,\n                    marginTop: translateY + 1\n                });\n            });\n        }\n        ";
} 
s += "\n\n        // apply inversion\n        if (wrapper.inverted) { // wrapper is a group\n            each(elem.childNodes, function (child) {\n                renderer.invertChild(child, elem);\n            });\n        }\n\n        if (elem.tagName === 'SPAN') {\n\n            var rotation = wrapper.rotation,\n                baseline,\n                textWidth = pInt(wrapper.textWidth),\n                whiteSpace = styles && styles.whiteSpace,\n                currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(',');\n\n            if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed\n\n\n                baseline = renderer.fontMetrics(elem.style.fontSize).b;\n\n                // Renderer specific handling of span rotation\n                if (defined(rotation)) {\n                    wrapper.setSpanRotation(rotation, alignCorrection, baseline);\n                }\n\n                // Update textWidth\n                if (elem.offsetWidth > textWidth && /[ \\-]/.test(elem.textContent || elem.innerText)) { // #983, #1254\n                    css(elem, {\n                        width: textWidth + 'px',\n                        display: 'block',\n                        whiteSpace: whiteSpace || 'normal' // #3331\n                    });\n                    wrapper.hasTextWidth = true;\n                } else if (wrapper.hasTextWidth) { // #4928\n                    css(elem, {\n                        width: '',\n                        display: '',\n                        whiteSpace: whiteSpace || 'nowrap'\n                    });\n                    wrapper.hasTextWidth = false;\n                }\n\n                wrapper.getSpanCorrection(wrapper.hasTextWidth ? textWidth : elem.offsetWidth, baseline, alignCorrection, rotation, align);\n            }\n\n            // apply position with correction\n            css(elem, {\n                left: (x + (wrapper.xCorr || 0)) + 'px',\n                top: (y + (wrapper.yCorr || 0)) + 'px'\n            });\n\n            // force reflow in webkit to apply the left and top on useHTML element (#1249)\n            if (isWebKit) {\n                baseline = elem.offsetHeight; // assigned to baseline for lint purpose\n            }\n\n            // record current text transform\n            wrapper.cTT = currentTextTransform;\n        }\n    },\n\n    /**\n     * Set the rotation of an individual HTML span\n     */\n    setSpanRotation: function (rotation, alignCorrection, baseline) {\n        var rotationStyle = {},\n            cssTransformKey = isMS ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : win.opera ? '-o-transform' : '';\n\n        rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';\n        rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';\n        css(this.element, rotationStyle);\n    },\n\n    /**\n     * Get the correction in X and Y positioning as the element is rotated.\n     */\n    getSpanCorrection: function (width, baseline, alignCorrection) {\n        this.xCorr = -width * alignCorrection;\n        this.yCorr = -baseline;\n    }\n});\n\n// Extend SvgRenderer for useHTML option.\nextend(SVGRenderer.prototype, {\n    /**\n     * Create HTML text node. This is used by the VML renderer as well as the SVG\n     * renderer through the useHTML option.\n     *\n     * @param {String} str\n     * @param {Number} x\n     * @param {Number} y\n     */\n    html: function (str, x, y) {\n        var wrapper = this.createElement('span'),\n            element = wrapper.element,\n            renderer = wrapper.renderer,\n            isSVG = renderer.isSVG,\n            addSetters = function (element, style) {\n                // These properties are set as attributes on the SVG group, and as\n                // identical CSS properties on the div. (#3542)\n                each(['opacity', 'visibility'], function (prop) {\n                    wrap(element, prop + 'Setter', function (proceed, value, key, elem) {\n                        proceed.call(this, value, key, elem);\n                        style[key] = value;\n                    });\n                });                \n            };\n\n        // Text setter\n        wrapper.textSetter = function (value) {\n            if (value !== element.innerHTML) {\n                delete this.bBox;\n            }\n            element.innerHTML = this.textStr = value;\n            wrapper.htmlUpdateTransform();\n        };\n\n        // Add setters for the element itself (#4938)\n        if (isSVG) { // #4938, only for HTML within SVG\n            addSetters(wrapper, wrapper.element.style);\n        }\n\n        // Various setters which rely on update transform\n        wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {\n            if (key === 'align') {\n                key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.\n            }\n            wrapper[key] = value;\n            wrapper.htmlUpdateTransform();\n        };\n\n        // Set the default attributes\n        wrapper\n            .attr({\n                text: str,\n                x: Math.round(x),\n                y: Math.round(y)\n            })\n            .css({\n                ";
if (build.classic) { 
s += "\n                fontFamily: this.style.fontFamily,\n                fontSize: this.style.fontSize,\n                ";
} 
s += "\n                position: 'absolute'\n            });\n\n        // Keep the whiteSpace style outside the wrapper.styles collection\n        element.style.whiteSpace = 'nowrap';\n\n        // Use the HTML specific .css method\n        wrapper.css = wrapper.htmlCss;\n\n        // This is specific for HTML within SVG\n        if (isSVG) {\n            wrapper.add = function (svgGroupWrapper) {\n\n                var htmlGroup,\n                    container = renderer.box.parentNode,\n                    parentGroup,\n                    parents = [];\n\n                this.parentGroup = svgGroupWrapper;\n\n                // Create a mock group to hold the HTML elements\n                if (svgGroupWrapper) {\n                    htmlGroup = svgGroupWrapper.div;\n                    if (!htmlGroup) {\n\n                        // Read the parent chain into an array and read from top down\n                        parentGroup = svgGroupWrapper;\n                        while (parentGroup) {\n\n                            parents.push(parentGroup);\n\n                            // Move up to the next parent group\n                            parentGroup = parentGroup.parentGroup;\n                        }\n\n                        // Ensure dynamically updating position when any parent is translated\n                        each(parents.reverse(), function (parentGroup) {\n                            var htmlGroupStyle,\n                                cls = attr(parentGroup.element, 'class');\n\n                            if (cls) {\n                                cls = { className: cls };\n                            } // else null\n\n                            // Create a HTML div and append it to the parent div to emulate\n                            // the SVG group structure\n                            htmlGroup = parentGroup.div = parentGroup.div || createElement('div', cls, {\n                                position: 'absolute',\n                                left: (parentGroup.translateX || 0) + 'px',\n                                top: (parentGroup.translateY || 0) + 'px',\n                                opacity: parentGroup.opacity // #5075\n                            }, htmlGroup || container); // the top group is appended to container\n\n                            // Shortcut\n                            htmlGroupStyle = htmlGroup.style;\n\n                            // Set listeners to update the HTML div's position whenever the SVG group\n                            // position is changed\n                            extend(parentGroup, {\n                                translateXSetter: function (value, key) {\n                                    htmlGroupStyle.left = value + 'px';\n                                    parentGroup[key] = value;\n                                    parentGroup.doTransform = true;\n                                },\n                                translateYSetter: function (value, key) {\n                                    htmlGroupStyle.top = value + 'px';\n                                    parentGroup[key] = value;\n                                    parentGroup.doTransform = true;\n                                }\n                            });\n                            addSetters(parentGroup, htmlGroupStyle);\n                        });\n\n                    }\n                } else {\n                    htmlGroup = container;\n                }\n\n                htmlGroup.appendChild(element);\n\n                // Shared with VML:\n                wrapper.added = true;\n                if (wrapper.alignOnAdd) {\n                    wrapper.htmlUpdateTransform();\n                }\n\n                return wrapper;\n            };\n        }\n        return wrapper;\n    }\n});\n\n    return H;\n}(Highcharts));\n";
if (build.classic) { 
s += "\n(function (H) {\n    var VMLRenderer,\n        VMLRendererExtension,\n        VMLElement,\n\n        Color = H.Color,\n        createElement = H.createElement,\n        css = H.css,\n        defaultOptions = H.defaultOptions,\n        defined = H.defined,\n        deg2rad = H.deg2rad,\n        discardElement = H.discardElement,\n        doc = H.doc,\n        each = H.each,\n        erase = H.erase,\n        extend = H.extend,\n        extendClass = H.extendClass,\n        isArray = H.isArray,\n        isNumber = H.isNumber,\n        isObject = H.isObject,\n        merge = H.merge,\n        noop = H.noop,\n        pick = H.pick,\n        pInt = H.pInt,\n        svg = H.svg,\n        SVGElement = H.SVGElement,\n        SVGRenderer = H.SVGRenderer,\n        useCanVG = H.useCanVG,\n        win = H.win;\n\n/* ****************************************************************************\n *                                                                            *\n * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *\n *                                                                            *\n * For applications and websites that don't need IE support, like platform    *\n * targeted mobile apps and web apps, this code can be removed.               *\n *                                                                            *\n *****************************************************************************/\n\n/**\n * @constructor\n */\nif (!svg && !useCanVG) {\n\n/**\n * The VML element wrapper.\n */\nVMLElement = {\n\n    docMode8: doc && doc.documentMode === 8,\n\n    /**\n     * Initialize a new VML element wrapper. It builds the markup as a string\n     * to minimize DOM traffic.\n     * @param {Object} renderer\n     * @param {Object} nodeName\n     */\n    init: function (renderer, nodeName) {\n        var wrapper = this,\n            markup =  ['<', nodeName, ' filled=___doublequote___f___doublequote___ stroked=___doublequote___f___doublequote___'],\n            style = ['position: ', 'absolute', ';'],\n            isDiv = nodeName === 'div';\n\n        // divs and shapes need size\n        if (nodeName === 'shape' || isDiv) {\n            style.push('left:0;top:0;width:1px;height:1px;');\n        }\n        style.push('visibility: ', isDiv ? 'hidden' : 'visible');\n\n        markup.push(' style=___doublequote___', style.join(''), '___doublequote___/>');\n\n        // create element with default attributes and style\n        if (nodeName) {\n            markup = isDiv || nodeName === 'span' || nodeName === 'img' ?\n                markup.join('')    :\n                renderer.prepVML(markup);\n            wrapper.element = createElement(markup);\n        }\n\n        wrapper.renderer = renderer;\n    },\n\n    /**\n     * Add the node to the given parent\n     * @param {Object} parent\n     */\n    add: function (parent) {\n        var wrapper = this,\n            renderer = wrapper.renderer,\n            element = wrapper.element,\n            box = renderer.box,\n            inverted = parent && parent.inverted,\n\n            // get the parent node\n            parentNode = parent ?\n                parent.element || parent :\n                box;\n\n        if (parent) {\n            this.parentGroup = parent;\n        }\n\n        // if the parent group is inverted, apply inversion on all children\n        if (inverted) { // only on groups\n            renderer.invertChild(element, parentNode);\n        }\n\n        // append it\n        parentNode.appendChild(element);\n\n        // align text after adding to be able to read offset\n        wrapper.added = true;\n        if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {\n            wrapper.updateTransform();\n        }\n\n        // fire an event for internal hooks\n        if (wrapper.onAdd) {\n            wrapper.onAdd();\n        }\n\n        return wrapper;\n    },\n\n    /**\n     * VML always uses htmlUpdateTransform\n     */\n    updateTransform: SVGElement.prototype.htmlUpdateTransform,\n\n    /**\n     * Set the rotation of a span with oldIE's filter\n     */\n    setSpanRotation: function () {\n        // Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented\n        // but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+\n        // has support for CSS3 transform. The getBBox method also needs to be updated\n        // to compensate for the rotation, like it currently does for SVG.\n        // Test case: http://jsfiddle.net/highcharts/Ybt44/\n\n        var rotation = this.rotation,\n            costheta = Math.cos(rotation * deg2rad),\n            sintheta = Math.sin(rotation * deg2rad);\n                    \n        css(this.element, {\n            filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,\n                ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,\n                ', sizingMethod=\\'auto expand\\')'].join('') : 'none'\n        });\n    },\n\n    /**\n     * Get the positioning correction for the span after rotating.\n     */\n    getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {\n\n        var costheta = rotation ? Math.cos(rotation * deg2rad) : 1,\n            sintheta = rotation ? Math.sin(rotation * deg2rad) : 0,\n            height = pick(this.elemHeight, this.element.offsetHeight),\n            quad,\n            nonLeft = align && align !== 'left';\n\n        // correct x and y\n        this.xCorr = costheta < 0 && -width;\n        this.yCorr = sintheta < 0 && -height;\n\n        // correct for baseline and corners spilling out after rotation\n        quad = costheta * sintheta < 0;\n        this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);\n        this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);\n        // correct for the length/height of the text\n        if (nonLeft) {\n            this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);\n            if (rotation) {\n                this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);\n            }\n            css(this.element, {\n                textAlign: align\n            });\n        }\n    },\n\n    /**\n     * Converts a subset of an SVG path definition to its VML counterpart. Takes an array\n     * as the parameter and returns a string.\n     */\n    pathToVML: function (value) {\n        // convert paths\n        var i = value.length,\n            path = [];\n\n        while (i--) {\n\n            // Multiply by 10 to allow subpixel precision.\n            // Substracting half a pixel seems to make the coordinates\n            // align with SVG, but this hasn't been tested thoroughly\n            if (isNumber(value[i])) {\n                path[i] = Math.round(value[i] * 10) - 5;\n            } else if (value[i] === 'Z') { // close the path\n                path[i] = 'x';\n            } else {\n                path[i] = value[i];\n\n                // When the start X and end X coordinates of an arc are too close,\n                // they are rounded to the same value above. In this case, substract or\n                // add 1 from the end X and Y positions. #186, #760, #1371, #1410.\n                if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {\n                    // Start and end X\n                    if (path[i + 5] === path[i + 7]) {\n                        path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;\n                    }\n                    // Start and end Y\n                    if (path[i + 6] === path[i + 8]) {\n                        path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;\n                    }\n                }\n            }\n        }\n\n\n        // Loop up again to handle path shortcuts (#2132)\n        /*while (i++ < path.length) {\n            if (path[i] === 'H') { // horizontal line to\n                path[i] = 'L';\n                path.splice(i + 2, 0, path[i - 1]);\n            } else if (path[i] === 'V') { // vertical line to\n                path[i] = 'L';\n                path.splice(i + 1, 0, path[i - 2]);\n            }\n        }*/\n        return path.join(' ') || 'x';\n    },\n\n    /**\n     * Set the element's clipping to a predefined rectangle\n     *\n     * @param {String} id The id of the clip rectangle\n     */\n    clip: function (clipRect) {\n        var wrapper = this,\n            clipMembers,\n            cssRet;\n\n        if (clipRect) {\n            clipMembers = clipRect.members;\n            erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)\n            clipMembers.push(wrapper);\n            wrapper.destroyClip = function () {\n                erase(clipMembers, wrapper);\n            };\n            cssRet = clipRect.getCSS(wrapper);\n\n        } else {\n            if (wrapper.destroyClip) {\n                wrapper.destroyClip();\n            }\n            cssRet = { clip: wrapper.docMode8 ? 'inherit' : 'rect(auto)' }; // #1214\n        }\n\n        return wrapper.css(cssRet);\n\n    },\n\n    /**\n     * Set styles for the element\n     * @param {Object} styles\n     */\n    css: SVGElement.prototype.htmlCss,\n\n    /**\n     * Removes a child either by removeChild or move to garbageBin.\n     * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n     */\n    safeRemoveChild: function (element) {\n        // discardElement will detach the node from its parent before attaching it\n        // to the garbage bin. Therefore it is important that the node is attached and have parent.\n        if (element.parentNode) {\n            discardElement(element);\n        }\n    },\n\n    /**\n     * Extend element.destroy by removing it from the clip members array\n     */\n    destroy: function () {\n        if (this.destroyClip) {\n            this.destroyClip();\n        }\n\n        return SVGElement.prototype.destroy.apply(this);\n    },\n\n    /**\n     * Add an event listener. VML override for normalizing event parameters.\n     * @param {String} eventType\n     * @param {Function} handler\n     */\n    on: function (eventType, handler) {\n        // simplest possible event model for internal use\n        this.element['on' + eventType] = function () {\n            var evt = win.event;\n            evt.target = evt.srcElement;\n            handler(evt);\n        };\n        return this;\n    },\n\n    /**\n     * In stacked columns, cut off the shadows so that they don't overlap\n     */\n    cutOffPath: function (path, length) {\n\n        var len;\n\n        path = path.split(/[ ,,]/); // The extra comma tricks the trailing comma remover in ___doublequote___gulp scripts___doublequote___ task\n        len = path.length;\n\n        if (len === 9 || len === 11) {\n            path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;\n        }\n        return path.join(' ');\n    },\n\n    /**\n     * Apply a drop shadow by copying elements and giving them different strokes\n     * @param {Boolean|Object} shadowOptions\n     */\n    shadow: function (shadowOptions, group, cutOff) {\n        var shadows = [],\n            i,\n            element = this.element,\n            renderer = this.renderer,\n            shadow,\n            elemStyle = element.style,\n            markup,\n            path = element.path,\n            strokeWidth,\n            modifiedPath,\n            shadowWidth,\n            shadowElementOpacity;\n\n        // some times empty paths are not strings\n        if (path && typeof path.value !== 'string') {\n            path = 'x';\n        }\n        modifiedPath = path;\n\n        if (shadowOptions) {\n            shadowWidth = pick(shadowOptions.width, 3);\n            shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n            for (i = 1; i <= 3; i++) {\n\n                strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\n                // Cut off shadows for stacked column items\n                if (cutOff) {\n                    modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);\n                }\n\n                markup = ['<shape isShadow=___doublequote___true___doublequote___ strokeweight=___doublequote___', strokeWidth,\n                    '___doublequote___ filled=___doublequote___false___doublequote___ path=___doublequote___', modifiedPath,\n                    '___doublequote___ coordsize=___doublequote___10 10___doublequote___ style=___doublequote___', element.style.cssText, '___doublequote___ />'];\n\n                shadow = createElement(renderer.prepVML(markup),\n                    null, {\n                        left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),\n                        top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)\n                    }\n                );\n                if (cutOff) {\n                    shadow.cutOff = strokeWidth + 1;\n                }\n\n                // apply the opacity\n                markup = ['<stroke color=___doublequote___', shadowOptions.color || 'black', '___doublequote___ opacity=___doublequote___', shadowElementOpacity * i, '___doublequote___/>'];\n                createElement(renderer.prepVML(markup), null, null, shadow);\n\n\n                // insert it\n                if (group) {\n                    group.element.appendChild(shadow);\n                } else {\n                    element.parentNode.insertBefore(shadow, element);\n                }\n\n                // record it\n                shadows.push(shadow);\n\n            }\n\n            this.shadows = shadows;\n        }\n        return this;\n    },\n    updateShadows: noop, // Used in SVG only\n\n    setAttr: function (key, value) {\n        if (this.docMode8) { // IE8 setAttribute bug\n            this.element[key] = value;\n        } else {\n            this.element.setAttribute(key, value);\n        }\n    },\n    classSetter: function (value) {\n        // IE8 Standards mode has problems retrieving the className unless set like this\n        this.element.className = value;\n    },\n    dashstyleSetter: function (value, key, element) {\n        var strokeElem = element.getElementsByTagName('stroke')[0] ||\n            createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);\n        strokeElem[key] = value || 'solid';\n        this[key] = value; /* because changing stroke-width will change the dash length\n            and cause an epileptic effect */\n    },\n    dSetter: function (value, key, element) {\n        var i,\n            shadows = this.shadows;\n        value = value || [];\n        this.d = value.join && value.join(' '); // used in getter for animation\n\n        element.path = value = this.pathToVML(value);\n\n        // update shadows\n        if (shadows) {\n            i = shadows.length;\n            while (i--) {\n                shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;\n            }\n        }\n        this.setAttr(key, value);\n    },\n    fillSetter: function (value, key, element) {\n        var nodeName = element.nodeName;\n        if (nodeName === 'SPAN') { // text color\n            element.style.color = value;\n        } else if (nodeName !== 'IMG') { // #1336\n            element.filled = value !== 'none';\n            this.setAttr('fillcolor', this.renderer.color(value, element, key, this));\n        }\n    },\n    'fill-opacitySetter': function (value, key, element) {\n        createElement(\n            this.renderer.prepVML(['<', key.split('-')[0], ' opacity=___doublequote___', value, '___doublequote___/>']),\n            null,\n            null,\n            element\n        );\n    },\n    opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts\n    rotationSetter: function (value, key, element) {\n        var style = element.style;\n        this[key] = style[key] = value; // style is for #1873\n\n        // Correction for the 1x1 size of the shape container. Used in gauge needles.\n        style.left = -Math.round(Math.sin(value * deg2rad) + 1) + 'px';\n        style.top = Math.round(Math.cos(value * deg2rad)) + 'px';\n    },\n    strokeSetter: function (value, key, element) {\n        this.setAttr('strokecolor', this.renderer.color(value, element, key, this));\n    },\n    'stroke-widthSetter': function (value, key, element) {\n        element.stroked = !!value; // VML ___doublequote___stroked___doublequote___ attribute\n        this[key] = value; // used in getter, issue #113\n        if (isNumber(value)) {\n            value += 'px';\n        }\n        this.setAttr('strokeweight', value);\n    },\n    titleSetter: function (value, key) {\n        this.setAttr(key, value);\n    },\n    visibilitySetter: function (value, key, element) {\n\n        // Handle inherited visibility\n        if (value === 'inherit') {\n            value = 'visible';\n        }\n\n        // Let the shadow follow the main element\n        if (this.shadows) {\n            each(this.shadows, function (shadow) {\n                shadow.style[key] = value;\n            });\n        }\n\n        // Instead of toggling the visibility CSS property, move the div out of the viewport.\n        // This works around #61 and #586\n        if (element.nodeName === 'DIV') {\n            value = value === 'hidden' ? '-999em' : 0;\n\n            // In order to redraw, IE7 needs the div to be visible when tucked away\n            // outside the viewport. So the visibility is actually opposite of\n            // the expected value. This applies to the tooltip only.\n            if (!this.docMode8) {\n                element.style[key] = value ? 'visible' : 'hidden';\n            }\n            key = 'top';\n        }\n        element.style[key] = value;\n    },\n    xSetter: function (value, key, element) {\n        this[key] = value; // used in getter\n\n        if (key === 'x') {\n            key = 'left';\n        } else if (key === 'y') {\n            key = 'top';\n        }/* else {\n            value = Math.max(0, value); // don't set width or height below zero (#311)\n        }*/\n\n        // clipping rectangle special\n        if (this.updateClipping) {\n            this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'\n            this.updateClipping();\n        } else {\n            // normal\n            element.style[key] = value;\n        }\n    },\n    zIndexSetter: function (value, key, element) {\n        element.style[key] = value;\n    }\n};\nH.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);\nVMLElement['stroke-opacitySetter'] = VMLElement['fill-opacitySetter'];\n\n// Some shared setters\nVMLElement.prototype.ySetter =\n    VMLElement.prototype.widthSetter =\n    VMLElement.prototype.heightSetter =\n    VMLElement.prototype.xSetter;\n\n\n/**\n * The VML renderer\n */\nVMLRendererExtension = { // inherit SVGRenderer\n\n    Element: VMLElement,\n    isIE8: win.navigator.userAgent.indexOf('MSIE 8.0') > -1,\n\n\n    /**\n     * Initialize the VMLRenderer\n     * @param {Object} container\n     * @param {Number} width\n     * @param {Number} height\n     */\n    init: function (container, width, height, style) {\n        var renderer = this,\n            boxWrapper,\n            box,\n            css;\n\n        renderer.alignedObjects = [];\n\n        boxWrapper = renderer.createElement('div')\n            .css(extend(this.getStyle(style), { position: 'relative' }));\n        box = boxWrapper.element;\n        container.appendChild(boxWrapper.element);\n\n\n        // generate the containing box\n        renderer.isVML = true;\n        renderer.box = box;\n        renderer.boxWrapper = boxWrapper;\n        renderer.gradients = {};\n        renderer.cache = {}; // Cache for numerical bounding boxes\n        renderer.cacheKeys = [];\n        renderer.imgCount = 0;\n\n\n        renderer.setSize(width, height, false);\n\n        // The only way to make IE6 and IE7 print is to use a global namespace. However,\n        // with IE8 the only way to make the dynamic shapes visible in screen and print mode\n        // seems to be to add the xmlns attribute and the behaviour style inline.\n        if (!doc.namespaces.hcv) {\n\n            doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');\n\n            // Setup default CSS (#2153, #2368, #2384)\n            css = 'hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke' +\n                '{ behavior:url(#default#VML); display: inline-block; } ';\n            try {\n                doc.createStyleSheet().cssText = css;\n            } catch (e) {\n                doc.styleSheets[0].cssText += css;\n            }\n\n        }\n    },\n\n\n    /**\n     * Detect whether the renderer is hidden. This happens when one of the parent elements\n     * has display: none\n     */\n    isHidden: function () {\n        return !this.box.offsetWidth;\n    },\n\n    /**\n     * Define a clipping rectangle. In VML it is accomplished by storing the values\n     * for setting the CSS style to all associated members.\n     *\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Number} width\n     * @param {Number} height\n     */\n    clipRect: function (x, y, width, height) {\n\n        // create a dummy element\n        var clipRect = this.createElement(),\n            isObj = isObject(x);\n\n        // mimic a rectangle with its style object for automatic updating in attr\n        return extend(clipRect, {\n            members: [],\n            count: 0,\n            left: (isObj ? x.x : x) + 1,\n            top: (isObj ? x.y : y) + 1,\n            width: (isObj ? x.width : width) - 1,\n            height: (isObj ? x.height : height) - 1,\n            getCSS: function (wrapper) {\n                var element = wrapper.element,\n                    nodeName = element.nodeName,\n                    isShape = nodeName === 'shape',\n                    inverted = wrapper.inverted,\n                    rect = this,\n                    top = rect.top - (isShape ? element.offsetTop : 0),\n                    left = rect.left,\n                    right = left + rect.width,\n                    bottom = top + rect.height,\n                    ret = {\n                        clip: 'rect(' +\n                            Math.round(inverted ? left : top) + 'px,' +\n                            Math.round(inverted ? bottom : right) + 'px,' +\n                            Math.round(inverted ? right : bottom) + 'px,' +\n                            Math.round(inverted ? top : left) + 'px)'\n                    };\n\n                // issue 74 workaround\n                if (!inverted && wrapper.docMode8 && nodeName === 'DIV') {\n                    extend(ret, {\n                        width: right + 'px',\n                        height: bottom + 'px'\n                    });\n                }\n                return ret;\n            },\n\n            // used in attr and animation to update the clipping of all members\n            updateClipping: function () {\n                each(clipRect.members, function (member) {\n                    if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.\n                        member.css(clipRect.getCSS(member));\n                    }\n                });\n            }\n        });\n\n    },\n\n\n    /**\n     * Take a color and return it if it's a string, make it a gradient if it's a\n     * gradient configuration object, and apply opacity.\n     *\n     * @param {Object} color The color or config object\n     */\n    color: function (color, elem, prop, wrapper) {\n        var renderer = this,\n            colorObject,\n            regexRgba = /^rgba/,\n            markup,\n            fillType,\n            ret = 'none';\n\n        // Check for linear or radial gradient\n        if (color && color.linearGradient) {\n            fillType = 'gradient';\n        } else if (color && color.radialGradient) {\n            fillType = 'pattern';\n        }\n\n\n        if (fillType) {\n\n            var stopColor,\n                stopOpacity,\n                gradient = color.linearGradient || color.radialGradient,\n                x1,\n                y1,\n                x2,\n                y2,\n                opacity1,\n                opacity2,\n                color1,\n                color2,\n                fillAttr = '',\n                stops = color.stops,\n                firstStop,\n                lastStop,\n                colors = [],\n                addFillNode = function () {\n                    // Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2\n                    // are reversed.\n                    markup = ['<fill colors=___doublequote___' + colors.join(',') + '___doublequote___ opacity=___doublequote___', opacity2, '___doublequote___ o:opacity2=___doublequote___', opacity1,\n                        '___doublequote___ type=___doublequote___', fillType, '___doublequote___ ', fillAttr, 'focus=___doublequote___100%___doublequote___ method=___doublequote___any___doublequote___ />'];\n                    createElement(renderer.prepVML(markup), null, null, elem);\n                };\n\n            // Extend from 0 to 1\n            firstStop = stops[0];\n            lastStop = stops[stops.length - 1];\n            if (firstStop[0] > 0) {\n                stops.unshift([\n                    0,\n                    firstStop[1]\n                ]);\n            }\n            if (lastStop[0] < 1) {\n                stops.push([\n                    1,\n                    lastStop[1]\n                ]);\n            }\n\n            // Compute the stops\n            each(stops, function (stop, i) {\n                if (regexRgba.test(stop[1])) {\n                    colorObject = Color(stop[1]);\n                    stopColor = colorObject.get('rgb');\n                    stopOpacity = colorObject.get('a');\n                } else {\n                    stopColor = stop[1];\n                    stopOpacity = 1;\n                }\n\n                // Build the color attribute\n                colors.push((stop[0] * 100) + '% ' + stopColor);\n\n                // Only start and end opacities are allowed, so we use the first and the last\n                if (!i) {\n                    opacity1 = stopOpacity;\n                    color2 = stopColor;\n                } else {\n                    opacity2 = stopOpacity;\n                    color1 = stopColor;\n                }\n            });\n\n            // Apply the gradient to fills only.\n            if (prop === 'fill') {\n\n                // Handle linear gradient angle\n                if (fillType === 'gradient') {\n                    x1 = gradient.x1 || gradient[0] || 0;\n                    y1 = gradient.y1 || gradient[1] || 0;\n                    x2 = gradient.x2 || gradient[2] || 0;\n                    y2 = gradient.y2 || gradient[3] || 0;\n                    fillAttr = 'angle=___doublequote___' + (90  - Math.atan(\n                        (y2 - y1) / // y vector\n                        (x2 - x1) // x vector\n                        ) * 180 / Math.PI) + '___doublequote___';\n\n                    addFillNode();\n\n                // Radial (circular) gradient\n                } else {\n\n                    var r = gradient.r,\n                        sizex = r * 2,\n                        sizey = r * 2,\n                        cx = gradient.cx,\n                        cy = gradient.cy,\n                        radialReference = elem.radialReference,\n                        bBox,\n                        applyRadialGradient = function () {\n                            if (radialReference) {\n                                bBox = wrapper.getBBox();\n                                cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;\n                                cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;\n                                sizex *= radialReference[2] / bBox.width;\n                                sizey *= radialReference[2] / bBox.height;\n                            }\n                            fillAttr = 'src=___doublequote___' + defaultOptions.global.VMLRadialGradientURL + '___doublequote___ ' +\n                                'size=___doublequote___' + sizex + ',' + sizey + '___doublequote___ ' +\n                                'origin=___doublequote___0.5,0.5___doublequote___ ' +\n                                'position=___doublequote___' + cx + ',' + cy + '___doublequote___ ' +\n                                'color2=___doublequote___' + color2 + '___doublequote___ ';\n\n                            addFillNode();\n                        };\n\n                    // Apply radial gradient\n                    if (wrapper.added) {\n                        applyRadialGradient();\n                    } else {\n                        // We need to know the bounding box to get the size and position right\n                        wrapper.onAdd = applyRadialGradient;\n                    }\n\n                    // The fill element's color attribute is broken in IE8 standards mode, so we\n                    // need to set the parent shape's fillcolor attribute instead.\n                    ret = color1;\n                }\n\n            // Gradients are not supported for VML stroke, return the first color. #722.\n            } else {\n                ret = stopColor;\n            }\n\n        // If the color is an rgba color, split it and add a fill node\n        // to hold the opacity component\n        } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {\n\n            colorObject = Color(color);\n\n            wrapper[prop + '-opacitySetter'](colorObject.get('a'), prop, elem);\n\n            ret = colorObject.get('rgb');\n\n\n        } else {\n            var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node\n            if (propNodes.length) {\n                propNodes[0].opacity = 1;\n                propNodes[0].type = 'solid';\n            }\n            ret = color;\n        }\n\n        return ret;\n    },\n\n    /**\n     * Take a VML string and prepare it for either IE8 or IE6/IE7.\n     * @param {Array} markup A string array of the VML markup to prepare\n     */\n    prepVML: function (markup) {\n        var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',\n            isIE8 = this.isIE8;\n\n        markup = markup.join('');\n\n        if (isIE8) { // add xmlns and style inline\n            markup = markup.replace('/>', ' xmlns=___doublequote___urn:schemas-microsoft-com:vml___doublequote___ />');\n            if (markup.indexOf('style=___doublequote___') === -1) {\n                markup = markup.replace('/>', ' style=___doublequote___' + vmlStyle + '___doublequote___ />');\n            } else {\n                markup = markup.replace('style=___doublequote___', 'style=___doublequote___' + vmlStyle);\n            }\n\n        } else { // add namespace\n            markup = markup.replace('<', '<hcv:');\n        }\n\n        return markup;\n    },\n\n    /**\n     * Create rotated and aligned text\n     * @param {String} str\n     * @param {Number} x\n     * @param {Number} y\n     */\n    text: SVGRenderer.prototype.html,\n\n    /**\n     * Create and return a path element\n     * @param {Array} path\n     */\n    path: function (path) {\n        var attr = {\n            // subpixel precision down to 0.1 (width and height = 1px)\n            coordsize: '10 10'\n        };\n        if (isArray(path)) {\n            attr.d = path;\n        } else if (isObject(path)) { // attributes\n            extend(attr, path);\n        }\n        // create the shape\n        return this.createElement('shape').attr(attr);\n    },\n\n    /**\n     * Create and return a circle element. In VML circles are implemented as\n     * shapes, which is faster than v:oval\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Number} r\n     */\n    circle: function (x, y, r) {\n        var circle = this.symbol('circle');\n        if (isObject(x)) {\n            r = x.r;\n            y = x.y;\n            x = x.x;\n        }\n        circle.isCircle = true; // Causes x and y to mean center (#1682)\n        circle.r = r;\n        return circle.attr({ x: x, y: y });\n    },\n\n    /**\n     * Create a group using an outer div and an inner v:group to allow rotating\n     * and flipping. A simple v:group would have problems with positioning\n     * child HTML elements and CSS clip.\n     *\n     * @param {String} name The name of the group\n     */\n    g: function (name) {\n        var wrapper,\n            attribs;\n\n        // set the class name\n        if (name) {\n            attribs = { 'className': 'highcharts-' + name, 'class': 'highcharts-' + name };\n        }\n\n        // the div to hold HTML and clipping\n        wrapper = this.createElement('div').attr(attribs);\n\n        return wrapper;\n    },\n\n    /**\n     * VML override to create a regular HTML image\n     * @param {String} src\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Number} width\n     * @param {Number} height\n     */\n    image: function (src, x, y, width, height) {\n        var obj = this.createElement('img')\n            .attr({ src: src });\n\n        if (arguments.length > 1) {\n            obj.attr({\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            });\n        }\n        return obj;\n    },\n\n    /**\n     * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems\n     */\n    createElement: function (nodeName) {\n        return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);\n    },\n\n    /**\n     * In the VML renderer, each child of an inverted div (group) is inverted\n     * @param {Object} element\n     * @param {Object} parentNode\n     */\n    invertChild: function (element, parentNode) {\n        var ren = this,\n            parentStyle = parentNode.style,\n            imgStyle = element.tagName === 'IMG' && element.style; // #1111\n\n        css(element, {\n            flip: 'x',\n            left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),\n            top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),\n            rotation: -90\n        });\n\n        // Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.\n        each(element.childNodes, function (child) {\n            ren.invertChild(child, element);\n        });\n    },\n\n    /**\n     * Symbol definitions that override the parent SVG renderer's symbols\n     *\n     */\n    symbols: {\n        // VML specific arc function\n        arc: function (x, y, w, h, options) {\n            var start = options.start,\n                end = options.end,\n                radius = options.r || w || h,\n                innerRadius = options.innerR,\n                cosStart = Math.cos(start),\n                sinStart = Math.sin(start),\n                cosEnd = Math.cos(end),\n                sinEnd = Math.sin(end),\n                ret;\n\n            if (end - start === 0) { // no angle, don't show it.\n                return ['x'];\n            }\n\n            ret = [\n                'wa', // clockwise arc to\n                x - radius, // left\n                y - radius, // top\n                x + radius, // right\n                y + radius, // bottom\n                x + radius * cosStart, // start x\n                y + radius * sinStart, // start y\n                x + radius * cosEnd, // end x\n                y + radius * sinEnd  // end y\n            ];\n\n            if (options.open && !innerRadius) {\n                ret.push(\n                    'e',\n                    'M',\n                    x, // - innerRadius,\n                    y // - innerRadius\n                );\n            }\n\n            ret.push(\n                'at', // anti clockwise arc to\n                x - innerRadius, // left\n                y - innerRadius, // top\n                x + innerRadius, // right\n                y + innerRadius, // bottom\n                x + innerRadius * cosEnd, // start x\n                y + innerRadius * sinEnd, // start y\n                x + innerRadius * cosStart, // end x\n                y + innerRadius * sinStart, // end y\n                'x', // finish path\n                'e' // close\n            );\n\n            ret.isArc = true;\n            return ret;\n\n        },\n        // Add circle symbol path. This performs significantly faster than v:oval.\n        circle: function (x, y, w, h, wrapper) {\n\n            if (wrapper) {\n                w = h = 2 * wrapper.r;\n            }\n\n            // Center correction, #1682\n            if (wrapper && wrapper.isCircle) {\n                x -= w / 2;\n                y -= h / 2;\n            }\n\n            // Return the path\n            return [\n                'wa', // clockwisearcto\n                x, // left\n                y, // top\n                x + w, // right\n                y + h, // bottom\n                x + w, // start x\n                y + h / 2,     // start y\n                x + w, // end x\n                y + h / 2,     // end y\n                //'x', // finish path\n                'e' // close\n            ];\n        },\n        /**\n         * Add rectangle symbol path which eases rotation and omits arcsize problems\n         * compared to the built-in VML roundrect shape. When borders are not rounded,\n         * use the simpler square path, else use the callout path without the arrow.\n         */\n        rect: function (x, y, w, h, options) {\n            return SVGRenderer.prototype.symbols[\n                !defined(options) || !options.r ? 'square' : 'callout'\n            ].call(0, x, y, w, h, options);\n        }\n    }\n};\nH.VMLRenderer = VMLRenderer = function () {\n    this.init.apply(this, arguments);\n};\nVMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);\n\n    // general renderer\n    H.Renderer = VMLRenderer;\n}\n\n// This method is used with exporting in old IE, when emulating SVG (see #2314)\nSVGRenderer.prototype.measureSpanWidth = function (text, styles) {\n    var measuringSpan = doc.createElement('span'),\n        offsetWidth,\n        textNode = doc.createTextNode(text);\n\n    measuringSpan.appendChild(textNode);\n    css(measuringSpan, styles);\n    this.box.appendChild(measuringSpan);\n    offsetWidth = measuringSpan.offsetWidth;\n    discardElement(measuringSpan); // #2463\n    return offsetWidth;\n};\n\n\n/* ****************************************************************************\n *                                                                            *\n * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *\n *                                                                            *\n *****************************************************************************/\n    \n    return H;\n}(Highcharts));\n\n";
} 
s += "\n(function (H) {\n    var CanVGRenderer,\n        doc = H.win.doc,\n        useCanVG = H.useCanVG;\n\n/* ****************************************************************************\n *                                                                            *\n * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *\n * TARGETING THAT SYSTEM.                                                     *\n *                                                                            *\n *****************************************************************************/\n\n/**\n * Downloads a script and executes a callback when done.\n * @param {String} scriptLocation\n * @param {Function} callback\n */\nfunction getScript(scriptLocation, callback) {\n    var head = doc.getElementsByTagName('head')[0],\n        script = doc.createElement('script');\n\n    script.type = 'text/javascript';\n    script.src = scriptLocation;\n    script.onload = callback;\n\n    head.appendChild(script);\n}\n\nif (useCanVG) {\n    /**\n     * The CanVGRenderer is empty from start to keep the source footprint small.\n     * When requested, the CanVGController downloads the rest of the source packaged\n     * together with the canvg library.\n     */\n    H.Renderer = CanVGRenderer = function () {\n        // Override the global SVG namespace to fake SVG/HTML that accepts CSS\n        H.SVG_NS = 'http://www.w3.org/1999/xhtml';\n    };\n\n    /**\n     * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but\n     * the implementation from SvgRenderer will not be merged in until first render.\n     */\n    CanVGRenderer.prototype.symbols = {};\n\n    /**\n     * Handles on demand download of canvg rendering support.\n     */\n    H.CanVGController = (function () {\n        // List of renderering calls\n        var deferredRenderCalls = [];\n\n        /**\n         * When downloaded, we are ready to draw deferred charts.\n         */\n        function drawDeferred() {\n            var callLength = deferredRenderCalls.length,\n                callIndex;\n\n            // Draw all pending render calls\n            for (callIndex = 0; callIndex < callLength; callIndex++) {\n                deferredRenderCalls[callIndex]();\n            }\n            // Clear the list\n            deferredRenderCalls = [];\n        }\n\n        return {\n            push: function (func, scriptLocation) {\n                // Only get the script once\n                if (deferredRenderCalls.length === 0) {\n                    getScript(scriptLocation, drawDeferred);\n                }\n                // Register render call\n                deferredRenderCalls.push(func);\n            }\n        };\n    }());\n} // end CanVGRenderer\n\n/* ****************************************************************************\n *                                                                            *\n * END OF ANDROID < 3 SPECIFIC CODE                                           *\n *                                                                            *\n *****************************************************************************/\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var correctFloat = H.correctFloat,\n        defined = H.defined,\n        destroyObjectProperties = H.destroyObjectProperties,\n        isNumber = H.isNumber,\n        merge = H.merge,\n        pick = H.pick,\n        deg2rad = H.deg2rad;\n\n/**\n * The Tick class\n */\nH.Tick = function (axis, pos, type, noLabel) {\n    this.axis = axis;\n    this.pos = pos;\n    this.type = type || '';\n    this.isNew = true;\n\n    if (!type && !noLabel) {\n        this.addLabel();\n    }\n};\n\nH.Tick.prototype = {\n    /**\n     * Write the tick label\n     */\n    addLabel: function () {\n        var tick = this,\n            axis = tick.axis,\n            options = axis.options,\n            chart = axis.chart,\n            categories = axis.categories,\n            names = axis.names,\n            pos = tick.pos,\n            labelOptions = options.labels,\n            str,\n            tickPositions = axis.tickPositions,\n            isFirst = pos === tickPositions[0],\n            isLast = pos === tickPositions[tickPositions.length - 1],\n            value = categories ?\n                pick(categories[pos], names[pos], pos) :\n                pos,\n            label = tick.label,\n            tickPositionInfo = tickPositions.info,\n            dateTimeLabelFormat;\n\n        // Set the datetime label format. If a higher rank is set for this position, use that. If not,\n        // use the general format.\n        if (axis.isDatetimeAxis && tickPositionInfo) {\n            dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];\n        }\n        // set properties for access in render method\n        tick.isFirst = isFirst;\n        tick.isLast = isLast;\n\n        // get the string\n        str = axis.labelFormatter.call({\n            axis: axis,\n            chart: chart,\n            isFirst: isFirst,\n            isLast: isLast,\n            dateTimeLabelFormat: dateTimeLabelFormat,\n            value: axis.isLog ? correctFloat(axis.lin2log(value)) : value\n        });\n\n        // prepare CSS\n        //css = width && { width: Math.max(1, Math.round(width - 2 * (labelOptions.padding || 10))) + 'px' };\n        \n        // first call\n        if (!defined(label)) {\n\n            tick.label = label =\n                defined(str) && labelOptions.enabled ?\n                    chart.renderer.text(\n                            str,\n                            0,\n                            0,\n                            labelOptions.useHTML\n                        )\n                        ";
if (build.classic) { 
s += "\n                        // without position absolute, IE export sometimes is wrong\n                        .css(merge(labelOptions.style))\n                        ";
} 
s += "\n                        .add(axis.labelGroup) :\n                    null;\n            tick.labelLength = label && label.getBBox().width; // Un-rotated length\n            tick.rotation = 0; // Base value to detect change for new calls to getBBox\n\n        // update\n        } else if (label) {\n            label.attr({ text: str });\n        }\n    },\n\n    /**\n     * Get the offset height or width of the label\n     */\n    getLabelSize: function () {\n        return this.label ?\n            this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :\n            0;\n    },\n\n    /**\n     * Handle the label overflow by adjusting the labels to the left and right edge, or\n     * hide them if they collide into the neighbour label.\n     */\n    handleOverflow: function (xy) {\n        var axis = this.axis,\n            pxPos = xy.x,\n            chartWidth = axis.chart.chartWidth,\n            spacing = axis.chart.spacing,\n            leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),\n            rightBound = pick(axis.labelRight, Math.max(axis.pos + axis.len, chartWidth - spacing[1])),\n            label = this.label,\n            rotation = this.rotation,\n            factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],\n            labelWidth = label.getBBox().width,\n            slotWidth = axis.getSlotWidth(),\n            modifiedSlotWidth = slotWidth,\n            xCorrection = factor,\n            goRight = 1,\n            leftPos,\n            rightPos,\n            textWidth,\n            css = {};\n\n        // Check if the label overshoots the chart spacing box. If it does, move it.\n        // If it now overshoots the slotWidth, add ellipsis.\n        if (!rotation) {\n            leftPos = pxPos - factor * labelWidth;\n            rightPos = pxPos + (1 - factor) * labelWidth;\n\n            if (leftPos < leftBound) {\n                modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;\n            } else if (rightPos > rightBound) {\n                modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;\n                goRight = -1;\n            }\n\n            modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177\n            if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {\n                xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));\n            }\n            // If the label width exceeds the available space, set a text width to be\n            // picked up below. Also, if a width has been set before, we need to set a new\n            // one because the reported labelWidth will be limited by the box (#3938).\n            if (labelWidth > modifiedSlotWidth || (axis.autoRotation && (label.styles || {}).width)) {\n                textWidth = modifiedSlotWidth;\n            }\n\n        // Add ellipsis to prevent rotated labels to be clipped against the edge of the chart\n        } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n            textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound);\n        } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n            textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad));\n        }\n\n        if (textWidth) {\n            css.width = textWidth;\n            if (!(axis.options.labels.style || {}).textOverflow) {\n                css.textOverflow = 'ellipsis';\n            }\n            label.css(css);\n        }\n    },\n\n    /**\n     * Get the x and y position for ticks and labels\n     */\n    getPosition: function (horiz, pos, tickmarkOffset, old) {\n        var axis = this.axis,\n            chart = axis.chart,\n            cHeight = (old && chart.oldChartHeight) || chart.chartHeight;\n\n        return {\n            x: horiz ?\n                axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :\n                axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),\n\n            y: horiz ?\n                cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :\n                cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB\n        };\n\n    },\n\n    /**\n     * Get the x, y position of the tick label\n     */\n    getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n        var axis = this.axis,\n            transA = axis.transA,\n            reversed = axis.reversed,\n            staggerLines = axis.staggerLines,\n            rotCorr = axis.tickRotCorr || { x: 0, y: 0 },\n            yOffset = labelOptions.y,\n            line;\n\n        if (!defined(yOffset)) {\n            if (axis.side === 0) {\n                yOffset = label.rotation ? -8 : -label.getBBox().height;\n            } else if (axis.side === 2) {\n                yOffset = rotCorr.y + 8;\n            } else {\n                // #3140, #3140\n                yOffset = Math.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);\n            }\n        }\n\n        x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?\n            tickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n        y = y + yOffset - (tickmarkOffset && !horiz ?\n            tickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n\n        // Correct for staggered labels\n        if (staggerLines) {\n            line = (index / (step || 1) % staggerLines);\n            if (axis.opposite) {\n                line = staggerLines - line - 1;\n            }\n            y += line * (axis.labelOffset / staggerLines);\n        }\n\n        return {\n            x: x,\n            y: Math.round(y)\n        };\n    },\n\n    /**\n     * Extendible method to return the path of the marker\n     */\n    getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {\n        return renderer.crispLine([\n            'M',\n            x,\n            y,\n            'L',\n            x + (horiz ? 0 : -tickLength),\n            y + (horiz ? tickLength : 0)\n        ], tickWidth);\n    },\n\n    /**\n     * Put everything in place\n     *\n     * @param index {Number}\n     * @param old {Boolean} Use old coordinates to prepare an animation into new position\n     */\n    render: function (index, old, opacity) {\n        var tick = this,\n            axis = tick.axis,\n            options = axis.options,\n            chart = axis.chart,\n            renderer = chart.renderer,\n            horiz = axis.horiz,\n            type = tick.type,\n            label = tick.label,\n            pos = tick.pos,\n            labelOptions = options.labels,\n            gridLine = tick.gridLine,\n            tickPrefix = type ? type + 'Tick' : 'tick',\n            tickPosition = options[tickPrefix + 'Position'],\n            tickSize = axis.tickSize(tickPrefix),\n            gridLinePath,\n            mark = tick.mark,\n            isNewMark = !mark,\n            step = labelOptions.step,\n            attribs = {},\n            show = true,\n            tickmarkOffset = axis.tickmarkOffset,\n            xy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n            x = xy.x,\n            y = xy.y,\n            reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687\n\n        ";
if (build.classic) { 
s += "\n        var gridPrefix = type ? type + 'Grid' : 'grid',\n            gridLineWidth = options[gridPrefix + 'LineWidth'],\n            gridLineColor = options[gridPrefix + 'LineColor'],\n            dashStyle = options[gridPrefix + 'LineDashStyle'],\n            tickWidth = pick(options[tickPrefix + 'Width'], !type && axis.isXAxis ? 1 : 0), // X axis defaults to 1\n            tickColor = options[tickPrefix + 'Color'];\n        ";
} 
s += "\n\n        opacity = pick(opacity, 1);\n        this.isActive = true;\n\n        // Create the grid line\n        if (gridLine === undefined) {\n            ";
if (build.classic) { 
s += "\n            attribs.stroke = gridLineColor;\n            attribs['stroke-width'] = gridLineWidth;\n            if (dashStyle) {\n                attribs.dashstyle = dashStyle;\n            }\n            ";
} 
s += "\n            if (!type) {\n                attribs.zIndex = 1;\n            }\n            if (old) {\n                attribs.opacity = 0;\n            }\n            tick.gridLine = gridLine = renderer.path()\n                .attr(attribs)\n                .addClass('highcharts-' + (type ? type + '-' : '') + 'grid-line')\n                .add(axis.gridGroup);\n        }\n\n        // If the parameter 'old' is set, the current call will be followed\n        // by another call, therefore do not do any animations this time\n        if (!old && gridLine) {\n            gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLine.strokeWidth() * reverseCrisp, old, true);\n            gridLine[tick.isNew ? 'attr' : 'animate']({\n                d: gridLinePath,\n                opacity: opacity\n            });\n        }\n\n        // create the tick mark\n        if (tickSize) {\n\n            // negate the length\n            if (tickPosition === 'inside') {\n                tickSize[0] = -tickSize[0];\n            }\n            if (axis.opposite) {\n                tickSize[0] = -tickSize[0];\n            }\n\n            // First time, create it\n            if (isNewMark) {\n                tick.mark = mark = renderer.path()\n                    .addClass('highcharts-' + (type ? type + '-' : '') + 'tick')\n                    .add(axis.axisGroup);\n\n                ";
if (build.classic) { 
s += "\n                mark.attr({\n                    stroke: tickColor,\n                    'stroke-width': tickWidth\n                });\n                ";
} 
s += "\n            }\n            mark[isNewMark ? 'attr' : 'animate']({\n                d: tick.getMarkPath(x, y, tickSize[1], mark.strokeWidth() * reverseCrisp, horiz, renderer),\n                opacity: opacity\n            });\n            \n        }\n\n        // the label is created on init - now move it into place\n        if (label && isNumber(x)) {\n            label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n\n            // Apply show first and show last. If the tick is both first and last, it is\n            // a single centered tick, in which case we show the label anyway (#2100).\n            if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||\n                    (tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {\n                show = false;\n\n            // Handle label overflow and show or hide accordingly\n            } else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {\n                tick.handleOverflow(xy);\n            }\n\n            // apply step\n            if (step && index % step) {\n                // show those indices dividable by step\n                show = false;\n            }\n\n            // Set the new position, and show or hide\n            if (show && isNumber(xy.y)) {\n                xy.opacity = opacity;\n                label[tick.isNew ? 'attr' : 'animate'](xy);\n                tick.isNew = false;\n            } else {\n                label.attr('y', -9999); // #1338\n            }\n        }\n    },\n\n    /**\n     * Destructor for the tick prototype\n     */\n    destroy: function () {\n        destroyObjectProperties(this, this.axis);\n    }\n};\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var arrayMax = H.arrayMax,\n        arrayMin = H.arrayMin,\n        defined = H.defined,\n        destroyObjectProperties = H.destroyObjectProperties,\n        each = H.each,\n        erase = H.erase,\n        merge = H.merge,\n        pick = H.pick;\n/*\n * The object wrapper for plot lines and plot bands\n * @param {Object} options\n */\nH.PlotLineOrBand = function (axis, options) {\n    this.axis = axis;\n\n    if (options) {\n        this.options = options;\n        this.id = options.id;\n    }\n};\n\nH.PlotLineOrBand.prototype = {\n    \n    /**\n     * Render the plot line or plot band. If it is already existing,\n     * move it.\n     */\n    render: function () {\n        var plotLine = this,\n            axis = plotLine.axis,\n            horiz = axis.horiz,\n            options = plotLine.options,\n            optionsLabel = options.label,\n            label = plotLine.label,\n            to = options.to,\n            from = options.from,\n            value = options.value,\n            isBand = defined(from) && defined(to),\n            isLine = defined(value),\n            svgElem = plotLine.svgElem,\n            isNew = !svgElem,\n            path = [],\n            addEvent,\n            eventType,\n            color = options.color,\n            zIndex = pick(options.zIndex, 0),\n            events = options.events,\n            attribs = {\n                'class': 'highcharts-plot-' + (isBand ? 'band ' : 'line ') + (options.className || '') // docs: className\n            },\n            groupAttribs = {},\n            renderer = axis.chart.renderer,\n            groupName = isBand ? 'bands' : 'lines',\n            group,\n            log2lin = axis.log2lin;\n\n        // logarithmic conversion\n        if (axis.isLog) {\n            from = log2lin(from);\n            to = log2lin(to);\n            value = log2lin(value);\n        }\n\n        ";
if (build.classic) { 
s += "\n        // Set the presentational attributes\n        if (isLine) {\n            attribs = {\n                stroke: color,\n                'stroke-width': options.width\n            };\n            if (options.dashStyle) {\n                attribs.dashstyle = options.dashStyle;\n            }\n            \n        } else if (isBand) { // plot band\n            if (color) {\n                attribs.fill = color;\n            }\n            if (options.borderWidth) {\n                attribs.stroke = options.borderColor;\n                attribs['stroke-width'] = options.borderWidth;\n            }\n        }\n        ";
} 
s += "\n\n        // Grouping and zIndex\n        groupAttribs.zIndex = zIndex;\n        groupName += '-' + zIndex;\n\n        group = axis[groupName];\n        if (!group) {\n            axis[groupName] = group = renderer.g('plot-' + groupName)\n                .attr(groupAttribs).add();\n        }\n\n        // Create the path\n        if (isNew) {\n            plotLine.svgElem = svgElem = \n                renderer\n                    .path()\n                    .attr(attribs).add(group);\n        }\n        \n\n        // Set the path or return\n        if (isLine) {\n            path = axis.getPlotLinePath(value, svgElem.strokeWidth());\n        } else if (isBand) { // plot band\n            path = axis.getPlotBandPath(from, to, options);\n        } else {\n            return;\n        }\n\n        // common for lines and bands\n        if (isNew && path && path.length) {\n            svgElem.attr({ d: path });\n\n            // events\n            if (events) {\n                addEvent = function (eventType) {\n                    svgElem.on(eventType, function (e) {\n                        events[eventType].apply(plotLine, [e]);\n                    });\n                };\n                for (eventType in events) {\n                    addEvent(eventType);\n                }\n            }\n        } else if (svgElem) {\n            if (path) {\n                svgElem.show();\n                svgElem.animate({ d: path });\n            } else {\n                svgElem.hide();\n                if (label) {\n                    plotLine.label = label = label.destroy();\n                }\n            }\n        }\n\n        // the plot band/line label\n        if (optionsLabel && defined(optionsLabel.text) && path && path.length && \n                axis.width > 0 && axis.height > 0 && !path.flat) {\n            // apply defaults\n            optionsLabel = merge({\n                align: horiz && isBand && 'center',\n                x: horiz ? !isBand && 4 : 10,\n                verticalAlign: !horiz && isBand && 'middle',\n                y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,\n                rotation: horiz && !isBand && 90\n            }, optionsLabel);\n\n            this.renderLabel(optionsLabel, path, isBand, zIndex);\n\n        } else if (label) { // move out of sight\n            label.hide();\n        }\n\n        // chainable\n        return plotLine;\n    },\n\n    /**\n     * Render and align label for plot line or band.\n     */\n    renderLabel: function (optionsLabel, path, isBand, zIndex) {\n        var plotLine = this,\n            label = plotLine.label,\n            renderer = plotLine.axis.chart.renderer,\n            attribs,\n            xs,\n            ys,\n            x,\n            y;\n\n        // add the SVG element\n        if (!label) {\n            attribs = {\n                align: optionsLabel.textAlign || optionsLabel.align,\n                rotation: optionsLabel.rotation,\n                'class': 'highcharts-plot-' + (isBand ? 'band' : 'line') + '-label ' + (optionsLabel.className || '')\n            };\n            \n            attribs.zIndex = zIndex;\n            \n            plotLine.label = label = renderer.text(\n                    optionsLabel.text,\n                    0,\n                    0,\n                    optionsLabel.useHTML\n                )\n                .attr(attribs)\n                .add();\n\n            ";
if (build.classic) { 
s += "\n            label.css(optionsLabel.style);\n            ";
} 
s += "\n        }\n\n        // get the bounding box and align the label\n        // #3000 changed to better handle choice between plotband or plotline\n        xs = [path[1], path[4], (isBand ? path[6] : path[1])];\n        ys = [path[2], path[5], (isBand ? path[7] : path[2])];\n        x = arrayMin(xs);\n        y = arrayMin(ys);\n\n        label.align(optionsLabel, false, {\n            x: x,\n            y: y,\n            width: arrayMax(xs) - x,\n            height: arrayMax(ys) - y\n        });\n        label.show();\n    },\n\n    /**\n     * Remove the plot line or band\n     */\n    destroy: function () {\n        // remove it from the lookup\n        erase(this.axis.plotLinesAndBands, this);\n\n        delete this.axis;\n        destroyObjectProperties(this);\n    }\n};\n\n/**\n * Object with members for extending the Axis prototype\n * @todo Extend directly instead of adding object to Highcharts first\n */\n\nH.AxisPlotLineOrBandExtension = {\n\n    /**\n     * Create the path for a plot band\n     */\n    getPlotBandPath: function (from, to) {\n        var toPath = this.getPlotLinePath(to, null, null, true),\n            path = this.getPlotLinePath(from, null, null, true);\n\n        if (path && toPath) {\n\n            // Flat paths don't need labels (#3836)\n            path.flat = path.toString() === toPath.toString();\n\n            path.push(\n                toPath[4],\n                toPath[5],\n                toPath[1],\n                toPath[2]\n            );\n        } else { // outside the axis area\n            path = null;\n        }\n\n        return path;\n    },\n\n    addPlotBand: function (options) {\n        return this.addPlotBandOrLine(options, 'plotBands');\n    },\n\n    addPlotLine: function (options) {\n        return this.addPlotBandOrLine(options, 'plotLines');\n    },\n\n    /**\n     * Add a plot band or plot line after render time\n     *\n     * @param options {Object} The plotBand or plotLine configuration object\n     */\n    addPlotBandOrLine: function (options, coll) {\n        var obj = new H.PlotLineOrBand(this, options).render(),\n            userOptions = this.userOptions;\n\n        if (obj) { // #2189\n            // Add it to the user options for exporting and Axis.update\n            if (coll) {\n                userOptions[coll] = userOptions[coll] || [];\n                userOptions[coll].push(options);\n            }\n            this.plotLinesAndBands.push(obj);\n        }\n\n        return obj;\n    },\n\n    /**\n     * Remove a plot band or plot line from the chart by id\n     * @param {Object} id\n     */\n    removePlotBandOrLine: function (id) {\n        var plotLinesAndBands = this.plotLinesAndBands,\n            options = this.options,\n            userOptions = this.userOptions,\n            i = plotLinesAndBands.length;\n        while (i--) {\n            if (plotLinesAndBands[i].id === id) {\n                plotLinesAndBands[i].destroy();\n            }\n        }\n        each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {\n            i = arr.length;\n            while (i--) {\n                if (arr[i].id === id) {\n                    erase(arr, arr[i]);\n                }\n            }\n        });\n    }\n};\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var addEvent = H.addEvent,\n        animObject = H.animObject,\n        arrayMax = H.arrayMax,\n        arrayMin = H.arrayMin,\n        AxisPlotLineOrBandExtension = H.AxisPlotLineOrBandExtension,\n        correctFloat = H.correctFloat,\n        defaultOptions = H.defaultOptions,\n        defaultPlotOptions = H.defaultPlotOptions,\n        defined = H.defined,\n        deg2rad = H.deg2rad,\n        destroyObjectProperties = H.destroyObjectProperties,\n        each = H.each,\n        error = H.error,\n        extend = H.extend,\n        fireEvent = H.fireEvent,\n        format = H.format,\n        getMagnitude = H.getMagnitude,\n        grep = H.grep,\n        inArray = H.inArray,\n        isNumber = H.isNumber,\n        isString = H.isString,\n        merge = H.merge,\n        normalizeTickInterval = H.normalizeTickInterval,\n        pick = H.pick,\n        PlotLineOrBand = H.PlotLineOrBand,\n        removeEvent = H.removeEvent,\n        splat = H.splat,\n        syncTimeout = H.syncTimeout,\n        Tick = H.Tick;\n/**\n * Create a new axis object\n * @param {Object} chart\n * @param {Object} options\n */\nH.Axis = function () {\n    this.init.apply(this, arguments);\n};\n\nH.Axis.prototype = {\n\n    /**\n     * Default options for the X axis - the Y axis has extended defaults\n     */\n    defaultOptions: {\n        // allowDecimals: null,\n        // alternateGridColor: null,\n        // categories: [],\n        dateTimeLabelFormats: {\n            millisecond: '%H:%M:%S.%L',\n            second: '%H:%M:%S',\n            minute: '%H:%M',\n            hour: '%H:%M',\n            day: '%e. %b',\n            week: '%e. %b',\n            month: '%b \\'%y',\n            year: '%Y'\n        },\n        endOnTick: false,\n        // reversed: false,\n\n        labels: {\n            enabled: true,\n            // rotation: 0,\n            // align: 'center',\n            // step: null,\n            ";
if (build.classic) { 
s += "\n            style: {\n                color: '#606060',\n                cursor: 'default',\n                fontSize: '11px'\n            },\n            ";
} 
s += "\n            x: 0\n            //y: undefined\n            /*formatter: function () {\n                return this.value;\n            },*/\n        },\n        //linkedTo: null,\n        //max: undefined,\n        //min: undefined,\n        minPadding: 0.01,\n        maxPadding: 0.01,\n        //minRange: null,\n        //minorTickInterval: null,\n        minorTickLength: 2,\n        minorTickPosition: 'outside', // inside or outside\n        //opposite: false,\n        //offset: 0,\n        //plotBands: [{\n        //    events: {},\n        //    zIndex: 1,\n        //    labels: { align, x, verticalAlign, y, style, rotation, textAlign }\n        //}],\n        //plotLines: [{\n        //    events: {}\n        //  dashStyle: {}\n        //    zIndex:\n        //    labels: { align, x, verticalAlign, y, style, rotation, textAlign }\n        //}],\n        //reversed: false,\n        // showFirstLabel: true,\n        // showLastLabel: true,\n        startOfWeek: 1,\n        startOnTick: false,\n        //tickInterval: null,\n        tickLength: 10,\n        tickmarkPlacement: 'between', // on or between\n        tickPixelInterval: 100,\n        tickPosition: 'outside',\n        title: {\n            //text: null,\n            align: 'middle', // low, middle or high\n            //margin: 0 for horizontal, 10 for vertical axes,\n            //rotation: 0,\n            //side: 'outside',\n            ";
if (build.classic) { 
s += "\n            style: {\n                color: '#707070'\n            }\n            ";
} 
s += "\n            //x: 0,\n            //y: 0\n        },\n        type: 'linear', // linear, logarithmic or datetime\n        //visible: true\n        ";
if (build.classic) { 
s += "\n        minorGridLineColor: '#E0E0E0',\n        // minorGridLineDashStyle: null,\n        minorGridLineWidth: 1,\n        minorTickColor: '#A0A0A0',\n        //minorTickWidth: 0,\n        lineColor: '#C0D0E0',\n        lineWidth: 1,\n        gridLineColor: '#D8D8D8',\n        // gridLineDashStyle: 'solid',\n        // gridLineWidth: 0,\n        tickColor: '#C0D0E0'\n        // tickWidth: 1\n        ";
} 
s += "        \n    },\n\n    /**\n     * This options set extends the defaultOptions for Y axes\n     */\n    defaultYAxisOptions: {\n        endOnTick: true,\n        tickPixelInterval: 72,\n        showLastLabel: true,\n        labels: {\n            x: -8\n        },\n        maxPadding: 0.05,\n        minPadding: 0.05,\n        startOnTick: true,\n        title: {\n            rotation: 270,\n            text: 'Values'\n        },\n        stackLabels: {\n            enabled: false,\n            //align: dynamic,\n            //y: dynamic,\n            //x: dynamic,\n            //verticalAlign: dynamic,\n            //textAlign: dynamic,\n            //rotation: 0,\n            formatter: function () {\n                return H.numberFormat(this.total, -1);\n            },\n            style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })\n        },\n        ";
if (build.classic) { 
s += "\n        gridLineWidth: 1,        \n        lineWidth: 0\n        // tickWidth: 0\n        ";
} 
s += "\n    },\n\n    /**\n     * These options extend the defaultOptions for left axes\n     */\n    defaultLeftAxisOptions: {\n        labels: {\n            x: -15\n        },\n        title: {\n            rotation: 270\n        }\n    },\n\n    /**\n     * These options extend the defaultOptions for right axes\n     */\n    defaultRightAxisOptions: {\n        labels: {\n            x: 15\n        },\n        title: {\n            rotation: 90\n        }\n    },\n\n    /**\n     * These options extend the defaultOptions for bottom axes\n     */\n    defaultBottomAxisOptions: {\n        labels: {\n            autoRotation: [-45],\n            x: 0\n            // overflow: undefined,\n            // staggerLines: null\n        },\n        title: {\n            rotation: 0\n        }\n    },\n    /**\n     * These options extend the defaultOptions for top axes\n     */\n    defaultTopAxisOptions: {\n        labels: {\n            autoRotation: [-45],\n            x: 0\n            // overflow: undefined\n            // staggerLines: null\n        },\n        title: {\n            rotation: 0\n        }\n    },\n\n    /**\n     * Initialize the axis\n     */\n    init: function (chart, userOptions) {\n\n\n        var isXAxis = userOptions.isX,\n            axis = this;\n\n        axis.chart = chart;\n\n        // Flag, is the axis horizontal\n        axis.horiz = chart.inverted ? !isXAxis : isXAxis;\n\n        // Flag, isXAxis\n        axis.isXAxis = isXAxis;\n        axis.coll = isXAxis ? 'xAxis' : 'yAxis';\n\n        axis.opposite = userOptions.opposite; // needed in setOptions\n        axis.side = userOptions.side || (axis.horiz ?\n                (axis.opposite ? 0 : 2) : // top : bottom\n                (axis.opposite ? 1 : 3));  // right : left\n\n        axis.setOptions(userOptions);\n\n\n        var options = this.options,\n            type = options.type,\n            isDatetimeAxis = type === 'datetime';\n\n        axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format\n\n\n        // Flag, stagger lines or not\n        axis.userOptions = userOptions;\n\n        //axis.axisTitleMargin = undefined,// = options.title.margin,\n        axis.minPixelPadding = 0;\n\n        axis.reversed = options.reversed;\n        axis.visible = options.visible !== false;\n        axis.zoomEnabled = options.zoomEnabled !== false;\n\n        // Initial categories\n        axis.categories = options.categories || type === 'category';\n        axis.names = axis.names || []; // Preserve on update (#3830)\n\n        // Elements\n        //axis.axisGroup = undefined;\n        //axis.gridGroup = undefined;\n        //axis.axisTitle = undefined;\n        //axis.axisLine = undefined;\n\n        // Shorthand types\n        axis.isLog = type === 'logarithmic';\n        axis.isDatetimeAxis = isDatetimeAxis;\n\n        // Flag, if axis is linked to another axis\n        axis.isLinked = defined(options.linkedTo);\n        // Linked axis.\n        //axis.linkedParent = undefined;\n\n        // Tick positions\n        //axis.tickPositions = undefined; // array containing predefined positions\n        // Tick intervals\n        //axis.tickInterval = undefined;\n        //axis.minorTickInterval = undefined;\n\n\n        // Major ticks\n        axis.ticks = {};\n        axis.labelEdge = [];\n        // Minor ticks\n        axis.minorTicks = {};\n\n        // List of plotLines/Bands\n        axis.plotLinesAndBands = [];\n\n        // Alternate bands\n        axis.alternateBands = {};\n\n        // Axis metrics\n        //axis.left = undefined;\n        //axis.top = undefined;\n        //axis.width = undefined;\n        //axis.height = undefined;\n        //axis.bottom = undefined;\n        //axis.right = undefined;\n        //axis.transA = undefined;\n        //axis.transB = undefined;\n        //axis.oldTransA = undefined;\n        axis.len = 0;\n        //axis.oldMin = undefined;\n        //axis.oldMax = undefined;\n        //axis.oldUserMin = undefined;\n        //axis.oldUserMax = undefined;\n        //axis.oldAxisLength = undefined;\n        axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n        axis.range = options.range;\n        axis.offset = options.offset || 0;\n\n\n        // Dictionary for stacks\n        axis.stacks = {};\n        axis.oldStacks = {};\n        axis.stacksTouched = 0;\n\n        // Min and max in the data\n        //axis.dataMin = undefined,\n        //axis.dataMax = undefined,\n\n        // The axis range\n        axis.max = null;\n        axis.min = null;\n\n        // User set min and max\n        //axis.userMin = undefined,\n        //axis.userMax = undefined,\n\n        // Crosshair options\n        axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);\n        // Run Axis\n\n        var eventType,\n            events = axis.options.events;\n\n        // Register\n        if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()\n            if (isXAxis && !this.isColorAxis) { // #2713\n                chart.axes.splice(chart.xAxis.length, 0, axis);\n            } else {\n                chart.axes.push(axis);\n            }\n\n            chart[axis.coll].push(axis);\n        }\n\n        axis.series = axis.series || []; // populated by Series\n\n        // inverted charts have reversed xAxes as default\n        if (chart.inverted && isXAxis && axis.reversed === undefined) {\n            axis.reversed = true;\n        }\n\n        axis.removePlotBand = axis.removePlotBandOrLine;\n        axis.removePlotLine = axis.removePlotBandOrLine;\n\n\n        // register event listeners\n        for (eventType in events) {\n            addEvent(axis, eventType, events[eventType]);\n        }\n\n        // extend logarithmic axis\n        if (axis.isLog) {\n            axis.val2lin = axis.log2lin;\n            axis.lin2val = axis.lin2log;\n        }\n    },\n\n    /**\n     * Merge and set options\n     */\n    setOptions: function (userOptions) {\n        this.options = merge(\n            this.defaultOptions,\n            this.isXAxis ? {} : this.defaultYAxisOptions,\n            [this.defaultTopAxisOptions, this.defaultRightAxisOptions,\n                this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],\n            merge(\n                defaultOptions[this.coll], // if set in setOptions (#1053)\n                userOptions\n            )\n        );\n    },\n\n    /**\n     * The default label formatter. The context is a special config object for the label.\n     */\n    defaultLabelFormatter: function () {\n        var axis = this.axis,\n            value = this.value,\n            categories = axis.categories,\n            dateTimeLabelFormat = this.dateTimeLabelFormat,\n            numericSymbols = defaultOptions.lang.numericSymbols,\n            i = numericSymbols && numericSymbols.length,\n            multi,\n            ret,\n            formatOption = axis.options.labels.format,\n\n            // make sure the same symbol is added for all labels on a linear axis\n            numericSymbolDetector = axis.isLog ? value : axis.tickInterval;\n\n        if (formatOption) {\n            ret = format(formatOption, this);\n\n        } else if (categories) {\n            ret = value;\n\n        } else if (dateTimeLabelFormat) { // datetime axis\n            ret = H.dateFormat(dateTimeLabelFormat, value);\n\n        } else if (i && numericSymbolDetector >= 1000) {\n            // Decide whether we should add a numeric symbol like k (thousands) or M (millions).\n            // If we are to enable this in tooltip or other places as well, we can move this\n            // logic to the numberFormatter and enable it by a parameter.\n            while (i-- && ret === undefined) {\n                multi = Math.pow(1000, i + 1);\n                if (numericSymbolDetector >= multi && (value * 10) % multi === 0 && numericSymbols[i] !== null) {\n                    ret = H.numberFormat(value / multi, -1) + numericSymbols[i];\n                }\n            }\n        }\n\n        if (ret === undefined) {\n            if (Math.abs(value) >= 10000) { // add thousands separators\n                ret = H.numberFormat(value, -1);\n            } else { // small numbers\n                ret = H.numberFormat(value, -1, undefined, ''); // #2466\n            }\n        }\n\n        return ret;\n    },\n\n    /**\n     * Get the minimum and maximum for the series of each axis\n     */\n    getSeriesExtremes: function () {\n        var axis = this,\n            chart = axis.chart;\n        axis.hasVisibleSeries = false;\n\n        // Reset properties in case we're redrawing (#3353)\n        axis.dataMin = axis.dataMax = axis.threshold = null;\n        axis.softThreshold = !axis.isXAxis;\n\n        if (axis.buildStacks) {\n            axis.buildStacks();\n        }\n\n        // loop through this axis' series\n        each(axis.series, function (series) {\n\n            if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n\n                var seriesOptions = series.options,\n                    xData,\n                    threshold = seriesOptions.threshold,\n                    seriesDataMin,\n                    seriesDataMax;\n\n                axis.hasVisibleSeries = true;\n\n                // Validate threshold in logarithmic axes\n                if (axis.isLog && threshold <= 0) {\n                    threshold = null;\n                }\n\n                // Get dataMin and dataMax for X axes\n                if (axis.isXAxis) {\n                    xData = series.xData;\n                    if (xData.length) {\n                        // If xData contains values which is not numbers, then filter them out.\n                        // To prevent performance hit, we only do this after we have already\n                        // found seriesDataMin because in most cases all data is valid. #5234.\n                        seriesDataMin = arrayMin(xData);\n                        if (!isNumber(seriesDataMin) && !(seriesDataMin instanceof Date)) { // Date for #5010\n                            xData = grep(xData, function (x) {\n                                return isNumber(x);\n                            });\n                            seriesDataMin = arrayMin(xData); // Do it again with valid data\n                        }\n\n                        axis.dataMin = Math.min(pick(axis.dataMin, xData[0]), seriesDataMin);\n                        axis.dataMax = Math.max(pick(axis.dataMax, xData[0]), arrayMax(xData));\n                        \n                    }\n\n                // Get dataMin and dataMax for Y axes, as well as handle stacking and processed data\n                } else {\n\n                    // Get this particular series extremes\n                    series.getExtremes();\n                    seriesDataMax = series.dataMax;\n                    seriesDataMin = series.dataMin;\n\n                    // Get the dataMin and dataMax so far. If percentage is used, the min and max are\n                    // always 0 and 100. If seriesDataMin and seriesDataMax is null, then series\n                    // doesn't have active y data, we continue with nulls\n                    if (defined(seriesDataMin) && defined(seriesDataMax)) {\n                        axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n                        axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n                    }\n\n                    // Adjust to threshold\n                    if (defined(threshold)) {\n                        axis.threshold = threshold;\n                    }\n                    // If any series has a hard threshold, it takes precedence\n                    if (!seriesOptions.softThreshold || axis.isLog) {\n                        axis.softThreshold = false;\n                    }\n                }\n            }\n        });\n    },\n\n    /**\n     * Translate from axis value to pixel position on the chart, or back\n     *\n     */\n    translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n        var axis = this.linkedParent || this, // #1417\n            sign = 1,\n            cvsOffset = 0,\n            localA = old ? axis.oldTransA : axis.transA,\n            localMin = old ? axis.oldMin : axis.min,\n            returnValue,\n            minPixelPadding = axis.minPixelPadding,\n            doPostTranslate = (axis.isOrdinal || axis.isBroken || (axis.isLog && handleLog)) && axis.lin2val;\n\n        if (!localA) {\n            localA = axis.transA;\n        }\n\n        // In vertical axes, the canvas coordinates start from 0 at the top like in\n        // SVG.\n        if (cvsCoord) {\n            sign *= -1; // canvas coordinates inverts the value\n            cvsOffset = axis.len;\n        }\n\n        // Handle reversed axis\n        if (axis.reversed) {\n            sign *= -1;\n            cvsOffset -= sign * (axis.sector || axis.len);\n        }\n\n        // From pixels to value\n        if (backwards) { // reverse translation\n\n            val = val * sign + cvsOffset;\n            val -= minPixelPadding;\n            returnValue = val / localA + localMin; // from chart pixel to value\n            if (doPostTranslate) { // log and ordinal axes\n                returnValue = axis.lin2val(returnValue);\n            }\n\n        // From value to pixels\n        } else {\n            if (doPostTranslate) { // log and ordinal axes\n                val = axis.val2lin(val);\n            }\n            if (pointPlacement === 'between') {\n                pointPlacement = 0.5;\n            }\n            returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +\n                (isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);\n        }\n\n        return returnValue;\n    },\n\n    /**\n     * Utility method to translate an axis value to pixel position.\n     * @param {Number} value A value in terms of axis units\n     * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart\n     *        or just the axis/pane itself.\n     */\n    toPixels: function (value, paneCoordinates) {\n        return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);\n    },\n\n    /*\n     * Utility method to translate a pixel position in to an axis value\n     * @param {Number} pixel The pixel value coordinate\n     * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the\n     *        axis/pane itself.\n     */\n    toValue: function (pixel, paneCoordinates) {\n        return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);\n    },\n\n    /**\n     * Create the path for a plot line that goes from the given value on\n     * this axis, across the plot to the opposite side\n     * @param {Number} value\n     * @param {Number} lineWidth Used for calculation crisp line\n     * @param {Number] old Use old coordinates (for resizing and rescaling)\n     */\n    getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {\n        var axis = this,\n            chart = axis.chart,\n            axisLeft = axis.left,\n            axisTop = axis.top,\n            x1,\n            y1,\n            x2,\n            y2,\n            cHeight = (old && chart.oldChartHeight) || chart.chartHeight,\n            cWidth = (old && chart.oldChartWidth) || chart.chartWidth,\n            skip,\n            transB = axis.transB,\n            /**\n             * Check if x is between a and b. If not, either move to a/b or skip,\n             * depending on the force parameter.\n             */\n            between = function (x, a, b) {\n                if (x < a || x > b) {\n                    if (force) {\n                        x = Math.min(Math.max(a, x), b);\n                    } else {\n                        skip = true;\n                    }\n                }\n                return x;\n            };\n\n        translatedValue = pick(translatedValue, axis.translate(value, null, null, old));\n        x1 = x2 = Math.round(translatedValue + transB);\n        y1 = y2 = Math.round(cHeight - translatedValue - transB);\n        if (!isNumber(translatedValue)) { // no min or max\n            skip = true;\n\n        } else if (axis.horiz) {\n            y1 = axisTop;\n            y2 = cHeight - axis.bottom;\n            x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n        } else {\n            x1 = axisLeft;\n            x2 = cWidth - axis.right;\n            y1 = y2 = between(y1, axisTop, axisTop + axis.height);\n        }\n        return skip && !force ?\n            null :\n            chart.renderer.crispLine(['M', x1, y1, 'L', x2, y2], lineWidth || 1);\n    },\n\n    /**\n     * Set the tick positions of a linear axis to round values like whole tens or every five.\n     */\n    getLinearTickPositions: function (tickInterval, min, max) {\n        var pos,\n            lastPos,\n            roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval),\n            roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval),\n            tickPositions = [];\n\n        // For single points, add a tick regardless of the relative position (#2662)\n        if (min === max && isNumber(min)) {\n            return [min];\n        }\n\n        // Populate the intermediate values\n        pos = roundedMin;\n        while (pos <= roundedMax) {\n\n            // Place the tick on the rounded value\n            tickPositions.push(pos);\n\n            // Always add the raw tickInterval, not the corrected one.\n            pos = correctFloat(pos + tickInterval);\n\n            // If the interval is not big enough in the current min - max range to actually increase\n            // the loop variable, we need to break out to prevent endless loop. Issue #619\n            if (pos === lastPos) {\n                break;\n            }\n\n            // Record the last value\n            lastPos = pos;\n        }\n        return tickPositions;\n    },\n\n    /**\n     * Return the minor tick positions. For logarithmic axes, reuse the same logic\n     * as for major ticks.\n     */\n    getMinorTickPositions: function () {\n        var axis = this,\n            options = axis.options,\n            tickPositions = axis.tickPositions,\n            minorTickInterval = axis.minorTickInterval,\n            minorTickPositions = [],\n            pos,\n            i,\n            pointRangePadding = axis.pointRangePadding || 0,\n            min = axis.min - pointRangePadding, // #1498\n            max = axis.max + pointRangePadding, // #1498\n            range = max - min,\n            len;\n\n        // If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.\n        if (range && range / minorTickInterval < axis.len / 3) { // #3875\n\n            if (axis.isLog) {\n                len = tickPositions.length;\n                for (i = 1; i < len; i++) {\n                    minorTickPositions = minorTickPositions.concat(\n                        axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)\n                    );\n                }\n            } else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314\n                minorTickPositions = minorTickPositions.concat(\n                    axis.getTimeTicks(\n                        axis.normalizeTimeTickInterval(minorTickInterval),\n                        min,\n                        max,\n                        options.startOfWeek\n                    )\n                );\n            } else {\n                for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {\n                    minorTickPositions.push(pos);\n                }\n            }\n        }\n\n        if (minorTickPositions.length !== 0) { // don't change the extremes, when there is no minor ticks\n            axis.trimTicks(minorTickPositions, options.startOnTick, options.endOnTick); // #3652 #3743 #1498\n        }\n        return minorTickPositions;\n    },\n\n    /**\n     * Adjust the min and max for the minimum range. Keep in mind that the series data is\n     * not yet processed, so we don't have information on data cropping and grouping, or\n     * updated axis.pointRange or series.pointRange. The data can't be processed until\n     * we have finally established min and max.\n     */\n    adjustForMinRange: function () {\n        var axis = this,\n            options = axis.options,\n            min = axis.min,\n            max = axis.max,\n            zoomOffset,\n            spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,\n            closestDataRange,\n            i,\n            distance,\n            xData,\n            loopLength,\n            minArgs,\n            maxArgs,\n            minRange;\n\n        // Set the automatic minimum range based on the closest point distance\n        if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {\n\n            if (defined(options.min) || defined(options.max)) {\n                axis.minRange = null; // don't do this again\n\n            } else {\n\n                // Find the closest distance between raw data points, as opposed to\n                // closestPointRange that applies to processed points (cropped and grouped)\n                each(axis.series, function (series) {\n                    xData = series.xData;\n                    loopLength = series.xIncrement ? 1 : xData.length - 1;\n                    for (i = loopLength; i > 0; i--) {\n                        distance = xData[i] - xData[i - 1];\n                        if (closestDataRange === undefined || distance < closestDataRange) {\n                            closestDataRange = distance;\n                        }\n                    }\n                });\n                axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);\n            }\n        }\n\n        // if minRange is exceeded, adjust\n        if (max - min < axis.minRange) {\n            minRange = axis.minRange;\n            zoomOffset = (minRange - max + min) / 2;\n\n            // if min and max options have been set, don't go beyond it\n            minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];\n            if (spaceAvailable) { // if space is available, stay within the data range\n                minArgs[2] = axis.dataMin;\n            }\n            min = arrayMax(minArgs);\n\n            maxArgs = [min + minRange, pick(options.max, min + minRange)];\n            if (spaceAvailable) { // if space is availabe, stay within the data range\n                maxArgs[2] = axis.dataMax;\n            }\n\n            max = arrayMin(maxArgs);\n\n            // now if the max is adjusted, adjust the min back\n            if (max - min < minRange) {\n                minArgs[0] = max - minRange;\n                minArgs[1] = pick(options.min, max - minRange);\n                min = arrayMax(minArgs);\n            }\n        }\n\n        // Record modified extremes\n        axis.min = min;\n        axis.max = max;\n    },\n\n    /**\n     * Find the closestPointRange across all series\n     */\n    getClosest: function () {\n        var ret;\n        each(this.series, function (series) {\n            var seriesClosest = series.closestPointRange;\n            if (!series.noSharedTooltip && defined(seriesClosest)) {\n                ret = defined(ret) ?\n                    Math.min(ret, seriesClosest) :\n                    seriesClosest;\n            }\n        });\n        return ret;\n    },\n\n    /**\n     * Update translation information\n     */\n    setAxisTranslation: function (saveOld) {\n        var axis = this,\n            range = axis.max - axis.min,\n            pointRange = axis.axisPointRange || 0,\n            closestPointRange,\n            minPointOffset = 0,\n            pointRangePadding = 0,\n            linkedParent = axis.linkedParent,\n            ordinalCorrection,\n            hasCategories = !!axis.categories,\n            transA = axis.transA,\n            isXAxis = axis.isXAxis;\n\n        // Adjust translation for padding. Y axis with categories need to go through the same (#1784).\n        if (isXAxis || hasCategories || pointRange) {\n            if (linkedParent) {\n                minPointOffset = linkedParent.minPointOffset;\n                pointRangePadding = linkedParent.pointRangePadding;\n\n            } else {\n                \n                // Get the closest points\n                closestPointRange = axis.getClosest();\n\n                each(axis.series, function (series) {\n                    var seriesPointRange = hasCategories ? \n                        1 : \n                        (isXAxis ? \n                            pick(series.options.pointRange, closestPointRange, 0) : \n                            (axis.axisPointRange || 0)), // #2806\n                        pointPlacement = series.options.pointPlacement;\n\n                    pointRange = Math.max(pointRange, seriesPointRange);\n\n                    if (!axis.single) {\n                        // minPointOffset is the value padding to the left of the axis in order to make\n                        // room for points with a pointRange, typically columns. When the pointPlacement option\n                        // is 'between' or 'on', this padding does not apply.\n                        minPointOffset = Math.max(\n                            minPointOffset,\n                            isString(pointPlacement) ? 0 : seriesPointRange / 2\n                        );\n\n                        // Determine the total padding needed to the length of the axis to make room for the\n                        // pointRange. If the series' pointPlacement is 'on', no padding is added.\n                        pointRangePadding = Math.max(\n                            pointRangePadding,\n                            pointPlacement === 'on' ? 0 : seriesPointRange\n                        );\n                    }\n                });\n            }\n\n            // Record minPointOffset and pointRangePadding\n            ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853\n            axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;\n            axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;\n\n            // pointRange means the width reserved for each point, like in a column chart\n            axis.pointRange = Math.min(pointRange, range);\n\n            // closestPointRange means the closest distance between points. In columns\n            // it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange\n            // is some other value\n            if (isXAxis) {\n                axis.closestPointRange = closestPointRange;\n            }\n        }\n\n        // Secondary values\n        if (saveOld) {\n            axis.oldTransA = transA;\n        }\n        axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);\n        axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend\n        axis.minPixelPadding = transA * minPointOffset;\n    },\n\n    minFromRange: function () {\n        return this.max - this.range;\n    },\n\n    /**\n     * Set the tick positions to round values and optionally extend the extremes\n     * to the nearest tick\n     */\n    setTickInterval: function (secondPass) {\n        var axis = this,\n            chart = axis.chart,\n            options = axis.options,\n            isLog = axis.isLog,\n            log2lin = axis.log2lin,\n            isDatetimeAxis = axis.isDatetimeAxis,\n            isXAxis = axis.isXAxis,\n            isLinked = axis.isLinked,\n            maxPadding = options.maxPadding,\n            minPadding = options.minPadding,\n            length,\n            linkedParentExtremes,\n            tickIntervalOption = options.tickInterval,\n            minTickInterval,\n            tickPixelIntervalOption = options.tickPixelInterval,\n            categories = axis.categories,\n            threshold = axis.threshold,\n            softThreshold = axis.softThreshold,\n            thresholdMin,\n            thresholdMax,\n            hardMin,\n            hardMax;\n\n        if (!isDatetimeAxis && !categories && !isLinked) {\n            this.getTickAmount();\n        }\n\n        // Min or max set either by zooming/setExtremes or initial options\n        hardMin = pick(axis.userMin, options.min);\n        hardMax = pick(axis.userMax, options.max);\n\n        // Linked axis gets the extremes from the parent axis\n        if (isLinked) {\n            axis.linkedParent = chart[axis.coll][options.linkedTo];\n            linkedParentExtremes = axis.linkedParent.getExtremes();\n            axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n            axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n            if (options.type !== axis.linkedParent.options.type) {\n                error(11, 1); // Can't link axes of different type\n            }\n\n        // Initial min and max from the extreme data values\n        } else {\n\n            // Adjust to hard threshold\n            if (!softThreshold && defined(threshold)) {\n                if (axis.dataMin >= threshold) {\n                    thresholdMin = threshold;\n                    minPadding = 0;\n                } else if (axis.dataMax <= threshold) {\n                    thresholdMax = threshold;\n                    maxPadding = 0;\n                }\n            }\n\n            axis.min = pick(hardMin, thresholdMin, axis.dataMin);\n            axis.max = pick(hardMax, thresholdMax, axis.dataMax);\n\n        }\n\n        if (isLog) {\n            if (!secondPass && Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978\n                error(10, 1); // Can't plot negative values on log axis\n            }\n            // The correctFloat cures #934, float errors on full tens. But it\n            // was too aggressive for #4360 because of conversion back to lin,\n            // therefore use precision 15.\n            axis.min = correctFloat(log2lin(axis.min), 15);\n            axis.max = correctFloat(log2lin(axis.max), 15);\n        }\n\n        // handle zoomed range\n        if (axis.range && defined(axis.max)) {\n            axis.userMin = axis.min = hardMin = Math.max(axis.min, axis.minFromRange()); // #618\n            axis.userMax = hardMax = axis.max;\n\n            axis.range = null;  // don't use it when running setExtremes\n        }\n\n        // Hook for Highstock Scroller. Consider combining with beforePadding.\n        fireEvent(axis, 'foundExtremes');\n\n        // Hook for adjusting this.min and this.max. Used by bubble series.\n        if (axis.beforePadding) {\n            axis.beforePadding();\n        }\n\n        // adjust min and max for the minimum range\n        axis.adjustForMinRange();\n\n        // Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding\n        // into account, we do this after computing tick interval (#1337).\n        if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {\n            length = axis.max - axis.min;\n            if (length) {\n                if (!defined(hardMin) && minPadding) {\n                    axis.min -= length * minPadding;\n                }\n                if (!defined(hardMax)  && maxPadding) {\n                    axis.max += length * maxPadding;\n                }\n            }\n        }\n\n        // Stay within floor and ceiling\n        if (isNumber(options.floor)) {\n            axis.min = Math.max(axis.min, options.floor);\n        }\n        if (isNumber(options.ceiling)) {\n            axis.max = Math.min(axis.max, options.ceiling);\n        }\n\n        // When the threshold is soft, adjust the extreme value only if\n        // the data extreme and the padded extreme land on either side of the threshold. For example,\n        // a series of [0, 1, 2, 3] would make the yAxis add a tick for -1 because of the\n        // default minPadding and startOnTick options. This is prevented by the softThreshold\n        // option.\n        if (softThreshold && defined(axis.dataMin)) {\n            threshold = threshold || 0;\n            if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {\n                axis.min = threshold;\n            } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {\n                axis.max = threshold;\n            }\n        }\n\n\n        // get tickInterval\n        if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {\n            axis.tickInterval = 1;\n        } else if (isLinked && !tickIntervalOption &&\n                tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n            axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;\n        } else {\n            axis.tickInterval = pick(\n                tickIntervalOption,\n                this.tickAmount ? ((axis.max - axis.min) / Math.max(this.tickAmount - 1, 1)) : undefined,\n                categories ? // for categoried axis, 1 is default, for linear axis use tickPix\n                    1 :\n                    // don't let it be more than the data range\n                    (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption)\n            );\n        }\n\n        // Now we're finished detecting min and max, crop and group series data. This\n        // is in turn needed in order to find tick positions in ordinal axes.\n        if (isXAxis && !secondPass) {\n            each(axis.series, function (series) {\n                series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);\n            });\n        }\n\n        // set the translation factor used in translate function\n        axis.setAxisTranslation(true);\n\n        // hook for ordinal axes and radial axes\n        if (axis.beforeSetTickPositions) {\n            axis.beforeSetTickPositions();\n        }\n\n        // hook for extensions, used in Highstock ordinal axes\n        if (axis.postProcessTickInterval) {\n            axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n        }\n\n        // In column-like charts, don't cramp in more ticks than there are points (#1943, #4184)\n        if (axis.pointRange && !tickIntervalOption) {\n            axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);\n        }\n\n        // Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.\n        minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);\n        if (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n            axis.tickInterval = minTickInterval;\n        }\n\n        // for linear axes, get magnitude and normalize the interval\n        if (!isDatetimeAxis && !isLog && !tickIntervalOption) {\n            axis.tickInterval = normalizeTickInterval(\n                axis.tickInterval,\n                null,\n                getMagnitude(axis.tickInterval),\n                // If the tick interval is between 0.5 and 5 and the axis max is in the order of\n                // thousands, chances are we are dealing with years. Don't allow decimals. #3363.\n                pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),\n                !!this.tickAmount\n            );\n        }\n\n        // Prevent ticks from getting so close that we can't draw the labels\n        if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length\n            axis.tickInterval = axis.unsquish();\n        }\n\n        this.setTickPositions();\n    },\n\n    /**\n     * Now we have computed the normalized tickInterval, get the tick positions\n     */\n    setTickPositions: function () {\n\n        var options = this.options,\n            tickPositions,\n            tickPositionsOption = options.tickPositions,\n            tickPositioner = options.tickPositioner,\n            startOnTick = options.startOnTick,\n            endOnTick = options.endOnTick,\n            single;\n\n        // Set the tickmarkOffset\n        this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' &&\n            this.tickInterval === 1) ? 0.5 : 0; // #3202\n\n\n        // get minorTickInterval\n        this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?\n            this.tickInterval / 5 : options.minorTickInterval;\n\n        // Find the tick positions\n        this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)\n        if (!tickPositions) {\n\n            if (this.isDatetimeAxis) {\n                tickPositions = this.getTimeTicks(\n                    this.normalizeTimeTickInterval(this.tickInterval, options.units),\n                    this.min,\n                    this.max,\n                    options.startOfWeek,\n                    this.ordinalPositions,\n                    this.closestPointRange,\n                    true\n                );\n            } else if (this.isLog) {\n                tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);\n            } else {\n                tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);\n            }\n\n            // Too dense ticks, keep only the first and last (#4477)\n            if (tickPositions.length > this.len) {\n                tickPositions = [tickPositions[0], tickPositions.pop()];\n            }\n\n            this.tickPositions = tickPositions;\n\n            // Run the tick positioner callback, that allows modifying auto tick positions.\n            if (tickPositioner) {\n                tickPositioner = tickPositioner.apply(this, [this.min, this.max]);\n                if (tickPositioner) {\n                    this.tickPositions = tickPositions = tickPositioner;\n                }\n            }\n\n        }\n\n        if (!this.isLinked) {\n\n            // reset min/max or remove extremes based on start/end on tick\n            this.trimTicks(tickPositions, startOnTick, endOnTick);\n\n            // When there is only one point, or all points have the same value on this axis, then min\n            // and max are equal and tickPositions.length is 0 or 1. In this case, add some padding\n            // in order to center the point, but leave it with one tick. #1337.\n            if (this.min === this.max && defined(this.min) && !this.tickAmount) {\n                // Substract half a unit (#2619, #2846, #2515, #3390)\n                single = true;\n                this.min -= 0.5;\n                this.max += 0.5;\n            }\n            this.single = single;\n\n            if (!tickPositionsOption && !tickPositioner) {\n                this.adjustTickAmount();\n            }\n        }\n    },\n\n    /**\n     * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max\n     */\n    trimTicks: function (tickPositions, startOnTick, endOnTick) {\n        var roundedMin = tickPositions[0],\n            roundedMax = tickPositions[tickPositions.length - 1],\n            minPointOffset = this.minPointOffset || 0;\n\n        if (startOnTick) {\n            this.min = roundedMin;\n        } else {\n            while (this.min - minPointOffset > tickPositions[0]) {\n                tickPositions.shift();\n            }\n        }\n\n        if (endOnTick) {\n            this.max = roundedMax;\n        } else {\n            while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {\n                tickPositions.pop();\n            }\n        }\n\n        // If no tick are left, set one tick in the middle (#3195)\n        if (tickPositions.length === 0 && defined(roundedMin)) {\n            tickPositions.push((roundedMax + roundedMin) / 2);\n        }\n    },\n\n    /**\n     * Check if there are multiple axes in the same pane\n     * @returns {Boolean} There are other axes\n     */\n    alignToOthers: function () {\n        var others = {}, // Whether there is another axis to pair with this one\n            hasOther,\n            options = this.options;\n\n        if (this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {\n            each(this.chart[this.coll], function (axis) {\n                var otherOptions = axis.options,\n                    horiz = axis.horiz,\n                    key = [\n                        horiz ? otherOptions.left : otherOptions.top, \n                        otherOptions.width,\n                        otherOptions.height, \n                        otherOptions.pane\n                    ].join(',');\n\n\n                if (axis.series.length) { // #4442\n                    if (others[key]) {\n                        hasOther = true; // #4201\n                    } else {\n                        others[key] = 1;\n                    }\n                }\n            });\n        }\n        return hasOther;\n    },\n\n    /**\n     * Set the max ticks of either the x and y axis collection\n     */\n    getTickAmount: function () {\n        var options = this.options,\n            tickAmount = options.tickAmount,\n            tickPixelInterval = options.tickPixelInterval;\n\n        if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&\n                !this.isLog && options.startOnTick && options.endOnTick) {\n            tickAmount = 2;\n        }\n\n        if (!tickAmount && this.alignToOthers()) {\n            // Add 1 because 4 tick intervals require 5 ticks (including first and last)\n            tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;\n        }\n\n        // For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This\n        // prevents the axis from adding ticks that are too far away from the data extremes.\n        if (tickAmount < 4) {\n            this.finalTickAmt = tickAmount;\n            tickAmount = 5;\n        }\n\n        this.tickAmount = tickAmount;\n    },\n\n    /**\n     * When using multiple axes, adjust the number of ticks to match the highest\n     * number of ticks in that group\n     */\n    adjustTickAmount: function () {\n        var tickInterval = this.tickInterval,\n            tickPositions = this.tickPositions,\n            tickAmount = this.tickAmount,\n            finalTickAmt = this.finalTickAmt,\n            currentTickAmount = tickPositions && tickPositions.length,\n            i,\n            len;\n\n        if (currentTickAmount < tickAmount) {\n            while (tickPositions.length < tickAmount) {\n                tickPositions.push(correctFloat(\n                    tickPositions[tickPositions.length - 1] + tickInterval\n                ));\n            }\n            this.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n            this.max = tickPositions[tickPositions.length - 1];\n\n        // We have too many ticks, run second pass to try to reduce ticks\n        } else if (currentTickAmount > tickAmount) {\n            this.tickInterval *= 2;\n            this.setTickPositions();\n        }\n\n        // The finalTickAmt property is set in getTickAmount\n        if (defined(finalTickAmt)) {\n            i = len = tickPositions.length;\n            while (i--) {\n                if (\n                    (finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick\n                    (finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last\n                ) {\n                    tickPositions.splice(i, 1);\n                }\n            }\n            this.finalTickAmt = undefined;\n        }\n    },\n\n    /**\n     * Set the scale based on data min and max, user set min and max or options\n     *\n     */\n    setScale: function () {\n        var axis = this,\n            isDirtyData,\n            isDirtyAxisLength;\n\n        axis.oldMin = axis.min;\n        axis.oldMax = axis.max;\n        axis.oldAxisLength = axis.len;\n\n        // set the new axisLength\n        axis.setAxisSize();\n        //axisLength = horiz ? axisWidth : axisHeight;\n        isDirtyAxisLength = axis.len !== axis.oldAxisLength;\n\n        // is there new data?\n        each(axis.series, function (series) {\n            if (series.isDirtyData || series.isDirty ||\n                    series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well\n                isDirtyData = true;\n            }\n        });\n\n        // do we really need to go through all this?\n        if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||\n            axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {\n\n            if (axis.resetStacks) {\n                axis.resetStacks();\n            }\n\n            axis.forceRedraw = false;\n\n            // get data extremes if needed\n            axis.getSeriesExtremes();\n\n            // get fixed positions based on tickInterval\n            axis.setTickInterval();\n\n            // record old values to decide whether a rescale is necessary later on (#540)\n            axis.oldUserMin = axis.userMin;\n            axis.oldUserMax = axis.userMax;\n\n            // Mark as dirty if it is not already set to dirty and extremes have changed. #595.\n            if (!axis.isDirty) {\n                axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;\n            }\n        } else if (axis.cleanStacks) {\n            axis.cleanStacks();\n        }\n    },\n\n    /**\n     * Set the extremes and optionally redraw\n     * @param {Number} newMin\n     * @param {Number} newMax\n     * @param {Boolean} redraw\n     * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n     *    configuration\n     * @param {Object} eventArguments\n     *\n     */\n    setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {\n        var axis = this,\n            chart = axis.chart;\n\n        redraw = pick(redraw, true); // defaults to true\n\n        each(axis.series, function (serie) {\n            delete serie.kdTree;\n        });\n\n        // Extend the arguments with min and max\n        eventArguments = extend(eventArguments, {\n            min: newMin,\n            max: newMax\n        });\n\n        // Fire the event\n        fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler\n\n            axis.userMin = newMin;\n            axis.userMax = newMax;\n            axis.eventArgs = eventArguments;\n\n            if (redraw) {\n                chart.redraw(animation);\n            }\n        });\n    },\n\n    /**\n     * Overridable method for zooming chart. Pulled out in a separate method to allow overriding\n     * in stock charts.\n     */\n    zoom: function (newMin, newMax) {\n        var dataMin = this.dataMin,\n            dataMax = this.dataMax,\n            options = this.options,\n            min = Math.min(dataMin, pick(options.min, dataMin)),\n            max = Math.max(dataMax, pick(options.max, dataMax));\n\n        // Prevent pinch zooming out of range. Check for defined is for #1946. #1734.\n        if (!this.allowZoomOutside) {\n            if (defined(dataMin) && newMin <= min) {\n                newMin = min;\n            }\n            if (defined(dataMax) && newMax >= max) {\n                newMax = max;\n            }\n        }\n\n        // In full view, displaying the reset zoom button is not required\n        this.displayBtn = newMin !== undefined || newMax !== undefined;\n\n        // Do it\n        this.setExtremes(\n            newMin,\n            newMax,\n            false,\n            undefined,\n            { trigger: 'zoom' }\n        );\n        return true;\n    },\n\n    /**\n     * Update the axis metrics\n     */\n    setAxisSize: function () {\n        var chart = this.chart,\n            options = this.options,\n            offsetLeft = options.offsetLeft || 0,\n            offsetRight = options.offsetRight || 0,\n            horiz = this.horiz,\n            width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),\n            height = pick(options.height, chart.plotHeight),\n            top = pick(options.top, chart.plotTop),\n            left = pick(options.left, chart.plotLeft + offsetLeft),\n            percentRegex = /%$/;\n\n        // Check for percentage based input values. Rounding fixes problems with\n        // column overflow and plot line filtering (#4898, #4899)\n        if (percentRegex.test(height)) {\n            height = Math.round(parseFloat(height) / 100 * chart.plotHeight);\n        }\n        if (percentRegex.test(top)) {\n            top = Math.round(parseFloat(top) / 100 * chart.plotHeight + chart.plotTop);\n        }\n\n        // Expose basic values to use in Series object and navigator\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n        this.bottom = chart.chartHeight - height - top;\n        this.right = chart.chartWidth - width - left;\n\n        // Direction agnostic properties\n        this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905\n        this.pos = horiz ? left : top; // distance from SVG origin\n    },\n\n    /**\n     * Get the actual axis extremes\n     */\n    getExtremes: function () {\n        var axis = this,\n            isLog = axis.isLog,\n            lin2log = axis.lin2log;\n\n        return {\n            min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,\n            max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,\n            dataMin: axis.dataMin,\n            dataMax: axis.dataMax,\n            userMin: axis.userMin,\n            userMax: axis.userMax\n        };\n    },\n\n    /**\n     * Get the zero plane either based on zero or on the min or max value.\n     * Used in bar and area plots\n     */\n    getThreshold: function (threshold) {\n        var axis = this,\n            isLog = axis.isLog,\n            lin2log = axis.lin2log,\n            realMin = isLog ? lin2log(axis.min) : axis.min,\n            realMax = isLog ? lin2log(axis.max) : axis.max;\n\n        // With a threshold of null, make the columns/areas rise from the top or bottom\n        // depending on the value, assuming an actual threshold of 0 (#4233).\n        if (threshold === null) {\n            threshold = realMax < 0 ? realMax : realMin;\n        } else if (realMin > threshold) {\n            threshold = realMin;\n        } else if (realMax < threshold) {\n            threshold = realMax;\n        }\n\n        return axis.translate(threshold, 0, 1, 0, 1);\n    },\n\n    /**\n     * Compute auto alignment for the axis label based on which side the axis is on\n     * and the given rotation for the label\n     */\n    autoLabelAlign: function (rotation) {\n        var ret,\n            angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;\n\n        if (angle > 15 && angle < 165) {\n            ret = 'right';\n        } else if (angle > 195 && angle < 345) {\n            ret = 'left';\n        } else {\n            ret = 'center';\n        }\n        return ret;\n    },\n\n    /**\n     * Get the tick length and width for the axis.\n     * @param   {String} prefix 'tick' or 'minorTick'\n     * @returns {Array}        An array of tickLength and tickWidth\n     */\n    tickSize: function (prefix) {\n        var options = this.options,\n            tickLength = options[prefix + 'Length'],\n            tickWidth = pick(options[prefix + 'Width'], prefix === 'tick' && this.isXAxis ? 1 : 0); // X axis defaults to 1\n\n        if (tickWidth && tickLength) {\n            // Negate the length\n            if (options[prefix + 'Position'] === 'inside') {\n                tickLength = -tickLength;\n            }\n            return [tickLength, tickWidth];\n        }\n            \n    },\n\n    /**\n     * Return the size of the labels\n     */\n    labelMetrics: function () {\n        return this.chart.renderer.fontMetrics(\n            this.options.labels.style.fontSize, \n            this.ticks[0] && this.ticks[0].label\n        );\n    },\n\n    /**\n     * Prevent the ticks from getting so close we can't draw the labels. On a horizontal\n     * axis, this is handled by rotating the labels, removing ticks and adding ellipsis.\n     * On a vertical axis remove ticks and add ellipsis.\n     */\n    unsquish: function () {\n        var labelOptions = this.options.labels,\n            horiz = this.horiz,\n            tickInterval = this.tickInterval,\n            newTickInterval = tickInterval,\n            slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),\n            rotation,\n            rotationOption = labelOptions.rotation,\n            labelMetrics = this.labelMetrics(),\n            step,\n            bestScore = Number.MAX_VALUE,\n            autoRotation,\n            // Return the multiple of tickInterval that is needed to avoid collision\n            getStep = function (spaceNeeded) {\n                var step = spaceNeeded / (slotSize || 1);\n                step = step > 1 ? Math.ceil(step) : 1;\n                return step * tickInterval;\n            };\n\n        if (horiz) {\n            autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971\n                defined(rotationOption) ?\n                    [rotationOption] :\n                    slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation\n            );\n\n            if (autoRotation) {\n\n                // Loop over the given autoRotation options, and determine which gives the best score. The\n                // best score is that with the lowest number of steps and a rotation closest to horizontal.\n                each(autoRotation, function (rot) {\n                    var score;\n\n                    if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891\n                    \n                        step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad * rot)));\n\n                        score = step + Math.abs(rot / 360);\n\n                        if (score < bestScore) {\n                            bestScore = score;\n                            rotation = rot;\n                            newTickInterval = step;\n                        }\n                    }\n                });\n            }\n\n        } else if (!labelOptions.step) { // #4411\n            newTickInterval = getStep(labelMetrics.h);\n        }\n\n        this.autoRotation = autoRotation;\n        this.labelRotation = pick(rotation, rotationOption);\n\n        return newTickInterval;\n    },\n\n    /**\n     * Get the general slot width for this axis. This may change between the pre-render (from Axis.getOffset) \n     * and the final tick rendering and placement (#5086).\n     */\n    getSlotWidth: function () {\n        var chart = this.chart,\n            horiz = this.horiz,\n            labelOptions = this.options.labels,\n            slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            marginLeft = chart.margin[3];\n\n        return (horiz && (labelOptions.step || 0) < 2 && !labelOptions.rotation && // #4415\n            ((this.staggerLines || 1) * chart.plotWidth) / slotCount) ||\n            (!horiz && ((marginLeft && (marginLeft - chart.spacing[3])) || chart.chartWidth * 0.33)); // #1580, #1931\n\n    },\n\n    /**\n     * Render the axis labels and determine whether ellipsis or rotation need to be applied\n     */\n    renderUnsquish: function () {\n        var chart = this.chart,\n            renderer = chart.renderer,\n            tickPositions = this.tickPositions,\n            ticks = this.ticks,\n            labelOptions = this.options.labels,\n            horiz = this.horiz,\n            slotWidth = this.getSlotWidth(),\n            innerWidth = Math.max(1, Math.round(slotWidth - 2 * (labelOptions.padding || 5))),\n            attr = {},\n            labelMetrics = this.labelMetrics(),\n            textOverflowOption = labelOptions.style.textOverflow,\n            css,\n            labelLength = 0,\n            label,\n            i,\n            pos;\n\n        // Set rotation option unless it is ___doublequote___auto___doublequote___, like in gauges\n        if (!isString(labelOptions.rotation)) {\n            attr.rotation = labelOptions.rotation || 0; // #4443\n        }\n\n        // Handle auto rotation on horizontal axis\n        if (this.autoRotation) {\n\n            // Get the longest label length\n            each(tickPositions, function (tick) {\n                tick = ticks[tick];\n                if (tick && tick.labelLength > labelLength) {\n                    labelLength = tick.labelLength;\n                }\n            });\n\n            // Apply rotation only if the label is too wide for the slot, and\n            // the label is wider than its height.\n            if (labelLength > innerWidth && labelLength > labelMetrics.h) {\n                attr.rotation = this.labelRotation;\n            } else {\n                this.labelRotation = 0;\n            }\n\n        // Handle word-wrap or ellipsis on vertical axis\n        } else if (slotWidth) {\n            // For word-wrap or ellipsis\n            css = { width: innerWidth + 'px' };\n\n            if (!textOverflowOption) {\n                css.textOverflow = 'clip';\n\n                // On vertical axis, only allow word wrap if there is room for more lines.\n                i = tickPositions.length;\n                while (!horiz && i--) {\n                    pos = tickPositions[i];\n                    label = ticks[pos].label;\n                    if (label) {\n                        // Reset ellipsis in order to get the correct bounding box (#4070)\n                        if (label.styles && label.styles.textOverflow === 'ellipsis') {\n                            label.css({ textOverflow: 'clip' });\n\n                        // Set the correct width in order to read the bounding box height (#4678, #5034)\n                        } else if (ticks[pos].labelLength > slotWidth) {\n                            label.css({ width: slotWidth + 'px' });\n                        }\n\n                        if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {\n                            label.specCss = { textOverflow: 'ellipsis' };\n                        }\n                    }\n                }\n            }\n        }\n\n\n        // Add ellipsis if the label length is significantly longer than ideal\n        if (attr.rotation) {\n            css = { \n                width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + 'px'\n            };\n            if (!textOverflowOption) {\n                css.textOverflow = 'ellipsis';\n            }\n        }\n\n        // Set the explicit or automatic label alignment\n        this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);\n        if (this.labelAlign) {\n            attr.align = this.labelAlign;\n        }\n\n        // Apply general and specific CSS\n        each(tickPositions, function (pos) {\n            var tick = ticks[pos],\n                label = tick && tick.label;\n            if (label) {\n                label.attr(attr); // This needs to go before the CSS in old IE (#4502)\n                if (css) {\n                    label.css(merge(css, label.specCss));\n                }\n                delete label.specCss;\n                tick.rotation = attr.rotation;\n            }\n        });\n\n        // Note: Why is this not part of getLabelPosition?\n        this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);\n    },\n\n    /**\n     * Return true if the axis has associated data\n     */\n    hasData: function () {\n        return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);\n    },\n\n    /**\n     * Render the tick labels to a preliminary position to get their sizes\n     */\n    getOffset: function () {\n        var axis = this,\n            chart = axis.chart,\n            renderer = chart.renderer,\n            options = axis.options,\n            tickPositions = axis.tickPositions,\n            ticks = axis.ticks,\n            horiz = axis.horiz,\n            side = axis.side,\n            invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,\n            hasData,\n            showAxis,\n            titleOffset = 0,\n            titleOffsetOption,\n            titleMargin = 0,\n            axisTitleOptions = options.title,\n            labelOptions = options.labels,\n            labelOffset = 0, // reset\n            labelOffsetPadded,\n            opposite = axis.opposite,\n            axisOffset = chart.axisOffset,\n            clipOffset = chart.clipOffset,\n            clip,\n            directionFactor = [-1, 1, 1, -1][side],\n            n,\n            className = options.className, // docs\n            textAlign,\n            axisParent = axis.axisParent, // Used in color axis\n            lineHeightCorrection,\n            tickSize = this.tickSize('tick');\n\n        // For reuse in Axis.render\n        hasData = axis.hasData();\n        axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);\n\n        // Set/reset staggerLines\n        axis.staggerLines = axis.horiz && labelOptions.staggerLines;\n\n        // Create the axisGroup and gridGroup elements on first iteration\n        if (!axis.axisGroup) {\n            axis.gridGroup = renderer.g('grid')\n                .attr({ zIndex: options.gridZIndex || 1 })\n                .addClass('highcharts-' + this.coll.toLowerCase() + '-grid ' + (className || '')) // docs: className\n                .add(axisParent);\n            axis.axisGroup = renderer.g('axis')\n                .attr({ zIndex: options.zIndex || 2 })\n                .addClass('highcharts-' + this.coll.toLowerCase() + ' ' + (className || '')) // docs: className\n                .add(axisParent);\n            axis.labelGroup = renderer.g('axis-labels')\n                .attr({ zIndex: labelOptions.zIndex || 7 })\n                .addClass('highcharts-' + axis.coll.toLowerCase() + '-labels ' + (className || ''))\n                .add(axisParent);\n        }\n\n        if (hasData || axis.isLinked) {\n\n            // Generate ticks\n            each(tickPositions, function (pos) {\n                if (!ticks[pos]) {\n                    ticks[pos] = new Tick(axis, pos);\n                } else {\n                    ticks[pos].addLabel(); // update labels depending on tick interval\n                }\n            });\n\n            axis.renderUnsquish();\n\n\n            // Left side must be align: right and right side must have align: left for labels\n            if (labelOptions.reserveSpace !== false && (side === 0 || side === 2 ||\n                    { 1: 'left', 3: 'right' }[side] === axis.labelAlign || axis.labelAlign === 'center')) {\n                each(tickPositions, function (pos) {\n\n                    // get the highest offset\n                    labelOffset = Math.max(\n                        ticks[pos].getLabelSize(),\n                        labelOffset\n                    );\n                });\n            }\n\n            if (axis.staggerLines) {\n                labelOffset *= axis.staggerLines;\n                axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);\n            }\n\n\n        } else { // doesn't have data\n            for (n in ticks) {\n                ticks[n].destroy();\n                delete ticks[n];\n            }\n        }\n\n        if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {\n            if (!axis.axisTitle) {\n                textAlign = axisTitleOptions.textAlign;\n                if (!textAlign) {\n                    textAlign = (horiz ? { \n                        low: 'left',\n                        middle: 'center',\n                        high: 'right'\n                    } : { \n                        low: opposite ? 'right' : 'left',\n                        middle: 'center',\n                        high: opposite ? 'left' : 'right'\n                    })[axisTitleOptions.align];\n                }\n                axis.axisTitle = renderer.text(\n                    axisTitleOptions.text,\n                    0,\n                    0,\n                    axisTitleOptions.useHTML\n                )\n                .attr({\n                    zIndex: 7,\n                    rotation: axisTitleOptions.rotation || 0,\n                    align: textAlign\n                })\n                .addClass('highcharts-axis-title')\n                ";
if (build.classic) { 
s += "\n                .css(axisTitleOptions.style)\n                ";
} 
s += "\n                .add(axis.axisGroup);\n                axis.axisTitle.isNew = true;\n            }\n\n            if (showAxis) {\n                titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n                titleOffsetOption = axisTitleOptions.offset;\n                titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);\n            }\n\n            // hide or show the title depending on whether showEmpty is set\n            axis.axisTitle[showAxis ? 'show' : 'hide'](true);\n        }\n\n        // Render the axis line\n        axis.renderLine();\n\n        // handle automatic or user set offset\n        axis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n\n        axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar\n        if (side === 0) {\n            lineHeightCorrection = -axis.labelMetrics().h;\n        } else if (side === 2) {\n            lineHeightCorrection = axis.tickRotCorr.y;\n        } else {\n            lineHeightCorrection = 0;\n        }\n\n        // Find the padded label offset\n        labelOffsetPadded = Math.abs(labelOffset) + titleMargin;\n        if (labelOffset) {\n            labelOffsetPadded -= lineHeightCorrection;\n            labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);\n        }\n        axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n\n        axisOffset[side] = Math.max(\n            axisOffset[side],\n            axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,\n            labelOffsetPadded, // #3027\n            hasData && tickPositions.length && tickSize ? tickSize[0] : 0 // #4866\n        );\n\n        // Decide the clipping needed to keep the graph inside the plot area and axis lines\n        clip = options.offset ? 0 : Math.floor(axis.axisLine.strokeWidth() / 2) * 2; // #4308, #4371\n        clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);\n    },\n\n    /**\n     * Get the path for the axis line\n     */\n    getLinePath: function (lineWidth) {\n        var chart = this.chart,\n            opposite = this.opposite,\n            offset = this.offset,\n            horiz = this.horiz,\n            lineLeft = this.left + (opposite ? this.width : 0) + offset,\n            lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;\n\n        if (opposite) {\n            lineWidth *= -1; // crispify the other way - #1480, #1687\n        }\n\n        return chart.renderer\n            .crispLine([\n                'M',\n                horiz ?\n                    this.left :\n                    lineLeft,\n                horiz ?\n                    lineTop :\n                    this.top,\n                'L',\n                horiz ?\n                    chart.chartWidth - this.right :\n                    lineLeft,\n                horiz ?\n                    lineTop :\n                    chart.chartHeight - this.bottom\n            ], lineWidth);\n    },\n\n    /**\n     * Render the axis line\n     * @returns {[type]} [description]\n     */\n    renderLine: function () {\n        if (!this.axisLine) {\n            this.axisLine = this.chart.renderer.path()\n                .addClass('highcharts-axis-line')\n                .add(this.axisGroup);\n\n            ";
if (build.classic) { 
s += "\n            this.axisLine.attr({\n                stroke: this.options.lineColor,\n                'stroke-width': this.options.lineWidth,\n                zIndex: 7\n            });\n            ";
} 
s += "\n        }\n    },\n\n    /**\n     * Position the title\n     */\n    getTitlePosition: function () {\n        // compute anchor points for each of the title align options\n        var horiz = this.horiz,\n            axisLeft = this.left,\n            axisTop = this.top,\n            axisLength = this.len,\n            axisTitleOptions = this.options.title,\n            margin = horiz ? axisLeft : axisTop,\n            opposite = this.opposite,\n            offset = this.offset,\n            xOption = axisTitleOptions.x || 0,\n            yOption = axisTitleOptions.y || 0,\n            fontSize = this.chart.renderer.fontMetrics(axisTitleOptions.style && axisTitleOptions.style.fontSize, this.axisTitle).f,\n\n            // the position in the length direction of the axis\n            alongAxis = {\n                low: margin + (horiz ? 0 : axisLength),\n                middle: margin + axisLength / 2,\n                high: margin + (horiz ? axisLength : 0)\n            }[axisTitleOptions.align],\n\n            // the position in the perpendicular direction of the axis\n            offAxis = (horiz ? axisTop + this.height : axisLeft) +\n                (horiz ? 1 : -1) * // horizontal axis reverses the margin\n                (opposite ? -1 : 1) * // so does opposite axes\n                this.axisTitleMargin +\n                (this.side === 2 ? fontSize : 0);\n\n        return {\n            x: horiz ?\n                alongAxis + xOption :\n                offAxis + (opposite ? this.width : 0) + offset + xOption,\n            y: horiz ?\n                offAxis + yOption - (opposite ? this.height : 0) + offset :\n                alongAxis + yOption\n        };\n    },\n\n    /**\n     * Render the axis\n     */\n    render: function () {\n        var axis = this,\n            chart = axis.chart,\n            renderer = chart.renderer,\n            options = axis.options,\n            isLog = axis.isLog,\n            lin2log = axis.lin2log,\n            isLinked = axis.isLinked,\n            tickPositions = axis.tickPositions,\n            axisTitle = axis.axisTitle,\n            ticks = axis.ticks,\n            minorTicks = axis.minorTicks,\n            alternateBands = axis.alternateBands,\n            stackLabelOptions = options.stackLabels,\n            alternateGridColor = options.alternateGridColor,\n            tickmarkOffset = axis.tickmarkOffset,\n            axisLine = axis.axisLine,\n            hasRendered = chart.hasRendered,\n            slideInTicks = hasRendered && isNumber(axis.oldMin),\n            showAxis = axis.showAxis,\n            animation = animObject(renderer.globalAnimation),\n            from,\n            to;\n\n        // Reset\n        axis.labelEdge.length = 0;\n        //axis.justifyToPlot = overflow === 'justify';\n        axis.overlap = false;\n\n        // Mark all elements inActive before we go over and mark the active ones\n        each([ticks, minorTicks, alternateBands], function (coll) {\n            var pos;\n            for (pos in coll) {\n                coll[pos].isActive = false;\n            }\n        });\n\n        // If the series has data draw the ticks. Else only the line and title\n        if (axis.hasData() || isLinked) {\n\n            // minor ticks\n            if (axis.minorTickInterval && !axis.categories) {\n                each(axis.getMinorTickPositions(), function (pos) {\n                    if (!minorTicks[pos]) {\n                        minorTicks[pos] = new Tick(axis, pos, 'minor');\n                    }\n\n                    // render new ticks in old position\n                    if (slideInTicks && minorTicks[pos].isNew) {\n                        minorTicks[pos].render(null, true);\n                    }\n\n                    minorTicks[pos].render(null, false, 1);\n                });\n            }\n\n            // Major ticks. Pull out the first item and render it last so that\n            // we can get the position of the neighbour label. #808.\n            if (tickPositions.length) { // #1300\n                each(tickPositions, function (pos, i) {\n\n                    // linked axes need an extra check to find out if\n                    if (!isLinked || (pos >= axis.min && pos <= axis.max)) {\n\n                        if (!ticks[pos]) {\n                            ticks[pos] = new Tick(axis, pos);\n                        }\n\n                        // render new ticks in old position\n                        if (slideInTicks && ticks[pos].isNew) {\n                            ticks[pos].render(i, true, 0.1);\n                        }\n\n                        ticks[pos].render(i);\n                    }\n\n                });\n                // In a categorized axis, the tick marks are displayed between labels. So\n                // we need to add a tick mark and grid line at the left edge of the X axis.\n                if (tickmarkOffset && (axis.min === 0 || axis.single)) {\n                    if (!ticks[-1]) {\n                        ticks[-1] = new Tick(axis, -1, null, true);\n                    }\n                    ticks[-1].render(-1);\n                }\n\n            }\n\n            // alternate grid color\n            if (alternateGridColor) {\n                each(tickPositions, function (pos, i) {\n                    to = tickPositions[i + 1] !== undefined ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset; \n                    if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) { // #2248, #4660\n                        if (!alternateBands[pos]) {\n                            alternateBands[pos] = new PlotLineOrBand(axis);\n                        }\n                        from = pos + tickmarkOffset; // #949\n                        alternateBands[pos].options = {\n                            from: isLog ? lin2log(from) : from,\n                            to: isLog ? lin2log(to) : to,\n                            color: alternateGridColor\n                        };\n                        alternateBands[pos].render();\n                        alternateBands[pos].isActive = true;\n                    }\n                });\n            }\n\n            // custom plot lines and bands\n            if (!axis._addedPlotLB) { // only first time\n                each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {\n                    axis.addPlotBandOrLine(plotLineOptions);\n                });\n                axis._addedPlotLB = true;\n            }\n\n        } // end if hasData\n\n        // Remove inactive ticks\n        each([ticks, minorTicks, alternateBands], function (coll) {\n            var pos,\n                i,\n                forDestruction = [],\n                delay = animation.duration,\n                destroyInactiveItems = function () {\n                    i = forDestruction.length;\n                    while (i--) {\n                        // When resizing rapidly, the same items may be destroyed in different timeouts,\n                        // or the may be reactivated\n                        if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {\n                            coll[forDestruction[i]].destroy();\n                            delete coll[forDestruction[i]];\n                        }\n                    }\n\n                };\n\n            for (pos in coll) {\n\n                if (!coll[pos].isActive) {\n                    // Render to zero opacity\n                    coll[pos].render(pos, false, 0);\n                    coll[pos].isActive = false;\n                    forDestruction.push(pos);\n                }\n            }\n\n            // When the objects are finished fading out, destroy them\n            syncTimeout(\n                destroyInactiveItems, \n                coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay\n            );\n        });\n\n        // Set the axis line path\n        if (axisLine) {\n            axisLine[axisLine.isPlaced ? 'animate' : 'attr']({\n                d: this.getLinePath(axisLine.strokeWidth())\n            });\n            axisLine.isPlaced = true;\n\n            // Show or hide the line depending on options.showEmpty\n            axisLine[showAxis ? 'show' : 'hide'](true);\n        }\n\n        if (axisTitle && showAxis) {\n\n            axisTitle[axisTitle.isNew ? 'attr' : 'animate'](\n                axis.getTitlePosition()\n            );\n            axisTitle.isNew = false;\n        }\n\n        // Stacked totals:\n        if (stackLabelOptions && stackLabelOptions.enabled) {\n            axis.renderStackTotals();\n        }\n        // End stacked totals\n\n        axis.isDirty = false;\n    },\n\n    /**\n     * Redraw the axis to reflect changes in the data or axis extremes\n     */\n    redraw: function () {\n\n        if (this.visible) {\n            // render the axis\n            this.render();\n\n            // move plot lines and bands\n            each(this.plotLinesAndBands, function (plotLine) {\n                plotLine.render();\n            });\n        }\n\n        // mark associated series as dirty and ready for redraw\n        each(this.series, function (series) {\n            series.isDirty = true;\n        });\n\n    },\n\n    /**\n     * Destroys an Axis instance.\n     */\n    destroy: function (keepEvents) {\n        var axis = this,\n            stacks = axis.stacks,\n            stackKey,\n            plotLinesAndBands = axis.plotLinesAndBands,\n            i;\n\n        // Remove the events\n        if (!keepEvents) {\n            removeEvent(axis);\n        }\n\n        // Destroy each stack total\n        for (stackKey in stacks) {\n            destroyObjectProperties(stacks[stackKey]);\n\n            stacks[stackKey] = null;\n        }\n\n        // Destroy collections\n        each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {\n            destroyObjectProperties(coll);\n        });\n        i = plotLinesAndBands.length;\n        while (i--) { // #1975\n            plotLinesAndBands[i].destroy();\n        }\n\n        // Destroy local variables\n        each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {\n            if (axis[prop]) {\n                axis[prop] = axis[prop].destroy();\n            }\n        });\n\n        // Destroy crosshair\n        if (this.cross) {\n            this.cross.destroy();\n        }\n    },\n\n    /**\n     * Draw the crosshair\n     * \n     * @param  {Object} e The event arguments from the modified pointer event\n     * @param  {Object} point The Point object\n     */\n    drawCrosshair: function (e, point) {\n\n        var path,\n            options = this.crosshair,\n            pos,\n            categorized,\n            graphic = this.cross;\n\n        if (\n            // Disabled in options\n            !this.crosshair ||\n            // Snap\n            ((defined(point) || !pick(options.snap, true)) === false)\n        ) {\n            this.hideCrosshair();\n\n        } else {\n\n            // Get the path\n            if (!pick(options.snap, true)) {\n                pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n            } else if (defined(point)) {\n                pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834\n            }\n\n            if (this.isRadial) {\n                path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189\n            } else {\n                path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189\n            }\n\n            if (path === null) {\n                this.hideCrosshair();\n                return;\n            }\n\n            categorized = this.categories && !this.isRadial;\n            \n            // Draw the cross\n            if (!graphic) {\n                this.cross = graphic = this.chart.renderer\n                    .path()\n                    .addClass('highcharts-crosshair highcharts-crosshair-' + \n                        (categorized ? 'category ' : 'thin ') + options.className) // docs: className\n                    .attr({\n                        zIndex: pick(options.zIndex, 2)\n                    })\n                    .add();\n\n                ";
if (build.classic) { 
s += "\n                // Presentational attributes\n                graphic.attr({\n                    'stroke': options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),\n                    'stroke-width': pick(options.width, 1)\n                });\n                if (options.dashStyle) {\n                    graphic.attr({\n                        dashstyle: options.dashStyle\n                    });\n                }\n                ";
} 
s += "\n                \n            }\n\n            graphic.show().attr({\n                d: path\n            });\n\n            if (categorized) {\n                graphic.attr({\n                    'stroke-width': this.transA\n                });\n            }\n        }\n\n    },\n\n    /**\n     *    Hide the crosshair.\n     */\n    hideCrosshair: function () {\n        if (this.cross) {\n            this.cross.hide();\n        }\n    }\n}; // end Axis\n\nextend(H.Axis.prototype, AxisPlotLineOrBandExtension);\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var Axis = H.Axis,\n        Date = H.Date,\n        defaultOptions = H.defaultOptions,\n        defined = H.defined,\n        each = H.each,\n        extend = H.extend,\n        getMagnitude = H.getMagnitude,\n        getTZOffset = H.getTZOffset,\n        grep = H.grep,\n        normalizeTickInterval = H.normalizeTickInterval,\n        pick = H.pick,\n        timeUnits = H.timeUnits;\n/**\n * Set the tick positions to a time unit that makes sense, for example\n * on the first of each month or on every Monday. Return an array\n * with the time positions. Used in datetime axes as well as for grouping\n * data on a datetime axis.\n *\n * @param {Object} normalizedInterval The interval in axis values (ms) and the count\n * @param {Number} min The minimum in axis values\n * @param {Number} max The maximum in axis values\n * @param {Number} startOfWeek\n */\nAxis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {\n    var tickPositions = [],\n        i,\n        higherRanks = {},\n        useUTC = defaultOptions.global.useUTC,\n        minYear, // used in months and years as a basis for Date.UTC()\n        minDate = new Date(min - getTZOffset(min)),\n        makeTime = Date.hcMakeTime,\n        interval = normalizedInterval.unitRange,\n        count = normalizedInterval.count;\n\n    if (defined(min)) { // #1300\n        minDate[Date.hcSetMilliseconds](interval >= timeUnits.second ? 0 : // #3935\n            count * Math.floor(minDate.getMilliseconds() / count)); // #3652, #3654\n\n        if (interval >= timeUnits.second) { // second\n            minDate[Date.hcSetSeconds](interval >= timeUnits.minute ? 0 : // #3935\n                count * Math.floor(minDate.getSeconds() / count));\n        }\n\n        if (interval >= timeUnits.minute) { // minute\n            minDate[Date.hcSetMinutes](interval >= timeUnits.hour ? 0 :\n                count * Math.floor(minDate[Date.hcGetMinutes]() / count));\n        }\n\n        if (interval >= timeUnits.hour) { // hour\n            minDate[Date.hcSetHours](interval >= timeUnits.day ? 0 :\n                count * Math.floor(minDate[Date.hcGetHours]() / count));\n        }\n\n        if (interval >= timeUnits.day) { // day\n            minDate[Date.hcSetDate](interval >= timeUnits.month ? 1 :\n                count * Math.floor(minDate[Date.hcGetDate]() / count));\n        }\n\n        if (interval >= timeUnits.month) { // month\n            minDate[Date.hcSetMonth](interval >= timeUnits.year ? 0 :\n                count * Math.floor(minDate[Date.hcGetMonth]() / count));\n            minYear = minDate[Date.hcGetFullYear]();\n        }\n\n        if (interval >= timeUnits.year) { // year\n            minYear -= minYear % count;\n            minDate[Date.hcSetFullYear](minYear);\n        }\n\n        // week is a special case that runs outside the hierarchy\n        if (interval === timeUnits.week) {\n            // get start of current week, independent of count\n            minDate[Date.hcSetDate](minDate[Date.hcGetDate]() - minDate[Date.hcGetDay]() +\n                pick(startOfWeek, 1));\n        }\n\n\n        // get tick positions\n        i = 1;\n        if (Date.hcTimezoneOffset || Date.hcGetTimezoneOffset) {\n            minDate = minDate.getTime();\n            minDate = new Date(minDate + getTZOffset(minDate));\n        }\n        minYear = minDate[Date.hcGetFullYear]();\n        var time = minDate.getTime(),\n            minMonth = minDate[Date.hcGetMonth](),\n            minDateDate = minDate[Date.hcGetDate](),\n            variableDayLength = !useUTC || !!Date.hcGetTimezoneOffset, // #4951\n            localTimezoneOffset = (timeUnits.day +\n                    (useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)\n                ) % timeUnits.day; // #950, #3359\n\n        // iterate and add tick positions at appropriate values\n        while (time < max) {\n            tickPositions.push(time);\n\n            // if the interval is years, use Date.UTC to increase years\n            if (interval === timeUnits.year) {\n                time = makeTime(minYear + i * count, 0);\n\n            // if the interval is months, use Date.UTC to increase months\n            } else if (interval === timeUnits.month) {\n                time = makeTime(minYear, minMonth + i * count);\n\n            // if we're using global time, the interval is not fixed as it jumps\n            // one hour at the DST crossover\n            } else if (variableDayLength && (interval === timeUnits.day || interval === timeUnits.week)) {\n                time = makeTime(minYear, minMonth, minDateDate +\n                    i * count * (interval === timeUnits.day ? 1 : 7));\n\n            // else, the interval is fixed and we use simple addition\n            } else {\n                time += interval * count;\n            }\n\n            i++;\n        }\n\n        // push the last time\n        tickPositions.push(time);\n\n\n        // mark new days if the time is dividible by day (#1649, #1760)\n        each(grep(tickPositions, function (time) {\n            return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;\n        }), function (time) {\n            higherRanks[time] = 'day';\n        });\n    }\n\n\n    // record information on the chosen unit - for dynamic label formatter\n    tickPositions.info = extend(normalizedInterval, {\n        higherRanks: higherRanks,\n        totalRange: interval * count\n    });\n\n    return tickPositions;\n};\n\n/**\n * Get a normalized tick interval for dates. Returns a configuration object with\n * unit range (interval), count and name. Used to prepare data for getTimeTicks.\n * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs\n * of segments in stock charts, the normalizing logic was extracted in order to\n * prevent it for running over again for each segment having the same interval.\n * #662, #697.\n */\nAxis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {\n    var units = unitsOption || [[\n            'millisecond', // unit name\n            [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n        ], [\n            'second',\n            [1, 2, 5, 10, 15, 30]\n        ], [\n            'minute',\n            [1, 2, 5, 10, 15, 30]\n        ], [\n            'hour',\n            [1, 2, 3, 4, 6, 8, 12]\n        ], [\n            'day',\n            [1, 2]\n        ], [\n            'week',\n            [1, 2]\n        ], [\n            'month',\n            [1, 2, 3, 4, 6]\n        ], [\n            'year',\n            null\n        ]],\n        unit = units[units.length - 1], // default unit is years\n        interval = timeUnits[unit[0]],\n        multiples = unit[1],\n        count,\n        i;\n\n    // loop through the units to find the one that best fits the tickInterval\n    for (i = 0; i < units.length; i++) {\n        unit = units[i];\n        interval = timeUnits[unit[0]];\n        multiples = unit[1];\n\n\n        if (units[i + 1]) {\n            // lessThan is in the middle between the highest multiple and the next unit.\n            var lessThan = (interval * multiples[multiples.length - 1] +\n                        timeUnits[units[i + 1][0]]) / 2;\n\n            // break and keep the current unit\n            if (tickInterval <= lessThan) {\n                break;\n            }\n        }\n    }\n\n    // prevent 2.5 years intervals, though 25, 250 etc. are allowed\n    if (interval === timeUnits.year && tickInterval < 5 * interval) {\n        multiples = [1, 2, 5];\n    }\n\n    // get the count\n    count = normalizeTickInterval(\n        tickInterval / interval,\n        multiples,\n        unit[0] === 'year' ? Math.max(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360\n    );\n\n    return {\n        unitRange: interval,\n        count: count,\n        unitName: unit[0]\n    };\n};\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var Axis = H.Axis,\n        getMagnitude = H.getMagnitude,\n        lin2log = H.lin2log,\n        log2lin = H.log2lin,\n        map = H.map,\n        normalizeTickInterval = H.normalizeTickInterval,\n        pick = H.pick;\n/**\n * Methods defined on the Axis prototype\n */\n\n/**\n * Set the tick positions of a logarithmic axis\n */\nAxis.prototype.getLogTickPositions = function (interval, min, max, minor) {\n    var axis = this,\n        options = axis.options,\n        axisLength = axis.len,\n        // Since we use this method for both major and minor ticks,\n        // use a local variable and return the result\n        positions = [];\n\n    // Reset\n    if (!minor) {\n        axis._minorAutoInterval = null;\n    }\n\n    // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.\n    if (interval >= 0.5) {\n        interval = Math.round(interval);\n        positions = axis.getLinearTickPositions(interval, min, max);\n\n    // Second case: We need intermediary ticks. For example\n    // 1, 2, 4, 6, 8, 10, 20, 40 etc.\n    } else if (interval >= 0.08) {\n        var roundedMin = Math.floor(min),\n            intermediate,\n            i,\n            j,\n            len,\n            pos,\n            lastPos,\n            break2;\n\n        if (interval > 0.3) {\n            intermediate = [1, 2, 4];\n        } else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc\n            intermediate = [1, 2, 4, 6, 8];\n        } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc\n            intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n        }\n\n        for (i = roundedMin; i < max + 1 && !break2; i++) {\n            len = intermediate.length;\n            for (j = 0; j < len && !break2; j++) {\n                pos = log2lin(lin2log(i) * intermediate[j]);\n                if (pos > min && (!minor || lastPos <= max) && lastPos !== undefined) { // #1670, lastPos is #3113\n                    positions.push(lastPos);\n                }\n\n                if (lastPos > max) {\n                    break2 = true;\n                }\n                lastPos = pos;\n            }\n        }\n\n    // Third case: We are so deep in between whole logarithmic values that\n    // we might as well handle the tick positions like a linear axis. For\n    // example 1.01, 1.02, 1.03, 1.04.\n    } else {\n        var realMin = lin2log(min),\n            realMax = lin2log(max),\n            tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],\n            filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,\n            tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),\n            totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;\n\n        interval = pick(\n            filteredTickIntervalOption,\n            axis._minorAutoInterval,\n            (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)\n        );\n\n        interval = normalizeTickInterval(\n            interval,\n            null,\n            getMagnitude(interval)\n        );\n\n        positions = map(axis.getLinearTickPositions(\n            interval,\n            realMin,\n            realMax\n        ), log2lin);\n\n        if (!minor) {\n            axis._minorAutoInterval = interval / 5;\n        }\n    }\n\n    // Set the axis-level tickInterval variable\n    if (!minor) {\n        axis.tickInterval = interval;\n    }\n    return positions;\n};\n\nAxis.prototype.log2lin = function (num) {\n    return Math.log(num) / Math.LN10;\n};\n\nAxis.prototype.lin2log = function (num) {\n    return Math.pow(10, num);\n};\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var dateFormat = H.dateFormat,\n        each = H.each,\n        extend = H.extend,\n        format = H.format,\n        isNumber = H.isNumber,\n        map = H.map,\n        merge = H.merge,\n        pick = H.pick,\n        splat = H.splat,\n        stop = H.stop,\n        syncTimeout = H.syncTimeout,\n        timeUnits = H.timeUnits,\n        useCanVG = H.useCanVG;\n/**\n * The tooltip object\n * @param {Object} chart The chart instance\n * @param {Object} options Tooltip options\n */\nH.Tooltip = function () {\n    this.init.apply(this, arguments);\n};\n\nH.Tooltip.prototype = {\n\n    init: function (chart, options) {\n\n        // Save the chart and options\n        this.chart = chart;\n        this.options = options;\n\n        // Keep track of the current series\n        //this.currentSeries = undefined;\n\n        // List of crosshairs\n        this.crosshairs = [];\n\n        // Current values of x and y when animating\n        this.now = { x: 0, y: 0 };\n\n        // The tooltip is initially hidden\n        this.isHidden = true;\n\n\n        // create the label\n        this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')\n            .attr({\n                padding: options.padding, // docs\n                r: options.borderRadius,\n                zIndex: 8\n            })\n            .add()\n            .attr({ y: -9999 });\n\n        ";
if (build.classic) { 
s += "\n        this.label\n            .attr({\n                'fill': options.backgroundColor,\n                'stroke-width': options.borderWidth\n            })\n            // #2301, #2657\n            .css(options.style)\n            \n            // When using canVG the shadow shows up as a gray circle\n            // even if the tooltip is hidden.\n            .shadow(!useCanVG && options.shadow);\n\n        \n        ";
} 
s += "\n\n        // Public property for getting the shared state.\n        this.shared = options.shared;\n    },\n\n    update: function (options) {\n        this.destroy();\n        this.init(this.chart, merge(true, this.options, options));\n    },\n\n    /**\n     * Destroy the tooltip and its elements.\n     */\n    destroy: function () {\n        // Destroy and clear local variables\n        if (this.label) {\n            this.label = this.label.destroy();\n        }\n        clearTimeout(this.hideTimer);\n        clearTimeout(this.tooltipTimeout);\n    },\n\n    /**\n     * Provide a soft movement for the tooltip\n     *\n     * @param {Number} x\n     * @param {Number} y\n     * @private\n     */\n    move: function (x, y, anchorX, anchorY) {\n        var tooltip = this,\n            now = tooltip.now,\n            animate = tooltip.options.animation !== false && !tooltip.isHidden &&\n                // When we get close to the target position, abort animation and land on the right place (#3056)\n                (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),\n            skipAnchor = tooltip.followPointer || tooltip.len > 1;\n\n        // Get intermediate values for animation\n        extend(now, {\n            x: animate ? (2 * now.x + x) / 3 : x,\n            y: animate ? (now.y + y) / 2 : y,\n            anchorX: skipAnchor ? undefined : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n            anchorY: skipAnchor ? undefined : animate ? (now.anchorY + anchorY) / 2 : anchorY\n        });\n\n        // Move to the intermediate value\n        tooltip.label.attr(now);\n\n\n        // Run on next tick of the mouse tracker\n        if (animate) {\n\n            // Never allow two timeouts\n            clearTimeout(this.tooltipTimeout);\n\n            // Set the fixed interval ticking for the smooth tooltip\n            this.tooltipTimeout = setTimeout(function () {\n                // The interval function may still be running during destroy, so check that the chart is really there before calling.\n                if (tooltip) {\n                    tooltip.move(x, y, anchorX, anchorY);\n                }\n            }, 32);\n\n        }\n    },\n\n    /**\n     * Hide the tooltip\n     */\n    hide: function (delay) {\n        var tooltip = this;\n        clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)\n        delay = pick(delay, this.options.hideDelay, 500);\n        if (!this.isHidden) {\n            this.hideTimer = syncTimeout(function () {\n                tooltip.label[delay ? 'fadeOut' : 'hide']();\n                tooltip.isHidden = true;\n            }, delay);\n        }\n    },\n\n    /**\n     * Extendable method to get the anchor position of the tooltip\n     * from a point or set of points\n     */\n    getAnchor: function (points, mouseEvent) {\n        var ret,\n            chart = this.chart,\n            inverted = chart.inverted,\n            plotTop = chart.plotTop,\n            plotLeft = chart.plotLeft,\n            plotX = 0,\n            plotY = 0,\n            yAxis,\n            xAxis;\n\n        points = splat(points);\n\n        // Pie uses a special tooltipPos\n        ret = points[0].tooltipPos;\n\n        // When tooltip follows mouse, relate the position to the mouse\n        if (this.followPointer && mouseEvent) {\n            if (mouseEvent.chartX === undefined) {\n                mouseEvent = chart.pointer.normalize(mouseEvent);\n            }\n            ret = [\n                mouseEvent.chartX - chart.plotLeft,\n                mouseEvent.chartY - plotTop\n            ];\n        }\n        // When shared, use the average position\n        if (!ret) {\n            each(points, function (point) {\n                yAxis = point.series.yAxis;\n                xAxis = point.series.xAxis;\n                plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0);\n                plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +\n                    (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151\n            });\n\n            plotX /= points.length;\n            plotY /= points.length;\n\n            ret = [\n                inverted ? chart.plotWidth - plotY : plotX,\n                this.shared && !inverted && points.length > 1 && mouseEvent ?\n                    mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)\n                    inverted ? chart.plotHeight - plotX : plotY\n            ];\n        }\n\n        return map(ret, Math.round);\n    },\n\n    /**\n     * Place the tooltip in a chart without spilling over\n     * and not covering the point it self.\n     */\n    getPosition: function (boxWidth, boxHeight, point) {\n\n        var chart = this.chart,\n            distance = this.distance,\n            ret = {},\n            h = point.h || 0, // #4117\n            swapped,\n            first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop, chart.plotTop, chart.plotTop + chart.plotHeight],\n            second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft, chart.plotLeft, chart.plotLeft + chart.plotWidth],\n            // The far side is right or bottom\n            preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === !!point.negative), // #4984\n            /**\n             * Handle the preferred dimension. When the preferred dimension is tooltip\n             * on top or bottom of the point, it will look for space there.\n             */\n            firstDimension = function (dim, outerSize, innerSize, point, min, max) {\n                var roomLeft = innerSize < point - distance,\n                    roomRight = point + distance + innerSize < outerSize,\n                    alignedLeft = point - distance - innerSize,\n                    alignedRight = point + distance;\n\n                if (preferFarSide && roomRight) {\n                    ret[dim] = alignedRight;\n                } else if (!preferFarSide && roomLeft) {\n                    ret[dim] = alignedLeft;\n                } else if (roomLeft) {\n                    ret[dim] = Math.min(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);\n                } else if (roomRight) {\n                    ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);\n                } else {\n                    return false;\n                }\n            },\n            /**\n             * Handle the secondary dimension. If the preferred dimension is tooltip\n             * on top or bottom of the point, the second dimension is to align the tooltip\n             * above the point, trying to align center but allowing left or right\n             * align within the chart box.\n             */\n            secondDimension = function (dim, outerSize, innerSize, point) {\n                var retVal;\n\n                // Too close to the edge, return false and swap dimensions\n                if (point < distance || point > outerSize - distance) {\n                    retVal = false;\n                // Align left/top\n                } else if (point < innerSize / 2) {\n                    ret[dim] = 1;\n                // Align right/bottom\n                } else if (point > outerSize - innerSize / 2) {\n                    ret[dim] = outerSize - innerSize - 2;\n                // Align center\n                } else {\n                    ret[dim] = point - innerSize / 2;\n                }\n                return retVal;\n            },\n            /**\n             * Swap the dimensions\n             */\n            swap = function (count) {\n                var temp = first;\n                first = second;\n                second = temp;\n                swapped = count;\n            },\n            run = function () {\n                if (firstDimension.apply(0, first) !== false) {\n                    if (secondDimension.apply(0, second) === false && !swapped) {\n                        swap(true);\n                        run();\n                    }\n                } else if (!swapped) {\n                    swap(true);\n                    run();\n                } else {\n                    ret.x = ret.y = 0;\n                }\n            };\n\n        // Under these conditions, prefer the tooltip on the side of the point\n        if (chart.inverted || this.len > 1) {\n            swap();\n        }\n        run();\n\n        return ret;\n\n    },\n\n    /**\n     * In case no user defined formatter is given, this will be used. Note that the context\n     * here is an object holding point, series, x, y etc.\n     */\n    defaultFormatter: function (tooltip) {\n        var items = this.points || splat(this),\n            s;\n\n        // build the header\n        s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header\n\n        // build the values\n        s = s.concat(tooltip.bodyFormatter(items));\n\n        // footer\n        s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header\n\n        return s.join('');\n    },\n\n    /**\n     * Refresh the tooltip's text and position.\n     * @param {Object} point\n     */\n    refresh: function (point, mouseEvent) {\n        var tooltip = this,\n            chart = tooltip.chart,\n            label = tooltip.label,\n            options = tooltip.options,\n            x,\n            y,\n            anchor,\n            textConfig = {},\n            text,\n            pointConfig = [],\n            formatter = options.formatter || tooltip.defaultFormatter,\n            hoverPoints = chart.hoverPoints,\n            shared = tooltip.shared,\n            currentSeries;\n\n        clearTimeout(this.hideTimer);\n\n        // get the reference point coordinates (pie charts use tooltipPos)\n        tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;\n        anchor = tooltip.getAnchor(point, mouseEvent);\n        x = anchor[0];\n        y = anchor[1];\n\n        // shared tooltip, array is sent over\n        if (shared && !(point.series && point.series.noSharedTooltip)) {\n\n            // hide previous hoverPoints and set new\n\n            chart.hoverPoints = point;\n            if (hoverPoints) {\n                each(hoverPoints, function (point) {\n                    point.setState();\n                });\n            }\n\n            each(point, function (item) {\n                item.setState('hover');\n\n                pointConfig.push(item.getLabelConfig());\n            });\n\n            textConfig = {\n                x: point[0].category,\n                y: point[0].y\n            };\n            textConfig.points = pointConfig;\n            this.len = pointConfig.length;\n            point = point[0];\n\n        // single point tooltip\n        } else {\n            textConfig = point.getLabelConfig();\n        }\n        text = formatter.call(textConfig, tooltip);\n\n        // register the current series\n        currentSeries = point.series;\n        this.distance = pick(currentSeries.tooltipOptions.distance, 16);\n\n        // update the inner HTML\n        if (text === false) {\n            this.hide();\n        } else {\n\n            // show it\n            if (tooltip.isHidden) {\n                stop(label);\n                label.attr('opacity', 1).show();\n            }\n\n            // update text\n            label.attr({\n                text: text\n            });\n\n            // Set the stroke color of the box to reflect the point\n            label.removeClass(/highcharts-color-[\\d]+/g)\n                .addClass('highcharts-color-' + pick(point.colorIndex, currentSeries.colorIndex));\n\n            ";
if (build.classic) { 
s += "\n            label.attr({\n                stroke: options.borderColor || point.color || currentSeries.color || '#606060'\n            });\n            ";
} 
s += "\n\n            tooltip.updatePosition({\n                plotX: x,\n                plotY: y,\n                negative: point.negative,\n                ttBelow: point.ttBelow,\n                h: anchor[2] || 0\n            });\n\n            this.isHidden = false;\n        }\n    },\n\n    /**\n     * Find the new position and perform the move\n     */\n    updatePosition: function (point) {\n        var chart = this.chart,\n            label = this.label,\n            pos = (this.options.positioner || this.getPosition).call(\n                this,\n                label.width,\n                label.height,\n                point\n            );\n\n        // do the move\n        this.move(\n            Math.round(pos.x), \n            Math.round(pos.y || 0), // can be undefined (#3977) \n            point.plotX + chart.plotLeft, \n            point.plotY + chart.plotTop\n        );\n    },\n\n    /**\n     * Get the best X date format based on the closest point range on the axis.\n     */\n    getXDateFormat: function (point, options, xAxis) {\n        var xDateFormat,\n            dateTimeLabelFormats = options.dateTimeLabelFormats,\n            closestPointRange = xAxis && xAxis.closestPointRange,\n            n,\n            blank = '01-01 00:00:00.000',\n            strpos = {\n                millisecond: 15,\n                second: 12,\n                minute: 9,\n                hour: 6,\n                day: 3\n            },\n            date,\n            lastN = 'millisecond'; // for sub-millisecond data, #4223\n\n        if (closestPointRange) {\n            date = dateFormat('%m-%d %H:%M:%S.%L', point.x);\n            for (n in timeUnits) {\n\n                // If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format\n                if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek &&\n                        date.substr(6) === blank.substr(6)) {\n                    n = 'week';\n                    break;\n                }\n\n                // The first format that is too great for the range\n                if (timeUnits[n] > closestPointRange) {\n                    n = lastN;\n                    break;\n                }\n\n                // If the point is placed every day at 23:59, we need to show\n                // the minutes as well. #2637.\n                if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {\n                    break;\n                }\n\n                // Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition\n                if (n !== 'week') {\n                    lastN = n;\n                }\n            }\n\n            if (n) {\n                xDateFormat = dateTimeLabelFormats[n];\n            }\n        } else {\n            xDateFormat = dateTimeLabelFormats.day;\n        }\n\n        return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581\n    },\n\n    /**\n     * Format the footer/header of the tooltip\n     * #3397: abstraction to enable formatting of footer and header\n     */\n    tooltipFooterHeaderFormatter: function (point, isFooter) {\n        var footOrHead = isFooter ? 'footer' : 'header',\n            series = point.series,\n            tooltipOptions = series.tooltipOptions,\n            xDateFormat = tooltipOptions.xDateFormat,\n            xAxis = series.xAxis,\n            isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),\n            formatString = tooltipOptions[footOrHead + 'Format'];\n\n        // Guess the best date format based on the closest point distance (#568, #3418)\n        if (isDateTime && !xDateFormat) {\n            xDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);\n        }\n\n        // Insert the footer date format if any\n        if (isDateTime && xDateFormat) {\n            formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');\n        }\n\n        return format(formatString, {\n            point: point,\n            series: series\n        });\n    },\n\n    /**\n     * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,\n     * abstracting this functionality allows to easily overwrite and extend it.\n     */\n    bodyFormatter: function (items) {\n        return map(items, function (item) {\n            var tooltipOptions = item.series.tooltipOptions;\n            return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);\n        });\n    }\n\n};\n\n    return H;\n}(Highcharts));\n(function (H) {\nvar addEvent = H.addEvent,\n    attr = H.attr,\n    charts = H.charts,\n    css = H.css,\n    defined = H.defined,\n    doc = H.doc,\n    each = H.each,\n    extend = H.extend,\n    fireEvent = H.fireEvent,\n    isNumber = H.isNumber,\n    offset = H.offset,\n    pick = H.pick,\n    removeEvent = H.removeEvent,\n    splat = H.splat,\n    Tooltip = H.Tooltip,\n    useCanVG = H.useCanVg,\n    win = H.win;\n\n// Global flag for touch support\nH.hasTouch = doc && doc.documentElement.ontouchstart !== undefined;\n\n/**\n * The mouse tracker object. All methods starting with ___doublequote___on___doublequote___ are primary DOM event handlers.\n * Subsequent methods should be named differently from what they are doing.\n * @param {Object} chart The Chart instance\n * @param {Object} options The root options object\n */\nH.Pointer = function (chart, options) {\n    this.init(chart, options);\n};\n\nH.Pointer.prototype = {\n    /**\n     * Initialize Pointer\n     */\n    init: function (chart, options) {\n\n        var chartOptions = options.chart,\n            chartEvents = chartOptions.events,\n            zoomType = useCanVG ? '' : chartOptions.zoomType,\n            inverted = chart.inverted,\n            zoomX,\n            zoomY;\n\n        // Store references\n        this.options = options;\n        this.chart = chart;\n\n        // Zoom status\n        this.zoomX = zoomX = /x/.test(zoomType);\n        this.zoomY = zoomY = /y/.test(zoomType);\n        this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);\n        this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);\n        this.hasZoom = zoomX || zoomY;\n\n        // Do we need to handle click on a touch device?\n        this.runChartClick = chartEvents && !!chartEvents.click;\n\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n\n        if (Tooltip && options.tooltip.enabled) {\n            chart.tooltip = new Tooltip(chart, options.tooltip);\n            this.followTouchMove = pick(options.tooltip.followTouchMove, true);\n        }\n\n        this.setDOMEvents();\n    },\n\n    /**\n     * Add crossbrowser support for chartX and chartY\n     * @param {Object} e The event object in standard browsers\n     */\n    normalize: function (e, chartPosition) {\n        var chartX,\n            chartY,\n            ePos;\n\n        // IE normalizing\n        e = e || win.event;\n        if (!e.target) {\n            e.target = e.srcElement;\n        }\n\n        // iOS (#2757)\n        ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;\n\n        // Get mouse position\n        if (!chartPosition) {\n            this.chartPosition = chartPosition = offset(this.chart.container);\n        }\n\n        // chartX and chartY\n        if (ePos.pageX === undefined) { // IE < 9. #886.\n            chartX = Math.max(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is \n                // for IE10 quirks mode within framesets\n            chartY = e.y;\n        } else {\n            chartX = ePos.pageX - chartPosition.left;\n            chartY = ePos.pageY - chartPosition.top;\n        }\n\n        return extend(e, {\n            chartX: Math.round(chartX),\n            chartY: Math.round(chartY)\n        });\n    },\n\n    /**\n     * Get the click position in terms of axis values.\n     *\n     * @param {Object} e A pointer event\n     */\n    getCoordinates: function (e) {\n        var coordinates = {\n            xAxis: [],\n            yAxis: []\n        };\n\n        each(this.chart.axes, function (axis) {\n            coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n                axis: axis,\n                value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n            });\n        });\n        return coordinates;\n    },\n\n    /**\n     * With line type charts with a single tracker, get the point closest to the mouse.\n     * Run Point.onMouseOver and display tooltip for the point or points.\n     */\n    runPointActions: function (e) {\n\n        var pointer = this,\n            chart = pointer.chart,\n            series = chart.series,\n            tooltip = chart.tooltip,\n            shared = tooltip ? tooltip.shared : false,\n            followPointer,\n            hoverPoint = chart.hoverPoint,\n            hoverSeries = chart.hoverSeries,\n            i,\n            distance = [Number.MAX_VALUE, Number.MAX_VALUE], // #4511\n            anchor,\n            noSharedTooltip,\n            stickToHoverSeries,\n            directTouch,\n            kdpoints = [],\n            kdpoint = [],\n            kdpointT;\n\n        // For hovering over the empty parts of the plot area (hoverSeries is undefined).\n        // If there is one series with point tracking (combo chart), don't go to nearest neighbour.\n        if (!shared && !hoverSeries) {\n            for (i = 0; i < series.length; i++) {\n                if (series[i].directTouch || !series[i].options.stickyTracking) {\n                    series = [];\n                }\n            }\n        }\n\n        // If it has a hoverPoint and that series requires direct touch (like columns, #3899), or we're on\n        // a noSharedTooltip series among shared tooltip series (#4546), use the hoverPoint . Otherwise,\n        // search the k-d tree.\n        stickToHoverSeries = hoverSeries && (shared ? hoverSeries.noSharedTooltip : hoverSeries.directTouch);\n        if (stickToHoverSeries && hoverPoint) {\n            kdpoint = [hoverPoint];\n\n        // Handle shared tooltip or cases where a series is not yet hovered\n        } else {\n            // Find nearest points on all series\n            each(series, function (s) {\n                // Skip hidden series\n                noSharedTooltip = s.noSharedTooltip && shared;\n                directTouch = !shared && s.directTouch;\n                if (s.visible && !noSharedTooltip && !directTouch && pick(s.options.enableMouseTracking, true)) { // #3821\n                    kdpointT = s.searchPoint(e, !noSharedTooltip && s.kdDimensions === 1); // #3828\n                    if (kdpointT && kdpointT.series) { // Point.series becomes null when reset and before redraw (#5197)\n                        kdpoints.push(kdpointT);\n                    }\n                }\n            });\n            // Find absolute nearest point\n            each(kdpoints, function (p) {\n                if (p) {\n                    // Store both closest points, using point.dist and point.distX comparisons (#4645):\n                    each(['dist', 'distX'], function (dist, k) {\n                        if (isNumber(p[dist])) {\n                            var\n                                // It is closer than the reference point\n                                isCloser = p[dist] < distance[k],\n                                // It is equally close, but above the reference point (#4679)\n                                isAbove = p[dist] === distance[k] && p.series.group.zIndex >= kdpoint[k].series.group.zIndex;\n\n                            if (isCloser || isAbove) {\n                                distance[k] = p[dist];\n                                kdpoint[k] = p;\n                            }\n                        }\n                    });\n                }\n            });\n        }\n\n        // Remove points with different x-positions, required for shared tooltip and crosshairs (#4645):\n        if (shared) {\n            i = kdpoints.length;\n            while (i--) {\n                if (kdpoints[i].clientX !== kdpoint[1].clientX || kdpoints[i].series.noSharedTooltip) {\n                    kdpoints.splice(i, 1);\n                }\n            }\n        }\n\n        // Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926, #4200\n        if (kdpoint[0] && (kdpoint[0] !== this.prevKDPoint || (tooltip && tooltip.isHidden))) {\n            // Draw tooltip if necessary\n            if (shared && !kdpoint[0].series.noSharedTooltip) {\n                if (kdpoints.length && tooltip) {\n                    tooltip.refresh(kdpoints, e);\n                }\n\n                // Do mouseover on all points (#3919, #3985, #4410)\n                each(kdpoints, function (point) {\n                    point.onMouseOver(e, point !== ((hoverSeries && hoverSeries.directTouch && hoverPoint) || kdpoint[0]));\n                });\n                this.prevKDPoint = kdpoint[1];\n            } else {\n                if (tooltip) {\n                    tooltip.refresh(kdpoint[0], e);\n                }\n                if (!hoverSeries || !hoverSeries.directTouch) { // #4448\n                    kdpoint[0].onMouseOver(e);\n                }\n                this.prevKDPoint = kdpoint[0];\n            }\n\n        // Update positions (regardless of kdpoint or hoverPoint)\n        } else {\n            followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;\n            if (tooltip && followPointer && !tooltip.isHidden) {\n                anchor = tooltip.getAnchor([{}], e);\n                tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });\n            }\n        }\n\n        // Start the event listener to pick up the tooltip and crosshairs\n        if (!pointer._onDocumentMouseMove) {\n            pointer._onDocumentMouseMove = function (e) {\n                if (charts[H.hoverChartIndex]) {\n                    charts[H.hoverChartIndex].pointer.onDocumentMouseMove(e);\n                }\n            };\n            addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n        }\n\n        // Crosshair. For each hover point, loop over axes and draw cross if that point\n        // belongs to the axis (#4927).\n        each(shared ? kdpoints : [pick(hoverPoint, kdpoint[1])], function (point) { // #5269\n            each(chart.axes, function (axis) {\n                // In case of snap = false, point is undefined, and we draw the crosshair anyway (#5066)\n                if (!point || point.series[axis.coll] === axis) {\n                    axis.drawCrosshair(e, point);\n                }\n            });\n        });\n    },\n\n    /**\n     * Reset the tracking by hiding the tooltip, the hover series state and the hover point\n     *\n     * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible\n     */\n    reset: function (allowMove, delay) {\n        var pointer = this,\n            chart = pointer.chart,\n            hoverSeries = chart.hoverSeries,\n            hoverPoint = chart.hoverPoint,\n            hoverPoints = chart.hoverPoints,\n            tooltip = chart.tooltip,\n            tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;\n\n        // Check if the points have moved outside the plot area (#1003, #4736, #5101)\n        if (allowMove && tooltipPoints) {\n            each(splat(tooltipPoints), function (point) {\n                if (point.series.isCartesian && point.plotX === undefined) {\n                    allowMove = false;\n                }\n            });\n        }\n        \n        // Just move the tooltip, #349\n        if (allowMove) {\n            if (tooltip && tooltipPoints) {\n                tooltip.refresh(tooltipPoints);\n                if (hoverPoint) { // #2500\n                    hoverPoint.setState(hoverPoint.state, true);\n                    each(chart.axes, function (axis) {\n                        if (pick(axis.crosshair && axis.crosshair.snap, true)) {\n                            axis.drawCrosshair(null, hoverPoint);\n                        }  else {\n                            axis.hideCrosshair();\n                        }\n                    });\n\n                }\n            }\n\n        // Full reset\n        } else {\n\n            if (hoverPoint) {\n                hoverPoint.onMouseOut();\n            }\n\n            if (hoverPoints) {\n                each(hoverPoints, function (point) {\n                    point.setState();\n                });\n            }\n\n            if (hoverSeries) {\n                hoverSeries.onMouseOut();\n            }\n\n            if (tooltip) {\n                tooltip.hide(delay);\n            }\n\n            if (pointer._onDocumentMouseMove) {\n                removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n                pointer._onDocumentMouseMove = null;\n            }\n\n            // Remove crosshairs\n            each(chart.axes, function (axis) {\n                axis.hideCrosshair();\n            });\n\n            pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;\n\n        }\n    },\n\n    /**\n     * Scale series groups to a certain scale and translation\n     */\n    scaleGroups: function (attribs, clip) {\n\n        var chart = this.chart,\n            seriesAttribs;\n\n        // Scale each series\n        each(chart.series, function (series) {\n            seriesAttribs = attribs || series.getPlotBox(); // #1701\n            if (series.xAxis && series.xAxis.zoomEnabled) {\n                series.group.attr(seriesAttribs);\n                if (series.markerGroup) {\n                    series.markerGroup.attr(seriesAttribs);\n                    series.markerGroup.clip(clip ? chart.clipRect : null);\n                }\n                if (series.dataLabelsGroup) {\n                    series.dataLabelsGroup.attr(seriesAttribs);\n                }\n            }\n        });\n\n        // Clip\n        chart.clipRect.attr(clip || chart.clipBox);\n    },\n\n    /**\n     * Start a drag operation\n     */\n    dragStart: function (e) {\n        var chart = this.chart;\n\n        // Record the start position\n        chart.mouseIsDown = e.type;\n        chart.cancelClick = false;\n        chart.mouseDownX = this.mouseDownX = e.chartX;\n        chart.mouseDownY = this.mouseDownY = e.chartY;\n    },\n\n    /**\n     * Perform a drag operation in response to a mousemove event while the mouse is down\n     */\n    drag: function (e) {\n\n        var chart = this.chart,\n            chartOptions = chart.options.chart,\n            chartX = e.chartX,\n            chartY = e.chartY,\n            zoomHor = this.zoomHor,\n            zoomVert = this.zoomVert,\n            plotLeft = chart.plotLeft,\n            plotTop = chart.plotTop,\n            plotWidth = chart.plotWidth,\n            plotHeight = chart.plotHeight,\n            clickedInside,\n            size,\n            selectionMarker = this.selectionMarker,\n            mouseDownX = this.mouseDownX,\n            mouseDownY = this.mouseDownY,\n            panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];\n\n        // If the device supports both touch and mouse (like IE11), and we are touch-dragging\n        // inside the plot area, don't handle the mouse event. #4339.\n        if (selectionMarker && selectionMarker.touch) {\n            return;\n        }\n\n        // If the mouse is outside the plot area, adjust to cooordinates\n        // inside to prevent the selection marker from going outside\n        if (chartX < plotLeft) {\n            chartX = plotLeft;\n        } else if (chartX > plotLeft + plotWidth) {\n            chartX = plotLeft + plotWidth;\n        }\n\n        if (chartY < plotTop) {\n            chartY = plotTop;\n        } else if (chartY > plotTop + plotHeight) {\n            chartY = plotTop + plotHeight;\n        }\n\n        // determine if the mouse has moved more than 10px\n        this.hasDragged = Math.sqrt(\n            Math.pow(mouseDownX - chartX, 2) +\n            Math.pow(mouseDownY - chartY, 2)\n        );\n\n        if (this.hasDragged > 10) {\n            clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);\n\n            // make a selection\n            if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {\n                if (!selectionMarker) {\n                    this.selectionMarker = selectionMarker = chart.renderer.rect(\n                        plotLeft,\n                        plotTop,\n                        zoomHor ? 1 : plotWidth,\n                        zoomVert ? 1 : plotHeight,\n                        0\n                    )\n                    .attr({\n                        ";
if (build.classic) { 
s += "\n                        fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',\n                        ";
} 
s += "\n                        'class': 'highcharts-selection-marker',                        \n                        'zIndex': 7\n                    })\n                    .add();\n                }\n            }\n\n            // adjust the width of the selection marker\n            if (selectionMarker && zoomHor) {\n                size = chartX - mouseDownX;\n                selectionMarker.attr({\n                    width: Math.abs(size),\n                    x: (size > 0 ? 0 : size) + mouseDownX\n                });\n            }\n            // adjust the height of the selection marker\n            if (selectionMarker && zoomVert) {\n                size = chartY - mouseDownY;\n                selectionMarker.attr({\n                    height: Math.abs(size),\n                    y: (size > 0 ? 0 : size) + mouseDownY\n                });\n            }\n\n            // panning\n            if (clickedInside && !selectionMarker && chartOptions.panning) {\n                chart.pan(e, chartOptions.panning);\n            }\n        }\n    },\n\n    /**\n     * On mouse up or touch end across the entire document, drop the selection.\n     */\n    drop: function (e) {\n        var pointer = this,\n            chart = this.chart,\n            hasPinched = this.hasPinched;\n\n        if (this.selectionMarker) {\n            var selectionData = {\n                    originalEvent: e, // #4890\n                    xAxis: [],\n                    yAxis: []\n                },\n                selectionBox = this.selectionMarker,\n                selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,\n                selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,\n                selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,\n                selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,\n                runZoom;\n\n            // a selection has been made\n            if (this.hasDragged || hasPinched) {\n\n                // record each axis' min and max\n                each(chart.axes, function (axis) {\n                    if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569\n                        var horiz = axis.horiz,\n                            minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0, // #1207, #3075\n                            selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),\n                            selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);\n\n                        selectionData[axis.coll].push({\n                            axis: axis,\n                            min: Math.min(selectionMin, selectionMax), // for reversed axes\n                            max: Math.max(selectionMin, selectionMax)\n                        });\n                        runZoom = true;\n                    }\n                });\n                if (runZoom) {\n                    fireEvent(chart, 'selection', selectionData, function (args) { \n                        chart.zoom(extend(args, hasPinched ? { animation: false } : null)); \n                    });\n                }\n\n            }\n            this.selectionMarker = this.selectionMarker.destroy();\n\n            // Reset scaling preview\n            if (hasPinched) {\n                this.scaleGroups();\n            }\n        }\n\n        // Reset all\n        if (chart) { // it may be destroyed on mouse up - #877\n            css(chart.container, { cursor: chart._cursor });\n            chart.cancelClick = this.hasDragged > 10; // #370\n            chart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n            this.pinchDown = [];\n        }\n    },\n\n    onContainerMouseDown: function (e) {\n\n        e = this.normalize(e);\n\n        // issue #295, dragging not always working in Firefox\n        if (e.preventDefault) {\n            e.preventDefault();\n        }\n\n        this.dragStart(e);\n    },\n\n\n\n    onDocumentMouseUp: function (e) {\n        if (charts[H.hoverChartIndex]) {\n            charts[H.hoverChartIndex].pointer.drop(e);\n        }\n    },\n\n    /**\n     * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.\n     * Issue #149 workaround. The mouseleave event does not always fire.\n     */\n    onDocumentMouseMove: function (e) {\n        var chart = this.chart,\n            chartPosition = this.chartPosition;\n\n        e = this.normalize(e, chartPosition);\n\n        // If we're outside, hide the tooltip\n        if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&\n                !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n            this.reset();\n        }\n    },\n\n    /**\n     * When mouse leaves the container, hide the tooltip.\n     */\n    onContainerMouseLeave: function (e) {\n        var chart = charts[H.hoverChartIndex];\n        if (chart && (e.relatedTarget || e.toElement)) { // #4886, MS Touch end fires mouseleave but with no related target\n            chart.pointer.reset();\n            chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix\n        }\n    },\n\n    // The mousemove, touchmove and touchstart event handler\n    onContainerMouseMove: function (e) {\n\n        var chart = this.chart;\n\n        if (!defined(H.hoverChartIndex) || !charts[H.hoverChartIndex].mouseIsDown) {\n            H.hoverChartIndex = chart.index;\n        }\n\n        e = this.normalize(e);\n        e.returnValue = false; // #2251, #3224\n\n        if (chart.mouseIsDown === 'mousedown') {\n            this.drag(e);\n        }\n\n        // Show the tooltip and run mouse over events (#977)\n        if ((this.inClass(e.target, 'highcharts-tracker') ||\n                chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {\n            this.runPointActions(e);\n        }\n    },\n\n    /**\n     * Utility to detect whether an element has, or has a parent with, a specific\n     * class name. Used on detection of tracker objects and on deciding whether\n     * hovering the tooltip should cause the active series to mouse out.\n     */\n    inClass: function (element, className) {\n        var elemClassName;\n        while (element) {\n            elemClassName = attr(element, 'class');\n            if (elemClassName) {\n                if (elemClassName.indexOf(className) !== -1) {\n                    return true;\n                }\n                if (elemClassName.indexOf('highcharts-container') !== -1) {\n                    return false;\n                }\n            }\n            element = element.parentNode;\n        }\n    },\n\n    onTrackerMouseOut: function (e) {\n        var series = this.chart.hoverSeries,\n            relatedTarget = e.relatedTarget || e.toElement;\n        \n        if (series && relatedTarget && !series.options.stickyTracking && \n                !this.inClass(relatedTarget, 'highcharts-tooltip') &&\n                !this.inClass(relatedTarget, 'highcharts-series-' + series.index)) { // #2499, #4465\n            series.onMouseOut();\n        }\n    },\n\n    onContainerClick: function (e) {\n        var chart = this.chart,\n            hoverPoint = chart.hoverPoint, \n            plotLeft = chart.plotLeft,\n            plotTop = chart.plotTop;\n\n        e = this.normalize(e);\n\n        if (!chart.cancelClick) {\n\n            // On tracker click, fire the series and point events. #783, #1583\n            if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {\n\n                // the series click event\n                fireEvent(hoverPoint.series, 'click', extend(e, {\n                    point: hoverPoint\n                }));\n\n                // the point click event\n                if (chart.hoverPoint) { // it may be destroyed (#1844)\n                    hoverPoint.firePointEvent('click', e);\n                }\n\n            // When clicking outside a tracker, fire a chart event\n            } else {\n                extend(e, this.getCoordinates(e));\n\n                // fire a click event in the chart\n                if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {\n                    fireEvent(chart, 'click', e);\n                }\n            }\n\n\n        }\n    },\n\n    /**\n     * Set the JS DOM events on the container and document. This method should contain\n     * a one-to-one assignment between methods and their handlers. Any advanced logic should\n     * be moved to the handler reflecting the event's name.\n     */\n    setDOMEvents: function () {\n\n        var pointer = this,\n            container = pointer.chart.container;\n\n        container.onmousedown = function (e) {\n            pointer.onContainerMouseDown(e);\n        };\n        container.onmousemove = function (e) {\n            pointer.onContainerMouseMove(e);\n        };\n        container.onclick = function (e) {\n            pointer.onContainerClick(e);\n        };\n        addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);\n        if (H.chartCount === 1) {\n            addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);\n        }\n        if (H.hasTouch) {\n            container.ontouchstart = function (e) {\n                pointer.onContainerTouchStart(e);\n            };\n            container.ontouchmove = function (e) {\n                pointer.onContainerTouchMove(e);\n            };\n            if (H.chartCount === 1) {\n                addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);\n            }\n        }\n\n    },\n\n    /**\n     * Destroys the Pointer object and disconnects DOM events.\n     */\n    destroy: function () {\n        var prop;\n\n        removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);\n        if (!H.chartCount) {\n            removeEvent(doc, 'mouseup', this.onDocumentMouseUp);\n            removeEvent(doc, 'touchend', this.onDocumentTouchEnd);\n        }\n\n        // memory and CPU leak\n        clearInterval(this.tooltipTimeout);\n\n        for (prop in this) {\n            this[prop] = null;\n        }\n    }\n};\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var charts = H.charts,\n        each = H.each,\n        extend = H.extend,\n        map = H.map,\n        noop = H.noop,\n        pick = H.pick,\n        Pointer = H.Pointer;\n\n/* Support for touch devices */\nextend(Pointer.prototype, {\n\n    /**\n     * Run translation operations\n     */\n    pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n        if (this.zoomHor || this.pinchHor) {\n            this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n        }\n        if (this.zoomVert || this.pinchVert) {\n            this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n        }\n    },\n\n    /**\n     * Run translation operations for each direction (horizontal and vertical) independently\n     */\n    pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {\n        var chart = this.chart,\n            xy = horiz ? 'x' : 'y',\n            XY = horiz ? 'X' : 'Y',\n            sChartXY = 'chart' + XY,\n            wh = horiz ? 'width' : 'height',\n            plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],\n            selectionWH,\n            selectionXY,\n            clipXY,\n            scale = forcedScale || 1,\n            inverted = chart.inverted,\n            bounds = chart.bounds[horiz ? 'h' : 'v'],\n            singleTouch = pinchDown.length === 1,\n            touch0Start = pinchDown[0][sChartXY],\n            touch0Now = touches[0][sChartXY],\n            touch1Start = !singleTouch && pinchDown[1][sChartXY],\n            touch1Now = !singleTouch && touches[1][sChartXY],\n            outOfBounds,\n            transformScale,\n            scaleKey,\n            setScale = function () {\n                if (!singleTouch && Math.abs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis\n                    scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start); \n                }\n\n                clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;\n                selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;\n            };\n\n        // Set the scale, first pass\n        setScale();\n\n        selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not\n\n        // Out of bounds\n        if (selectionXY < bounds.min) {\n            selectionXY = bounds.min;\n            outOfBounds = true;\n        } else if (selectionXY + selectionWH > bounds.max) {\n            selectionXY = bounds.max - selectionWH;\n            outOfBounds = true;\n        }\n\n        // Is the chart dragged off its bounds, determined by dataMin and dataMax?\n        if (outOfBounds) {\n\n            // Modify the touchNow position in order to create an elastic drag movement. This indicates\n            // to the user that the chart is responsive but can't be dragged further.\n            touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);\n            if (!singleTouch) {\n                touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);\n            }\n\n            // Set the scale, second pass to adapt to the modified touchNow positions\n            setScale();\n\n        } else {\n            lastValidTouch[xy] = [touch0Now, touch1Now];\n        }\n\n        // Set geometry for clipping, selection and transformation\n        if (!inverted) {\n            clip[xy] = clipXY - plotLeftTop;\n            clip[wh] = selectionWH;\n        }\n        scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;\n        transformScale = inverted ? 1 / scale : scale;\n\n        selectionMarker[wh] = selectionWH;\n        selectionMarker[xy] = selectionXY;\n        transform[scaleKey] = scale;\n        transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));\n    },\n\n    /**\n     * Handle touch events with two touches\n     */\n    pinch: function (e) {\n\n        var self = this,\n            chart = self.chart,\n            pinchDown = self.pinchDown,\n            touches = e.touches,\n            touchesLength = touches.length,\n            lastValidTouch = self.lastValidTouch,\n            hasZoom = self.hasZoom,\n            selectionMarker = self.selectionMarker,\n            transform = {},\n            fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, 'highcharts-tracker') && \n                chart.runTrackerClick) || self.runChartClick),\n            clip = {};\n\n        // Don't initiate panning until the user has pinched. This prevents us from\n        // blocking page scrolling as users scroll down a long page (#4210).\n        if (touchesLength > 1) {\n            self.initiated = true;\n        }\n\n        // On touch devices, only proceed to trigger click if a handler is defined\n        if (hasZoom && self.initiated && !fireClickEvent) {\n            e.preventDefault();\n        }\n\n        // Normalize each touch\n        map(touches, function (e) {\n            return self.normalize(e);\n        });\n\n        // Register the touch start position\n        if (e.type === 'touchstart') {\n            each(touches, function (e, i) {\n                pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };\n            });\n            lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];\n            lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];\n\n            // Identify the data bounds in pixels\n            each(chart.axes, function (axis) {\n                if (axis.zoomEnabled) {\n                    var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],\n                        minPixelPadding = axis.minPixelPadding,\n                        min = axis.toPixels(pick(axis.options.min, axis.dataMin)),\n                        max = axis.toPixels(pick(axis.options.max, axis.dataMax)),\n                        absMin = Math.min(min, max),\n                        absMax = Math.max(min, max);\n\n                    // Store the bounds for use in the touchmove handler\n                    bounds.min = Math.min(axis.pos, absMin - minPixelPadding);\n                    bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);\n                }\n            });\n            self.res = true; // reset on next move\n\n        // Event type is touchmove, handle panning and pinching\n        } else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first\n\n\n            // Set the marker\n            if (!selectionMarker) {\n                self.selectionMarker = selectionMarker = extend({\n                    destroy: noop,\n                    touch: true\n                }, chart.plotBox);\n            }\n\n            self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\n            self.hasPinched = hasZoom;\n\n            // Scale and translate the groups to provide visual feedback during pinching\n            self.scaleGroups(transform, clip);\n\n            // Optionally move the tooltip on touchmove\n            if (!hasZoom && self.followTouchMove && touchesLength === 1) {\n                this.runPointActions(self.normalize(e));\n            } else if (self.res) {\n                self.res = false;\n                this.reset(false, 0);\n            }\n        }\n    },\n\n    /**\n     * General touch handler shared by touchstart and touchmove.\n     */\n    touch: function (e, start) {\n        var chart = this.chart,\n            hasMoved,\n            pinchDown;\n\n        H.hoverChartIndex = chart.index;\n\n        if (e.touches.length === 1) {\n\n            e = this.normalize(e);\n\n            if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {\n\n                // Run mouse events and display tooltip etc\n                if (start) {\n                    this.runPointActions(e);\n                }\n\n                // Android fires touchmove events after the touchstart even if the\n                // finger hasn't moved, or moved only a pixel or two. In iOS however,\n                // the touchmove doesn't fire unless the finger moves more than ~4px.\n                // So we emulate this behaviour in Android by checking how much it\n                // moved, and cancelling on small distances. #3450.\n                if (e.type === 'touchmove') {\n                    pinchDown = this.pinchDown;\n                    hasMoved = pinchDown[0] ? Math.sqrt( // #5266\n                        Math.pow(pinchDown[0].chartX - e.chartX, 2) +\n                        Math.pow(pinchDown[0].chartY - e.chartY, 2)\n                    ) >= 4 : false;\n                }\n\n                if (pick(hasMoved, true)) {\n                    this.pinch(e);\n                }\n\n            } else if (start) {\n                // Hide the tooltip on touching outside the plot area (#1203)\n                this.reset();\n            }\n\n        } else if (e.touches.length === 2) {\n            this.pinch(e);\n        }\n    },\n\n    onContainerTouchStart: function (e) {\n        this.touch(e, true);\n    },\n\n    onContainerTouchMove: function (e) {\n        this.touch(e);\n    },\n\n    onDocumentTouchEnd: function (e) {\n        if (charts[H.hoverChartIndex]) {\n            charts[H.hoverChartIndex].pointer.drop(e);\n        }\n    }\n\n});\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var addEvent = H.addEvent,\n        charts = H.charts,\n        css = H.css,\n        doc = H.doc,\n        extend = H.extend,\n        noop = H.noop,\n        Pointer = H.Pointer,\n        removeEvent = H.removeEvent,\n        win = H.win,\n        wrap = H.wrap;\n\nif (win.PointerEvent || win.MSPointerEvent) {\n    \n    // The touches object keeps track of the points being touched at all times\n    var touches = {},\n        hasPointerEvent = !!win.PointerEvent,\n        getWebkitTouches = function () {\n            var key,\n                fake = [];\n            fake.item = function (i) {\n                return this[i];\n            };\n            for (key in touches) {\n                if (touches.hasOwnProperty(key)) {\n                    fake.push({\n                        pageX: touches[key].pageX,\n                        pageY: touches[key].pageY,\n                        target: touches[key].target\n                    });\n                }\n            }\n            return fake;\n        },\n        translateMSPointer = function (e, method, wktype, func) {\n            var p;\n            if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[H.hoverChartIndex]) {\n                func(e);\n                p = charts[H.hoverChartIndex].pointer;\n                p[method]({\n                    type: wktype,\n                    target: e.currentTarget,\n                    preventDefault: noop,\n                    touches: getWebkitTouches()\n                });\n            }\n        };\n\n    /**\n     * Extend the Pointer prototype with methods for each event handler and more\n     */\n    extend(Pointer.prototype, {\n        onContainerPointerDown: function (e) {\n            translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {\n                touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };\n            });\n        },\n        onContainerPointerMove: function (e) {\n            translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {\n                touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };\n                if (!touches[e.pointerId].target) {\n                    touches[e.pointerId].target = e.currentTarget;\n                }\n            });\n        },\n        onDocumentPointerUp: function (e) {\n            translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function (e) {\n                delete touches[e.pointerId];\n            });\n        },\n\n        /**\n         * Add or remove the MS Pointer specific events\n         */\n        batchMSEvents: function (fn) {\n            fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);\n            fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);\n            fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);\n        }\n    });\n\n    // Disable default IE actions for pinch and such on chart element\n    wrap(Pointer.prototype, 'init', function (proceed, chart, options) {\n        proceed.call(this, chart, options);\n        if (this.hasZoom) { // #4014\n            css(chart.container, {\n                '-ms-touch-action': 'none',\n                'touch-action': 'none'\n            });\n        }\n    });\n\n    // Add IE specific touch events to chart\n    wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {\n        proceed.apply(this);\n        if (this.hasZoom || this.followTouchMove) {\n            this.batchMSEvents(addEvent);\n        }\n    });\n    // Destroy MS events also\n    wrap(Pointer.prototype, 'destroy', function (proceed) {\n        this.batchMSEvents(removeEvent);\n        proceed.call(this);\n    });\n}\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var Legend,\n        \n        addEvent = H.addEvent,\n        css = H.css,\n        discardElement = H.discardElement,\n        defined = H.defined,\n        each = H.each,\n        extend = H.extend,\n        isFirefox = H.isFirefox,\n        marginNames = H.marginNames,\n        merge = H.merge,\n        pick = H.pick,\n        setAnimation = H.setAnimation,\n        stableSort = H.stableSort,\n        win = H.win,\n        wrap = H.wrap;\n/**\n * The overview of the chart's series\n */\nLegend = H.Legend = function (chart, options) {\n    this.init(chart, options);\n};\n\nLegend.prototype = {\n\n    /**\n     * Initialize the legend\n     */\n    init: function (chart, options) {\n\n        this.chart = chart;\n        \n        this.setOptions(options);\n        \n        if (options.enabled) {\n        \n            // Render it\n            this.render();\n\n            // move checkboxes\n            addEvent(this.chart, 'endResize', function () {\n                this.legend.positionCheckboxes();\n            });\n        }\n    },\n\n    setOptions: function (options) {\n\n        var padding = pick(options.padding, 8);\n\n        this.options = options;\n    \n        ";
if (build.classic) { 
s += "\n        this.itemStyle = options.itemStyle;\n        this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle);\n        ";
} 
s += "\n        this.itemMarginTop = options.itemMarginTop || 0;\n        this.padding = padding;\n        this.initialItemX = padding;\n        this.initialItemY = padding - 5; // 5 is the number of pixels above the text\n        this.maxItemWidth = 0;\n        this.itemHeight = 0;\n        this.symbolWidth = pick(options.symbolWidth, 16);\n        this.pages = [];\n\n    },\n\n    update: function (options, redraw) { // docs. Sample created.\n        var chart = this.chart;\n\n        this.setOptions(merge(true, this.options, options));\n        this.destroy();\n        chart.isDirtyLegend = chart.isDirtyBox = true;\n        if (pick(redraw, true)) {\n            chart.redraw();\n        }\n    },\n\n    /**\n     * Set the colors for the legend item\n     * @param {Object} item A Series or Point instance\n     * @param {Object} visible Dimmed or colored\n     */\n    colorizeItem: function (item, visible) {\n        item.legendGroup[visible ? 'removeClass' : 'addClass']('highcharts-legend-item-hidden');\n\n        ";
if (build.classic) { 
s += "\n        var legend = this,\n            options = legend.options,\n            legendItem = item.legendItem,\n            legendLine = item.legendLine,\n            legendSymbol = item.legendSymbol,\n            hiddenColor = legend.itemHiddenStyle.color,\n            textColor = visible ? options.itemStyle.color : hiddenColor,\n            symbolColor = visible ? (item.color || '#CCC') : hiddenColor,\n            markerOptions = item.options && item.options.marker,\n            symbolAttr = { fill: symbolColor },\n            key;\n\n        if (legendItem) {\n            legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE\n        }\n        if (legendLine) {\n            legendLine.attr({ stroke: symbolColor });\n        }\n\n        if (legendSymbol) {\n\n            // Apply marker options\n            if (markerOptions && legendSymbol.isMarker) { // #585\n                //symbolAttr.stroke = symbolColor;\n                symbolAttr = item.pointAttribs();\n                if (!visible) {\n                    for (key in symbolAttr) {\n                            symbolAttr[key] = hiddenColor;\n                    }\n                }\n            }\n\n            legendSymbol.attr(symbolAttr);\n        }\n        ";
} 
s += "\n    },\n\n    /**\n     * Position the legend item\n     * @param {Object} item A Series or Point instance\n     */\n    positionItem: function (item) {\n        var legend = this,\n            options = legend.options,\n            symbolPadding = options.symbolPadding,\n            ltr = !options.rtl,\n            legendItemPos = item._legendItemPos,\n            itemX = legendItemPos[0],\n            itemY = legendItemPos[1],\n            checkbox = item.checkbox,\n            legendGroup = item.legendGroup;\n\n        if (legendGroup && legendGroup.element) {\n            legendGroup.translate(\n                ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,\n                itemY\n            );\n        }\n\n        if (checkbox) {\n            checkbox.x = itemX;\n            checkbox.y = itemY;\n        }\n    },\n\n    /**\n     * Destroy a single legend item\n     * @param {Object} item The series or point\n     */\n    destroyItem: function (item) {\n        var checkbox = item.checkbox;\n\n        // destroy SVG elements\n        each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {\n            if (item[key]) {\n                item[key] = item[key].destroy();\n            }\n        });\n\n        if (checkbox) {\n            discardElement(item.checkbox);\n        }\n    },\n\n    /**\n     * Destroys the legend.\n     */\n    destroy: function () {\n        var legend = this,\n            legendGroup = legend.group,\n            box = legend.box;\n\n        if (box) {\n            legend.box = box.destroy();\n        }\n\n        // Destroy items\n        each(this.getAllItems(), function (item) {\n            each(['legendItem', 'legendGroup'], function (key) {\n                if (item[key]) {\n                    item[key] = item[key].destroy();\n                }\n            });\n        });\n\n        if (legendGroup) {\n            legend.group = legendGroup.destroy();\n        }\n    },\n\n    /**\n     * Position the checkboxes after the width is determined\n     */\n    positionCheckboxes: function (scrollOffset) {\n        var alignAttr = this.group.alignAttr,\n            translateY,\n            clipHeight = this.clipHeight || this.legendHeight,\n            titleHeight = this.titleHeight;\n\n        if (alignAttr) {\n            translateY = alignAttr.translateY;\n            each(this.allItems, function (item) {\n                var checkbox = item.checkbox,\n                    top;\n\n                if (checkbox) {\n                    top = translateY + titleHeight + checkbox.y + (scrollOffset || 0) + 3;\n                    css(checkbox, {\n                        left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + 'px',\n                        top: top + 'px',\n                        display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : 'none'\n                    });\n                }\n            });\n        }\n    },\n\n    /**\n     * Render the legend title on top of the legend\n     */\n    renderTitle: function () {\n        var options = this.options,\n            padding = this.padding,\n            titleOptions = options.title,\n            titleHeight = 0,\n            bBox;\n\n        if (titleOptions.text) {\n            if (!this.title) {\n                this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')\n                    .attr({ zIndex: 1 })\n                    ";
if (build.classic) { 
s += "\n                    .css(titleOptions.style)\n                    ";
} 
s += "\n                    .add(this.group);\n            }\n            bBox = this.title.getBBox();\n            titleHeight = bBox.height;\n            this.offsetWidth = bBox.width; // #1717\n            this.contentGroup.attr({ translateY: titleHeight });\n        }\n        this.titleHeight = titleHeight;\n    },\n\n    /**\n     * Set the legend item text\n     */\n    setText: function (item) {\n        var options = this.options;\n        item.legendItem.attr({\n            text: options.labelFormat ? Highcharts.format(options.labelFormat, item) : options.labelFormatter.call(item)\n        });\n    },\n\n    /**\n     * Render a single specific legend item\n     * @param {Object} item A series or point\n     */\n    renderItem: function (item) {\n        var legend = this,\n            chart = legend.chart,\n            renderer = chart.renderer,\n            options = legend.options,\n            horizontal = options.layout === 'horizontal',\n            symbolWidth = legend.symbolWidth,\n            symbolPadding = options.symbolPadding,\n            ";
if (build.classic) { 
s += "\n            itemStyle = legend.itemStyle,\n            itemHiddenStyle = legend.itemHiddenStyle,\n            ";
} 
s += "\n            padding = legend.padding,\n            itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n            ltr = !options.rtl,\n            itemHeight,\n            widthOption = options.width,\n            itemMarginBottom = options.itemMarginBottom || 0,\n            itemMarginTop = legend.itemMarginTop,\n            initialItemX = legend.initialItemX,\n            bBox,\n            itemWidth,\n            li = item.legendItem,\n            isSeries = !item.series,\n            series = !isSeries && item.series.drawLegendSymbol ? item.series : item,\n            seriesOptions = series.options,\n            showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,\n            useHTML = options.useHTML,\n            fontSize = 12;\n\n        if (!li) { // generate it once, later move it\n\n            // Generate the group box\n            // A group to hold the symbol and text. Text is to be appended in Legend class.\n            item.legendGroup = renderer.g('legend-item')\n                .addClass('highcharts-' + series.type + '-series highcharts-color-' + item.colorIndex + ' ' + \n                    (item.options.className || '') +\n                    (isSeries ? 'highcharts-series-' + item.index : '')\n                )\n                .attr({ zIndex: 1 })\n                .add(legend.scrollGroup);\n\n            // Generate the list item text and add it to the group\n            item.legendItem = li = renderer.text(\n                    '',\n                    ltr ? symbolWidth + symbolPadding : -symbolPadding,\n                    legend.baseline || 0,\n                    useHTML\n                )\n                ";
if (build.classic) { 
s += "\n                .css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)\n                ";
} 
s += "\n                .attr({\n                    align: ltr ? 'left' : 'right',\n                    zIndex: 2\n                })\n                .add(item.legendGroup);\n\n            // Get the baseline for the first item - the font size is equal for all\n            if (!legend.baseline) {\n                ";
if (build.classic) { 
s += "\n                fontSize = itemStyle.fontSize;\n                ";
} 
s += "\n                legend.fontMetrics = renderer.fontMetrics(\n                    fontSize,\n                    li\n                );\n                legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;\n                li.attr('y', legend.baseline);\n            }\n\n            // Draw the legend symbol inside the group box\n            series.drawLegendSymbol(legend, item);\n\n            if (legend.setItemEvents) {\n                legend.setItemEvents(item, li, useHTML);\n            }            \n\n            // add the HTML checkbox on top\n            if (showCheckbox) {\n                legend.createCheckboxForItem(item);\n            }\n        }\n\n        // Colorize the items\n        legend.colorizeItem(item, item.visible);\n\n        // Always update the text\n        legend.setText(item);\n\n        // calculate the positions for the next line\n        bBox = li.getBBox();\n\n        itemWidth = item.checkboxOffset =\n            options.itemWidth ||\n            item.legendItemWidth ||\n            symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);\n        legend.itemHeight = itemHeight = Math.round(item.legendItemHeight || bBox.height);\n\n        // if the item exceeds the width, start a new line\n        if (horizontal && legend.itemX - initialItemX + itemWidth >\n                (widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {\n            legend.itemX = initialItemX;\n            legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;\n            legend.lastLineHeight = 0; // reset for next line (#915, #3976)\n        }\n\n        // If the item exceeds the height, start a new column\n        /*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {\n            legend.itemY = legend.initialItemY;\n            legend.itemX += legend.maxItemWidth;\n            legend.maxItemWidth = 0;\n        }*/\n\n        // Set the edge positions\n        legend.maxItemWidth = Math.max(legend.maxItemWidth, itemWidth);\n        legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;\n        legend.lastLineHeight = Math.max(itemHeight, legend.lastLineHeight); // #915\n\n        // cache the position of the newly generated or reordered items\n        item._legendItemPos = [legend.itemX, legend.itemY];\n\n        // advance\n        if (horizontal) {\n            legend.itemX += itemWidth;\n\n        } else {\n            legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n            legend.lastLineHeight = itemHeight;\n        }\n\n        // the width of the widest item\n        legend.offsetWidth = widthOption || Math.max(\n            (horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,\n            legend.offsetWidth\n        );\n    },\n\n    /**\n     * Get all items, which is one item per series for normal series and one item per point\n     * for pie series.\n     */\n    getAllItems: function () {\n        var allItems = [];\n        each(this.chart.series, function (series) {\n            var seriesOptions = series.options;\n\n            // Handle showInLegend. If the series is linked to another series, defaults to false.\n            if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? undefined : false, true)) {\n                return;\n            }\n\n            // use points or series for the legend item depending on legendType\n            allItems = allItems.concat(\n                    series.legendItems ||\n                    (seriesOptions.legendType === 'point' ?\n                            series.data :\n                            series)\n            );\n        });\n        return allItems;\n    },\n\n    /**\n     * Adjust the chart margins by reserving space for the legend on only one side\n     * of the chart. If the position is set to a corner, top or bottom is reserved\n     * for horizontal legends and left or right for vertical ones.\n     */\n    adjustMargins: function (margin, spacing) {\n        var chart = this.chart,\n            options = this.options,\n            // Use the first letter of each alignment option in order to detect the side\n            alignment = options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0); // #4189 - use charAt(x) notation instead of [x] for IE7\n\n        if (this.display && !options.floating) {\n\n            each([\n                /(lth|ct|rth)/,\n                /(rtv|rm|rbv)/,\n                /(rbh|cb|lbh)/,\n                /(lbv|lm|ltv)/\n            ], function (alignments, side) {\n                if (alignments.test(alignment) && !defined(margin[side])) {\n                    // Now we have detected on which side of the chart we should reserve space for the legend\n                    chart[marginNames[side]] = Math.max(\n                        chart[marginNames[side]],\n                        chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] +\n                            [1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] +\n                            pick(options.margin, 12) +\n                            spacing[side]\n                    );\n                }\n            });\n        }\n    },\n\n    /**\n     * Render the legend. This method can be called both before and after\n     * chart.render. If called after, it will only rearrange items instead\n     * of creating new ones.\n     */\n    render: function () {\n        var legend = this,\n            chart = legend.chart,\n            renderer = chart.renderer,\n            legendGroup = legend.group,\n            allItems,\n            display,\n            legendWidth,\n            legendHeight,\n            box = legend.box,\n            options = legend.options,\n            padding = legend.padding;\n\n        legend.itemX = legend.initialItemX;\n        legend.itemY = legend.initialItemY;\n        legend.offsetWidth = 0;\n        legend.lastItemY = 0;\n\n        if (!legendGroup) {\n            legend.group = legendGroup = renderer.g('legend')\n                .attr({ zIndex: 7 })\n                .add();\n            legend.contentGroup = renderer.g()\n                .attr({ zIndex: 1 }) // above background\n                .add(legendGroup);\n            legend.scrollGroup = renderer.g()\n                .add(legend.contentGroup);\n        }\n\n        legend.renderTitle();\n\n        // add each series or point\n        allItems = legend.getAllItems();\n\n        // sort by legendIndex\n        stableSort(allItems, function (a, b) {\n            return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);\n        });\n\n        // reversed legend\n        if (options.reversed) {\n            allItems.reverse();\n        }\n\n        legend.allItems = allItems;\n        legend.display = display = !!allItems.length;\n\n        // render the items\n        legend.lastLineHeight = 0;\n        each(allItems, function (item) {\n            legend.renderItem(item);\n        });\n\n        // Get the box\n        legendWidth = (options.width || legend.offsetWidth) + padding;\n        legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;\n        legendHeight = legend.handleOverflow(legendHeight);\n        legendHeight += padding;\n\n        // Draw the border and/or background\n        if (!box) {\n            legend.box = box = renderer.rect()\n                .addClass('highcharts-legend-box')\n                .attr({\n                    r: options.borderRadius\n                })\n                .add(legendGroup);\n            box.isNew = true;\n        } \n\n        ";
if (build.classic) { 
s += "\n        // Presentational\n        box.attr({\n                stroke: options.borderColor,\n                'stroke-width': options.borderWidth || 0,\n                fill: options.backgroundColor || 'none'\n            })\n            .shadow(options.shadow);\n        ";
} 
s += "\n\n        if (legendWidth > 0 && legendHeight > 0) {\n            box[box.isNew ? 'attr' : 'animate'](\n                box.crisp({ x: 0, y: 0, width: legendWidth, height: legendHeight }, box.strokeWidth())\n            );\n            box.isNew = false;\n        }\n\n        // hide the border if no items\n        box[display ? 'show' : 'hide']();\n\n        ";
if (!build.classic) { 
s += "\n        // Open for responsiveness\n        if (legendGroup.getStyle('display') === 'none') {\n            legendWidth = legendHeight = 0;\n        }\n        ";
} 
s += "\n\n        legend.legendWidth = legendWidth;\n        legend.legendHeight = legendHeight;\n\n        // Now that the legend width and height are established, put the items in the\n        // final position\n        each(allItems, function (item) {\n            legend.positionItem(item);\n        });\n\n        // 1.x compatibility: positioning based on style\n        /*var props = ['left', 'right', 'top', 'bottom'],\n            prop,\n            i = 4;\n        while (i--) {\n            prop = props[i];\n            if (options.style[prop] && options.style[prop] !== 'auto') {\n                options[i < 2 ? 'align' : 'verticalAlign'] = prop;\n                options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);\n            }\n        }*/\n\n        if (display) {\n            legendGroup.align(extend({\n                width: legendWidth,\n                height: legendHeight\n            }, options), true, 'spacingBox');\n        }\n\n        if (!chart.isResizing) {\n            this.positionCheckboxes();\n        }\n    },\n\n    /**\n     * Set up the overflow handling by adding navigation with up and down arrows below the\n     * legend.\n     */\n    handleOverflow: function (legendHeight) {\n        var legend = this,\n            chart = this.chart,\n            renderer = chart.renderer,\n            options = this.options,\n            optionsY = options.y,\n            alignTop = options.verticalAlign === 'top',\n            spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,\n            maxHeight = options.maxHeight,\n            clipHeight,\n            clipRect = this.clipRect,\n            navOptions = options.navigation,\n            animation = pick(navOptions.animation, true),\n            arrowSize = navOptions.arrowSize || 12,\n            nav = this.nav,\n            pages = this.pages,\n            padding = this.padding,\n            lastY,\n            allItems = this.allItems,\n            clipToHeight = function (height) {\n                clipRect.attr({\n                    height: height\n                });\n\n                // useHTML\n                if (legend.contentGroup.div) {\n                    legend.contentGroup.div.style.clip = 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)';\n                }\n            };\n\n\n        // Adjust the height\n        if (options.layout === 'horizontal') {\n            spaceHeight /= 2;\n        }\n        if (maxHeight) {\n            spaceHeight = Math.min(spaceHeight, maxHeight);\n        }\n\n        // Reset the legend height and adjust the clipping rectangle\n        pages.length = 0;\n        if (legendHeight > spaceHeight && navOptions.enabled !== false) {\n\n            this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);\n            this.currentPage = pick(this.currentPage, 1);\n            this.fullHeight = legendHeight;\n\n            // Fill pages with Y positions so that the top of each a legend item defines\n            // the scroll top for each page (#2098)\n            each(allItems, function (item, i) {\n                var y = item._legendItemPos[1],\n                    h = Math.round(item.legendItem.getBBox().height),\n                    len = pages.length;\n\n                if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {\n                    pages.push(lastY || y);\n                    len++;\n                }\n\n                if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {\n                    pages.push(y);\n                }\n                if (y !== lastY) {\n                    lastY = y;\n                }\n            });\n\n            // Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)\n            if (!clipRect) {\n                clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);\n                legend.contentGroup.clip(clipRect);\n            }\n\n            clipToHeight(clipHeight);\n\n            // Add navigation elements\n            if (!nav) {\n                this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);\n                this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)\n                    .on('click', function () {\n                        legend.scroll(-1, animation);\n                    })\n                    .add(nav);\n                this.pager = renderer.text('', 15, 10)\n                    .addClass('highcharts-legend-navigation')\n                    ";
if (build.classic) { 
s += "\n                    .css(navOptions.style)\n                    ";
} 
s += "\n                    .add(nav);\n                this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)\n                    .on('click', function () {\n                        legend.scroll(1, animation);\n                    })\n                    .add(nav);\n            }\n\n            // Set initial position\n            legend.scroll(0);\n\n            legendHeight = spaceHeight;\n\n        } else if (nav) {\n            clipToHeight(chart.chartHeight);\n            nav.hide();\n            this.scrollGroup.attr({\n                translateY: 1\n            });\n            this.clipHeight = 0; // #1379\n        }\n\n        return legendHeight;\n    },\n\n    /**\n     * Scroll the legend by a number of pages\n     * @param {Object} scrollBy\n     * @param {Object} animation\n     */\n    scroll: function (scrollBy, animation) {\n        var pages = this.pages,\n            pageCount = pages.length,\n            currentPage = this.currentPage + scrollBy,\n            clipHeight = this.clipHeight,\n            navOptions = this.options.navigation,\n            pager = this.pager,\n            padding = this.padding,\n            scrollOffset;\n\n        // When resizing while looking at the last page\n        if (currentPage > pageCount) {\n            currentPage = pageCount;\n        }\n\n        if (currentPage > 0) {\n            \n            if (animation !== undefined) {\n                setAnimation(animation, this.chart);\n            }\n\n            this.nav.attr({\n                translateX: padding,\n                translateY: clipHeight + this.padding + 7 + this.titleHeight,\n                visibility: 'visible'\n            });\n            this.up.attr({\n                'class': currentPage === 1 ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n            });\n            pager.attr({\n                text: currentPage + '/' + pageCount\n            });\n            this.down.attr({\n                'x': 18 + this.pager.getBBox().width, // adjust to text width\n                'class': currentPage === pageCount ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n            });\n\n            ";
if (build.classic) { 
s += "\n            this.up\n                .attr({\n                    fill: currentPage === 1 ? navOptions.inactiveColor : navOptions.activeColor\n                })\n                .css({\n                    cursor: currentPage === 1 ? 'default' : 'pointer'\n                });\n            this.down\n                .attr({\n                    fill: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor\n                })\n                .css({\n                    cursor: currentPage === pageCount ? 'default' : 'pointer'\n                });\n            ";
} 
s += "\n            \n            scrollOffset = -pages[currentPage - 1] + this.initialItemY;\n\n            this.scrollGroup.animate({\n                translateY: scrollOffset\n            });\n\n            this.currentPage = currentPage;\n            this.positionCheckboxes(scrollOffset);\n        }\n\n    }\n\n};\n\n/*\n * LegendSymbolMixin\n */\n\nH.LegendSymbolMixin = {\n\n    /**\n     * Get the series' symbol in the legend\n     *\n     * @param {Object} legend The legend object\n     * @param {Object} item The series (this) or point\n     */\n    drawRectangle: function (legend, item) {\n        var symbolHeight = legend.options.symbolHeight || legend.fontMetrics.f;\n\n        item.legendSymbol = this.chart.renderer.rect(\n            0,\n            legend.baseline - symbolHeight + 1, // #3988\n            legend.symbolWidth,\n            symbolHeight,\n            legend.options.symbolRadius || 0\n        )\n        .addClass('highcharts-point')\n        .attr({\n            zIndex: 3\n        }).add(item.legendGroup);\n\n    },\n\n    /**\n     * Get the series' symbol in the legend. This method should be overridable to create custom\n     * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n     *\n     * @param {Object} legend The legend object\n     */\n    drawLineMarker: function (legend) {\n\n        var options = this.options,\n            markerOptions = options.marker,\n            radius,\n            legendSymbol,\n            symbolWidth = legend.symbolWidth,\n            renderer = this.chart.renderer,\n            legendItemGroup = this.legendGroup,\n            verticalCenter = legend.baseline - Math.round(legend.fontMetrics.b * 0.3),\n            attr = {};\n\n        // Draw the line\n        ";
if (build.classic) { 
s += "\n        attr = {\n            'stroke-width': options.lineWidth || 0\n        };\n        if (options.dashStyle) {\n            attr.dashstyle = options.dashStyle;\n        }\n        ";
} 
s += "\n        \n        this.legendLine = renderer.path([\n            'M',\n            0,\n            verticalCenter,\n            'L',\n            symbolWidth,\n            verticalCenter\n        ])\n        .addClass('highcharts-graph')\n        .attr(attr)\n        .add(legendItemGroup);\n        \n        // Draw the marker\n        if (markerOptions && markerOptions.enabled !== false) {\n            radius = markerOptions.radius;\n            this.legendSymbol = legendSymbol = renderer.symbol(\n                this.symbol,\n                (symbolWidth / 2) - radius,\n                verticalCenter - radius,\n                2 * radius,\n                2 * radius,\n                markerOptions\n            )\n            .addClass('highcharts-point')\n            .add(legendItemGroup);\n            legendSymbol.isMarker = true;\n        }\n    }\n};\n\n// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,\n// and for #2580, a similar drawing flaw in Firefox 26.\n// Explore if there's a general cause for this. The problem may be related\n// to nested group elements, as the legend item texts are within 4 group elements.\nif (/Trident\\/7\\.0/.test(win.navigator.userAgent) || isFirefox) {\n    wrap(Legend.prototype, 'positionItem', function (proceed, item) {\n        var legend = this,\n            runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)\n                if (item._legendItemPos) {\n                    proceed.call(legend, item);\n                }\n            };\n\n        // Do it now, for export and to get checkbox placement\n        runPositionItem();\n\n        // Do it after to work around the core issue\n        setTimeout(runPositionItem);\n    });\n}\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var addEvent = H.addEvent,\n        animate = H.animate,\n        animObject = H.animObject,\n        attr = H.attr,\n        doc = H.doc,\n        Axis = H.Axis, // @todo add as requirement\n        CanVGController = H.CanVGController,\n        createElement = H.createElement,\n        defaultOptions = H.defaultOptions,\n        discardElement = H.discardElement,\n        charts = H.charts,\n        css = H.css,\n        defined = H.defined,\n        each = H.each,\n        error = H.error,\n        extend = H.extend,\n        fireEvent = H.fireEvent,\n        getStyle = H.getStyle,\n        grep = H.grep,\n        isNumber = H.isNumber,\n        isString = H.isString,\n        Legend = H.Legend, // @todo add as requirement\n        marginNames = H.marginNames,\n        merge = H.merge,\n        Pointer = H.Pointer, // @todo add as requirement\n        pick = H.pick,\n        pInt = H.pInt,\n        removeEvent = H.removeEvent,\n        seriesTypes = H.seriesTypes,\n        splat = H.splat,\n        svg = H.svg,\n        syncTimeout = H.syncTimeout,\n        win = H.win,\n        Renderer = H.Renderer,\n        useCanVG = H.useCanVG;\n/**\n * The Chart class\n * @param {String|Object} renderTo The DOM element to render to, or its id\n * @param {Object} options\n * @param {Function} callback Function to run when the chart has loaded\n */\nvar Chart = Highcharts.Chart = function () {\n    this.getArgs.apply(this, arguments);\n};\n\nHighcharts.chart = function (a, b, c) {\n    return new Chart(a, b, c);\n};\n\nChart.prototype = {\n\n    /**\n     * Hook for modules\n     */\n    callbacks: [],\n\n    ";
if (!build.classic) { 
s += "\n    colorCount: 10,\n    ";
} 
s += "\n\n    /**\n     * Handle the arguments passed to the constructor\n     * @returns {Array} Arguments without renderTo\n     */\n    getArgs: function () {\n        var args = [].slice.call(arguments);\n        \n        // Remove the optional first argument, renderTo, and\n        // set it on this.\n        if (isString(args[0]) || args[0].nodeName) {\n            this.renderTo = args.shift();\n        }\n        this.init(args[0], args[1]);\n    },\n\n    /**\n     * Initialize the chart\n     */\n    init: function (userOptions, callback) {\n\n        // Handle regular options\n        var options,\n            seriesOptions = userOptions.series; // skip merging data points to increase performance\n\n        userOptions.series = null;\n        options = merge(defaultOptions, userOptions); // do the merge\n        options.series = userOptions.series = seriesOptions; // set back the series data\n        this.userOptions = userOptions;\n\n        var optionsChart = options.chart;\n\n        // Create margin & spacing array\n        this.margin = this.splashArray('margin', optionsChart);\n        this.spacing = this.splashArray('spacing', optionsChart);\n\n        var chartEvents = optionsChart.events;\n\n        //this.runChartClick = chartEvents && !!chartEvents.click;\n        this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom\n\n        this.callback = callback;\n        this.isResizing = 0;\n        this.options = options;\n        //chartTitleOptions = undefined;\n        //chartSubtitleOptions = undefined;\n\n        this.axes = [];\n        this.series = [];\n        this.hasCartesianSeries = optionsChart.showAxes;\n        //this.axisOffset = undefined;\n        //this.maxTicks = undefined; // handle the greatest amount of ticks on grouped axes\n        //this.inverted = undefined;\n        //this.loadingShown = undefined;\n        //this.container = undefined;\n        //this.chartWidth = undefined;\n        //this.chartHeight = undefined;\n        //this.marginRight = undefined;\n        //this.marginBottom = undefined;\n        //this.containerWidth = undefined;\n        //this.containerHeight = undefined;\n        //this.oldChartWidth = undefined;\n        //this.oldChartHeight = undefined;\n\n        //this.renderTo = undefined;\n        //this.renderToClone = undefined;\n\n        //this.spacingBox = undefined\n\n        //this.legend = undefined;\n\n        // Elements\n        //this.chartBackground = undefined;\n        //this.plotBackground = undefined;\n        //this.plotBGImage = undefined;\n        //this.plotBorder = undefined;\n        //this.loadingDiv = undefined;\n        //this.loadingSpan = undefined;\n\n        var chart = this,\n            eventType;\n\n        // Add the chart to the global lookup\n        chart.index = charts.length;\n        charts.push(chart);\n        H.chartCount++;\n\n        // Set up auto resize\n        if (optionsChart.reflow !== false) {\n            addEvent(chart, 'load', function () {\n                chart.initReflow();\n            });\n        }\n\n        // Chart event handlers\n        if (chartEvents) {\n            for (eventType in chartEvents) {\n                addEvent(chart, eventType, chartEvents[eventType]);\n            }\n        }\n\n        chart.xAxis = [];\n        chart.yAxis = [];\n\n        // Expose methods and variables\n        chart.animation = useCanVG ? false : pick(optionsChart.animation, true);\n        chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;\n\n        chart.firstRender();\n    },\n\n    /**\n     * Initialize an individual series, called internally before render time\n     */\n    initSeries: function (options) {\n        var chart = this,\n            optionsChart = chart.options.chart,\n            type = options.type || optionsChart.type || optionsChart.defaultSeriesType,\n            series,\n            constr = seriesTypes[type];\n\n        // No such series type\n        if (!constr) {\n            error(17, true);\n        }\n\n        series = new constr();\n        series.init(this, options);\n        return series;\n    },\n\n    /**\n     * Check whether a given point is within the plot area\n     *\n     * @param {Number} plotX Pixel x relative to the plot area\n     * @param {Number} plotY Pixel y relative to the plot area\n     * @param {Boolean} inverted Whether the chart is inverted\n     */\n    isInsidePlot: function (plotX, plotY, inverted) {\n        var x = inverted ? plotY : plotX,\n            y = inverted ? plotX : plotY;\n\n        return x >= 0 &&\n            x <= this.plotWidth &&\n            y >= 0 &&\n            y <= this.plotHeight;\n    },\n\n    /**\n     * Redraw legend, axes or series based on updated data\n     *\n     * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n     *    configuration\n     */\n    redraw: function (animation) {\n        var chart = this,\n            axes = chart.axes,\n            series = chart.series,\n            pointer = chart.pointer,\n            legend = chart.legend,\n            redrawLegend = chart.isDirtyLegend,\n            hasStackedSeries,\n            hasDirtyStacks,\n            hasCartesianSeries = chart.hasCartesianSeries,\n            isDirtyBox = chart.isDirtyBox,\n            seriesLength = series.length,\n            i = seriesLength,\n            serie,\n            renderer = chart.renderer,\n            isHiddenChart = renderer.isHidden(),\n            afterRedraw = [];\n            \n        H.setAnimation(animation, chart);\n        \n        if (isHiddenChart) {\n            chart.cloneRenderTo();\n        }\n\n        // Adjust title layout (reflow multiline text)\n        chart.layOutTitles();\n\n        // link stacked series\n        while (i--) {\n            serie = series[i];\n\n            if (serie.options.stacking) {\n                hasStackedSeries = true;\n\n                if (serie.isDirty) {\n                    hasDirtyStacks = true;\n                    break;\n                }\n            }\n        }\n        if (hasDirtyStacks) { // mark others as dirty\n            i = seriesLength;\n            while (i--) {\n                serie = series[i];\n                if (serie.options.stacking) {\n                    serie.isDirty = true;\n                }\n            }\n        }\n\n        // Handle updated data in the series\n        each(series, function (serie) {\n            if (serie.isDirty) {\n                if (serie.options.legendType === 'point') {\n                    if (serie.updateTotals) {\n                        serie.updateTotals();\n                    }\n                    redrawLegend = true;\n                }\n            }\n            if (serie.isDirtyData) {\n                fireEvent(serie, 'updatedData');\n            }\n        });\n\n        // handle added or removed series\n        if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed\n            // draw legend graphics\n            legend.render();\n\n            chart.isDirtyLegend = false;\n        }\n\n        // reset stacks\n        if (hasStackedSeries) {\n            chart.getStacks();\n        }\n\n\n        if (hasCartesianSeries) {\n            if (!chart.isResizing) {\n\n                // reset maxTicks\n                chart.maxTicks = null;\n\n                // set axes scales\n                each(axes, function (axis) {\n                    axis.setScale();\n                });\n            }\n        }\n\n        chart.getMargins(); // #3098\n\n        if (hasCartesianSeries) {\n            // If one axis is dirty, all axes must be redrawn (#792, #2169)\n            each(axes, function (axis) {\n                if (axis.isDirty) {\n                    isDirtyBox = true;\n                }\n            });\n\n            // redraw axes\n            each(axes, function (axis) {\n\n                // Fire 'afterSetExtremes' only if extremes are set\n                var key = axis.min + ',' + axis.max;\n                if (axis.extKey !== key) { // #821, #4452\n                    axis.extKey = key;\n                    afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)\n                        fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751\n                        delete axis.eventArgs;\n                    });\n                }\n                if (isDirtyBox || hasStackedSeries) {\n                    axis.redraw();\n                }\n            });\n        }\n\n        // the plot areas size has changed\n        if (isDirtyBox) {\n            chart.drawChartBox();\n        }\n\n\n        // redraw affected series\n        each(series, function (serie) {\n            if (serie.isDirty && serie.visible &&\n                    (!serie.isCartesian || serie.xAxis)) { // issue #153\n                serie.redraw();\n            }\n        });\n\n        // move tooltip or reset\n        if (pointer) {\n            pointer.reset(true);\n        }\n\n        // redraw if canvas\n        renderer.draw();\n\n        // fire the event\n        fireEvent(chart, 'redraw');\n\n        if (isHiddenChart) {\n            chart.cloneRenderTo(true);\n        }\n\n        // Fire callbacks that are put on hold until after the redraw\n        each(afterRedraw, function (callback) {\n            callback.call();\n        });\n    },\n\n    /**\n     * Get an axis, series or point object by id.\n     * @param id {String} The id as given in the configuration options\n     */\n    get: function (id) {\n        var chart = this,\n            axes = chart.axes,\n            series = chart.series;\n\n        var i,\n            j,\n            points;\n\n        // search axes\n        for (i = 0; i < axes.length; i++) {\n            if (axes[i].options.id === id) {\n                return axes[i];\n            }\n        }\n\n        // search series\n        for (i = 0; i < series.length; i++) {\n            if (series[i].options.id === id) {\n                return series[i];\n            }\n        }\n\n        // search points\n        for (i = 0; i < series.length; i++) {\n            points = series[i].points || [];\n            for (j = 0; j < points.length; j++) {\n                if (points[j].id === id) {\n                    return points[j];\n                }\n            }\n        }\n        return null;\n    },\n\n    /**\n     * Create the Axis instances based on the config options\n     */\n    getAxes: function () {\n        var chart = this,\n            options = this.options,\n            xAxisOptions = options.xAxis = splat(options.xAxis || {}),\n            yAxisOptions = options.yAxis = splat(options.yAxis || {}),\n            optionsArray;\n\n        // make sure the options are arrays and add some members\n        each(xAxisOptions, function (axis, i) {\n            axis.index = i;\n            axis.isX = true;\n        });\n\n        each(yAxisOptions, function (axis, i) {\n            axis.index = i;\n        });\n\n        // concatenate all axis options into one array\n        optionsArray = xAxisOptions.concat(yAxisOptions);\n\n        each(optionsArray, function (axisOptions) {\n            new Axis(chart, axisOptions); // eslint-disable-line no-new\n        });\n    },\n\n\n    /**\n     * Get the currently selected points from all series\n     */\n    getSelectedPoints: function () {\n        var points = [];\n        each(this.series, function (serie) {\n            points = points.concat(grep(serie.points || [], function (point) {\n                return point.selected;\n            }));\n        });\n        return points;\n    },\n\n    /**\n     * Get the currently selected series\n     */\n    getSelectedSeries: function () {\n        return grep(this.series, function (serie) {\n            return serie.selected;\n        });\n    },\n\n    /**\n     * Show the title and subtitle of the chart\n     *\n     * @param titleOptions {Object} New title options\n     * @param subtitleOptions {Object} New subtitle options\n     *\n     */\n    setTitle: function (titleOptions, subtitleOptions, redraw) {\n        var chart = this,\n            options = chart.options,\n            chartTitleOptions,\n            chartSubtitleOptions;\n\n        chartTitleOptions = options.title = merge(options.title, titleOptions);\n        chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);\n\n        // add title and subtitle\n        each([\n            ['title', titleOptions, chartTitleOptions],\n            ['subtitle', subtitleOptions, chartSubtitleOptions]\n        ], function (arr, i) {\n            var name = arr[0],\n                title = chart[name],\n                titleOptions = arr[1],\n                chartTitleOptions = arr[2];\n\n            if (title && titleOptions) {\n                chart[name] = title = title.destroy(); // remove old\n            }\n\n            if (chartTitleOptions && chartTitleOptions.text && !title) {\n                chart[name] = chart.renderer.text(\n                    chartTitleOptions.text,\n                    0,\n                    0,\n                    chartTitleOptions.useHTML\n                )\n                .attr({\n                    align: chartTitleOptions.align,\n                    'class': 'highcharts-' + name,\n                    zIndex: chartTitleOptions.zIndex || 4\n                })\n                .css(chartTitleOptions.style)\n                .add();\n\n                // Update methods, shortcut to Chart.setTitle // docs. Sample created\n                chart[name].update = function (o) {\n                    chart.setTitle(!i && o, i && o);\n                };\n            }\n        });\n        chart.layOutTitles(redraw);\n    },\n\n    /**\n     * Lay out the chart titles and cache the full offset height for use in getMargins\n     */\n    layOutTitles: function (redraw) {\n        var titleOffset = 0,\n            requiresDirtyBox,\n            renderer = this.renderer,\n            spacingBox = this.spacingBox;\n\n        // Lay out the title and the subtitle respectively\n        each(['title', 'subtitle'], function (key) {\n            var title = this[key],\n                titleOptions = this.options[key],\n                titleSize;\n\n            if (title) {\n                ";
if (build.classic) { 
s += "\n                titleSize = titleOptions.style.fontSize;\n                ";
} 
s += "\n                titleSize = renderer.fontMetrics(titleSize, title).b;\n                \n                title\n                    .css({ width: (titleOptions.width || spacingBox.width + titleOptions.widthAdjust) + 'px' })\n                    .align(extend({ \n                        y: titleOffset + titleSize + (key === 'title' ? -3 : 2)\n                    }, titleOptions), false, 'spacingBox');\n\n                if (!titleOptions.floating && !titleOptions.verticalAlign) {\n                    titleOffset = Math.ceil(titleOffset + title.getBBox().height);\n                }\n            }\n        }, this);\n\n        requiresDirtyBox = this.titleOffset !== titleOffset;\n        this.titleOffset = titleOffset; // used in getMargins\n\n        if (!this.isDirtyBox && requiresDirtyBox) {\n            this.isDirtyBox = requiresDirtyBox;\n            // Redraw if necessary (#2719, #2744)\n            if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {\n                this.redraw();\n            }\n        }\n    },\n\n    /**\n     * Get chart width and height according to options and container size\n     */\n    getChartSize: function () {\n        var chart = this,\n            optionsChart = chart.options.chart,\n            widthOption = optionsChart.width,\n            heightOption = optionsChart.height,\n            renderTo = chart.renderToClone || chart.renderTo;\n\n        // Get inner width and height\n        if (!defined(widthOption)) {\n            chart.containerWidth = getStyle(renderTo, 'width');\n        }\n        if (!defined(heightOption)) {\n            chart.containerHeight = getStyle(renderTo, 'height');\n        }\n        \n        chart.chartWidth = Math.max(0, widthOption || chart.containerWidth || 600); // #1393, 1460\n        chart.chartHeight = Math.max(0, pick(heightOption,\n            // the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:\n            chart.containerHeight > 19 ? chart.containerHeight : 400));\n    },\n\n    /**\n     * Create a clone of the chart's renderTo div and place it outside the viewport to allow\n     * size computation on chart.render and chart.redraw\n     */\n    cloneRenderTo: function (revert) {\n        var clone = this.renderToClone,\n            container = this.container;\n\n        // Destroy the clone and bring the container back to the real renderTo div\n        if (revert) {\n            if (clone) {\n                this.renderTo.appendChild(container);\n                discardElement(clone);\n                delete this.renderToClone;\n            }\n\n        // Set up the clone\n        } else {\n            if (container && container.parentNode === this.renderTo) {\n                this.renderTo.removeChild(container); // do not clone this\n            }\n            this.renderToClone = clone = this.renderTo.cloneNode(0);\n            css(clone, {\n                position: 'absolute',\n                top: '-9999px',\n                display: 'block' // #833\n            });\n            if (clone.style.setProperty) { // #2631\n                clone.style.setProperty('display', 'block', 'important');\n            }\n            doc.body.appendChild(clone);\n            if (container) {\n                clone.appendChild(container);\n            }\n        }\n    },\n\n    /**\n     * Get the containing element, determine the size and create the inner container\n     * div to hold the chart\n     */\n    getContainer: function () {\n        var chart = this,\n            container,\n            options = chart.options,\n            optionsChart = options.chart,\n            chartWidth,\n            chartHeight,\n            renderTo = chart.renderTo,\n            indexAttrName = 'data-highcharts-chart',\n            oldChartIndex,\n            Ren,\n            containerId = 'highcharts-' + H.idCounter++,\n            containerStyle,\n            key;\n\n        if (!renderTo) {\n            chart.renderTo = renderTo = optionsChart.renderTo;\n        }\n        \n        if (isString(renderTo)) {\n            chart.renderTo = renderTo = doc.getElementById(renderTo);\n        }\n\n        // Display an error if the renderTo is wrong\n        if (!renderTo) {\n            error(13, true);\n        }\n\n        // If the container already holds a chart, destroy it. The check for hasRendered is there\n        // because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart\n        // attribute and the SVG contents, but not an interactive chart. So in this case,\n        // charts[oldChartIndex] will point to the wrong chart if any (#2609).\n        oldChartIndex = pInt(attr(renderTo, indexAttrName));\n        if (isNumber(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {\n            charts[oldChartIndex].destroy();\n        }\n\n        // Make a reference to the chart from the div\n        attr(renderTo, indexAttrName, chart.index);\n\n        // remove previous chart\n        renderTo.innerHTML = '';\n\n        // If the container doesn't have an offsetWidth, it has or is a child of a node\n        // that has display:none. We need to temporarily move it out to a visible\n        // state to determine the size, else the legend and tooltips won't render\n        // properly. The allowClone option is used in sparklines as a micro optimization,\n        // saving about 1-2 ms each chart.\n        if (!optionsChart.skipClone && !renderTo.offsetWidth) {\n            chart.cloneRenderTo();\n        }\n\n        // get the width and height\n        chart.getChartSize();\n        chartWidth = chart.chartWidth;\n        chartHeight = chart.chartHeight;\n\n        // Create the inner container\n        ";
if (build.classic) { 
s += "\n        containerStyle = extend({\n            position: 'relative',\n            overflow: 'hidden', // needed for context menu (avoid scrollbars) and\n                // content overflow in IE\n            width: chartWidth + 'px',\n            height: chartHeight + 'px',\n            textAlign: 'left',\n            lineHeight: 'normal', // #427\n            zIndex: 0, // #1072\n            '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'\n        }, optionsChart.style);\n        ";
} 
s += "\n        chart.container = container = createElement('div', {\n                className: 'highcharts-container ' + (optionsChart.className || ''),\n                id: containerId\n            },\n            containerStyle,\n            chart.renderToClone || renderTo\n        );\n\n        // cache the cursor (#1650)\n        chart._cursor = container.style.cursor;\n\n        // Initialize the renderer\n        Ren = Highcharts[optionsChart.renderer] || Renderer;\n        chart.renderer = new Ren(\n            container,\n            chartWidth,\n            chartHeight,\n            optionsChart.style,\n            optionsChart.forExport,\n            options.exporting && options.exporting.allowHTML\n        );\n\n        ";
if (!build.classic) { 
s += "\n        // Initialize definitions\n        for (key in options.defs) {\n            this.renderer.addDefinition(options.defs[key]);\n        }\n        ";
} 
s += "        \n\n        if (useCanVG) {\n            // If we need canvg library, extend and configure the renderer\n            // to get the tracker for translating mouse events\n            chart.renderer.create(chart, container, chartWidth, chartHeight);\n        }\n        // Add a reference to the charts index\n        chart.renderer.chartIndex = chart.index;\n    },\n\n    /**\n     * Calculate margins by rendering axis labels in a preliminary position. Title,\n     * subtitle and legend have already been rendered at this stage, but will be\n     * moved into their final positions\n     */\n    getMargins: function (skipAxes) {\n        var chart = this,\n            spacing = chart.spacing,\n            margin = chart.margin,\n            titleOffset = chart.titleOffset;\n\n        chart.resetMargins();\n\n        // Adjust for title and subtitle\n        if (titleOffset && !defined(margin[0])) {\n            chart.plotTop = Math.max(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);\n        }\n\n        // Adjust for legend\n        chart.legend.adjustMargins(margin, spacing);\n\n        // adjust for scroller\n        if (chart.extraBottomMargin) {\n            chart.marginBottom += chart.extraBottomMargin;\n        }\n        if (chart.extraTopMargin) {\n            chart.plotTop += chart.extraTopMargin;\n        }\n        if (!skipAxes) {\n            this.getAxisMargins();\n        }\n    },\n\n    getAxisMargins: function () {\n\n        var chart = this,\n            axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left\n            margin = chart.margin;\n\n        // pre-render axes to get labels offset width\n        if (chart.hasCartesianSeries) {\n            each(chart.axes, function (axis) {\n                if (axis.visible) {\n                    axis.getOffset();\n                }\n            });\n        }\n\n        // Add the axis offsets\n        each(marginNames, function (m, side) {\n            if (!defined(margin[side])) {\n                chart[m] += axisOffset[side];\n            }\n        });\n\n        chart.setChartSize();\n\n    },\n\n    /**\n     * Resize the chart to its container if size is not explicitly set\n     */\n    reflow: function (e) {\n        var chart = this,\n            optionsChart = chart.options.chart,\n            renderTo = chart.renderTo,\n            width = optionsChart.width || getStyle(renderTo, 'width'),\n            height = optionsChart.height || getStyle(renderTo, 'height'),\n            target = e ? e.target : win;\n\n        // Width and height checks for display:none. Target is doc in IE8 and Opera,\n        // win in Firefox, Chrome and IE9.\n        if (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093\n            if (width !== chart.containerWidth || height !== chart.containerHeight) {\n                clearTimeout(chart.reflowTimeout);\n                // When called from window.resize, e is set, else it's called directly (#2224)\n                chart.reflowTimeout = syncTimeout(function () {\n                    if (chart.container) { // It may have been destroyed in the meantime (#1257)\n                        chart.setSize(width, height, false);\n                        chart.hasUserSize = null;\n                    }\n                }, e ? 100 : 0);\n            }\n            chart.containerWidth = width;\n            chart.containerHeight = height;\n        }\n    },\n\n    /**\n     * Add the event handlers necessary for auto resizing\n     */\n    initReflow: function () {\n        var chart = this,\n            reflow = function (e) {\n                chart.reflow(e);\n            };\n            \n        \n        addEvent(win, 'resize', reflow);\n        addEvent(chart, 'destroy', function () {\n            removeEvent(win, 'resize', reflow);\n        });\n    },\n\n    /**\n     * Resize the chart to a given width and height\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Object|Boolean} animation\n     */\n    setSize: function (width, height, animation) {\n        var chart = this,\n            chartWidth,\n            chartHeight,\n            renderer = chart.renderer,\n            globalAnimation;\n\n        // Handle the isResizing counter\n        chart.isResizing += 1;\n        \n        // set the animation for the current process\n        H.setAnimation(animation, chart);\n\n        chart.oldChartHeight = chart.chartHeight;\n        chart.oldChartWidth = chart.chartWidth;\n        if (defined(width)) {\n            chart.chartWidth = chartWidth = Math.max(0, Math.round(width));\n            chart.hasUserSize = !!chartWidth;\n        }\n        if (defined(height)) {\n            chart.chartHeight = chartHeight = Math.max(0, Math.round(height));\n        }\n\n        // Resize the container with the global animation applied if enabled (#2503)\n        ";
if (build.classic) { 
s += "\n        globalAnimation = renderer.globalAnimation;\n        (globalAnimation ? animate : css)(chart.container, {\n            width: chartWidth + 'px',\n            height: chartHeight + 'px'\n        }, globalAnimation);\n        ";
} 
s += "\n\n        chart.setChartSize(true);\n        renderer.setSize(chartWidth, chartHeight, animation);\n\n        // handle axes\n        chart.maxTicks = null;\n        each(chart.axes, function (axis) {\n            axis.isDirty = true;\n            axis.setScale();\n        });\n\n        // make sure non-cartesian series are also handled\n        each(chart.series, function (serie) {\n            serie.isDirty = true;\n        });\n\n        chart.isDirtyLegend = true; // force legend redraw\n        chart.isDirtyBox = true; // force redraw of plot and chart border\n\n        chart.layOutTitles(); // #2857\n        chart.getMargins();\n\n        chart.redraw(animation);\n\n\n        chart.oldChartHeight = null;\n        fireEvent(chart, 'resize');\n\n        // Fire endResize and set isResizing back. If animation is disabled, fire without delay\n        syncTimeout(function () {\n            if (chart) {\n                fireEvent(chart, 'endResize', null, function () {\n                    chart.isResizing -= 1;\n                });\n            }\n        }, animObject(globalAnimation).duration);\n    },\n\n    /**\n     * Set the public chart properties. This is done before and after the pre-render\n     * to determine margin sizes\n     */\n    setChartSize: function (skipAxes) {\n        var chart = this,\n            inverted = chart.inverted,\n            renderer = chart.renderer,\n            chartWidth = chart.chartWidth,\n            chartHeight = chart.chartHeight,\n            optionsChart = chart.options.chart,\n            spacing = chart.spacing,\n            clipOffset = chart.clipOffset,\n            clipX,\n            clipY,\n            plotLeft,\n            plotTop,\n            plotWidth,\n            plotHeight,\n            plotBorderWidth;\n\n        chart.plotLeft = plotLeft = Math.round(chart.plotLeft);\n        chart.plotTop = plotTop = Math.round(chart.plotTop);\n        chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));\n        chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));\n\n        chart.plotSizeX = inverted ? plotHeight : plotWidth;\n        chart.plotSizeY = inverted ? plotWidth : plotHeight;\n\n        chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;\n\n        // Set boxes used for alignment\n        chart.spacingBox = renderer.spacingBox = {\n            x: spacing[3],\n            y: spacing[0],\n            width: chartWidth - spacing[3] - spacing[1],\n            height: chartHeight - spacing[0] - spacing[2]\n        };\n        chart.plotBox = renderer.plotBox = {\n            x: plotLeft,\n            y: plotTop,\n            width: plotWidth,\n            height: plotHeight\n        };\n\n        plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);\n        clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2);\n        clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);\n        chart.clipBox = {\n            x: clipX, \n            y: clipY, \n            width: Math.floor(chart.plotSizeX - Math.max(plotBorderWidth, clipOffset[1]) / 2 - clipX), \n            height: Math.max(0, Math.floor(chart.plotSizeY - Math.max(plotBorderWidth, clipOffset[2]) / 2 - clipY))\n        };\n\n        if (!skipAxes) {\n            each(chart.axes, function (axis) {\n                axis.setAxisSize();\n                axis.setAxisTranslation();\n            });\n        }\n    },\n\n    /**\n     * Initial margins before auto size margins are applied\n     */\n    resetMargins: function () {\n        var chart = this;\n\n        each(marginNames, function (m, side) {\n            chart[m] = pick(chart.margin[side], chart.spacing[side]);\n        });\n        chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n        chart.clipOffset = [0, 0, 0, 0];\n    },\n\n    /**\n     * Draw the borders and backgrounds for chart and plot area\n     */\n    drawChartBox: function () {\n        var chart = this,\n            optionsChart = chart.options.chart,\n            renderer = chart.renderer,\n            chartWidth = chart.chartWidth,\n            chartHeight = chart.chartHeight,\n            chartBackground = chart.chartBackground,\n            plotBackground = chart.plotBackground,\n            plotBorder = chart.plotBorder,\n            chartBorderWidth,\n            ";
if (build.classic) { 
s += "\n            plotBGImage = chart.plotBGImage,\n            chartBackgroundColor = optionsChart.backgroundColor,\n            plotBackgroundColor = optionsChart.plotBackgroundColor,\n            plotBackgroundImage = optionsChart.plotBackgroundImage,\n            ";
} 
s += "\n            mgn,\n            bgAttr,\n            plotLeft = chart.plotLeft,\n            plotTop = chart.plotTop,\n            plotWidth = chart.plotWidth,\n            plotHeight = chart.plotHeight,\n            plotBox = chart.plotBox,\n            clipRect = chart.clipRect,\n            clipBox = chart.clipBox,\n            verb = 'animate';\n\n        // Chart area\n        if (!chartBackground) {\n            chart.chartBackground = chartBackground = renderer.rect()\n                .addClass('highcharts-background')\n                .add();\n            verb = 'attr';\n        }\n\n        ";
if (build.classic) { 
s += "\n        // Presentational\n        chartBorderWidth = optionsChart.borderWidth || 0;\n        mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);\n\n        bgAttr = {\n            fill: chartBackgroundColor || 'none'\n        };\n\n        if (chartBorderWidth) { // #980\n            bgAttr.stroke = optionsChart.borderColor;\n            bgAttr['stroke-width'] = chartBorderWidth;\n        }\n        chartBackground\n            .attr(bgAttr)\n            .shadow(optionsChart.shadow);\n        ";
} 
s += "\n\n        chartBorderWidth = mgn = chartBackground.strokeWidth();\n        chartBackground[verb]({\n            x: mgn / 2,\n            y: mgn / 2,\n            width: chartWidth - mgn - chartBorderWidth % 2,\n            height: chartHeight - mgn - chartBorderWidth % 2,\n            r: optionsChart.borderRadius\n        });\n\n        // Plot background\n        verb = 'animate';\n        if (!plotBackground) {\n            verb = 'attr';\n            chart.plotBackground = plotBackground = renderer.rect()\n                .addClass('highcharts-plot-background')\n                .add();\n        }\n        plotBackground[verb](plotBox);\n\n        ";
if (build.classic) { 
s += "\n        // Presentational attributes for the background\n        plotBackground\n            .attr({\n                fill: plotBackgroundColor || 'none'\n            })\n            .shadow(optionsChart.plotShadow);\n        \n        // Create the background image\n        if (plotBackgroundImage) {\n            if (!plotBGImage) {\n                chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)\n                    .add();\n            } else {\n                plotBGImage.animate(plotBox);\n            }\n        }\n        ";
} 
s += "\n        \n        // Plot clip\n        if (!clipRect) {\n            chart.clipRect = renderer.clipRect(clipBox);\n        } else {\n            clipRect.animate({\n                width: clipBox.width,\n                height: clipBox.height\n            });\n        }\n\n        // Plot area border\n        verb = 'animate';\n        if (!plotBorder) {\n            verb = 'attr';\n            chart.plotBorder = plotBorder = renderer.rect()\n                .addClass('highcharts-plot-border')\n                .attr({\n                    zIndex: 1 // Above the grid\n                })\n                .add();\n        }\n\n        ";
if (build.classic) { 
s += "\n        // Presentational\n        plotBorder.attr({\n            stroke: optionsChart.plotBorderColor,\n            'stroke-width': optionsChart.plotBorderWidth || 0,\n            fill: 'none'\n        });\n        ";
} 
s += "\n\n        plotBorder[verb](plotBorder.crisp({\n            x: plotLeft,\n            y: plotTop,\n            width: plotWidth,\n            height: plotHeight\n        }, -plotBorder.strokeWidth())); //#3282 plotBorder should be negative;\n\n        // reset\n        chart.isDirtyBox = false;\n    },\n\n    /**\n     * Detect whether a certain chart property is needed based on inspecting its options\n     * and series. This mainly applies to the chart.invert property, and in extensions to\n     * the chart.angular and chart.polar properties.\n     */\n    propFromSeries: function () {\n        var chart = this,\n            optionsChart = chart.options.chart,\n            klass,\n            seriesOptions = chart.options.series,\n            i,\n            value;\n\n\n        each(['inverted', 'angular', 'polar'], function (key) {\n\n            // The default series type's class\n            klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];\n\n            // Get the value from available chart-wide properties\n            value = (\n                chart[key] || // 1. it is set before\n                optionsChart[key] || // 2. it is set in the options\n                (klass && klass.prototype[key]) // 3. it's default series class requires it\n            );\n\n            // 4. Check if any the chart's series require it\n            i = seriesOptions && seriesOptions.length;\n            while (!value && i--) {\n                klass = seriesTypes[seriesOptions[i].type];\n                if (klass && klass.prototype[key]) {\n                    value = true;\n                }\n            }\n\n            // Set the chart property\n            chart[key] = value;\n        });\n\n    },\n\n    /**\n     * Link two or more series together. This is done initially from Chart.render,\n     * and after Chart.addSeries and Series.remove.\n     */\n    linkSeries: function () {\n        var chart = this,\n            chartSeries = chart.series;\n\n        // Reset links\n        each(chartSeries, function (series) {\n            series.linkedSeries.length = 0;\n        });\n\n        // Apply new links\n        each(chartSeries, function (series) {\n            var linkedTo = series.options.linkedTo;\n            if (isString(linkedTo)) {\n                if (linkedTo === ':previous') {\n                    linkedTo = chart.series[series.index - 1];\n                } else {\n                    linkedTo = chart.get(linkedTo);\n                }\n                if (linkedTo) {\n                    linkedTo.linkedSeries.push(series);\n                    series.linkedParent = linkedTo;\n                    series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible); // #3879\n                }\n            }\n        });\n    },\n\n    /**\n     * Render series for the chart\n     */\n    renderSeries: function () {\n        each(this.series, function (serie) {\n            serie.translate();\n            serie.render();\n        });\n    },\n\n    /**\n     * Render labels for the chart\n     */\n    renderLabels: function () {\n        var chart = this,\n            labels = chart.options.labels;\n        if (labels.items) {\n            each(labels.items, function (label) {\n                var style = extend(labels.style, label.style),\n                    x = pInt(style.left) + chart.plotLeft,\n                    y = pInt(style.top) + chart.plotTop + 12;\n\n                // delete to prevent rewriting in IE\n                delete style.left;\n                delete style.top;\n\n                chart.renderer.text(\n                    label.html,\n                    x,\n                    y\n                )\n                .attr({ zIndex: 2 })\n                .css(style)\n                .add();\n\n            });\n        }\n    },\n\n    /**\n     * Render all graphics for the chart\n     */\n    render: function () {\n        var chart = this,\n            axes = chart.axes,\n            renderer = chart.renderer,\n            options = chart.options,\n            tempWidth,\n            tempHeight,\n            redoHorizontal,\n            redoVertical;\n\n        // Title\n        chart.setTitle();\n\n\n        // Legend\n        chart.legend = new Legend(chart, options.legend);\n\n        // Get stacks\n        if (chart.getStacks) {\n            chart.getStacks();\n        }\n\n        // Get chart margins\n        chart.getMargins(true);\n        chart.setChartSize();\n\n        // Record preliminary dimensions for later comparison\n        tempWidth = chart.plotWidth;\n        tempHeight = chart.plotHeight = chart.plotHeight - 21; // 21 is the most common correction for X axis labels\n\n        // Get margins by pre-rendering axes\n        each(axes, function (axis) {\n            axis.setScale();\n        });\n        chart.getAxisMargins();\n\n        // If the plot area size has changed significantly, calculate tick positions again\n        redoHorizontal = tempWidth / chart.plotWidth > 1.1;\n        redoVertical = tempHeight / chart.plotHeight > 1.05; // Height is more sensitive\n\n        if (redoHorizontal || redoVertical) {\n\n            chart.maxTicks = null; // reset for second pass\n            each(axes, function (axis) {\n                if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {\n                    axis.setTickInterval(true); // update to reflect the new margins\n                }\n            });\n            chart.getMargins(); // second pass to check for new labels\n        }\n\n        // Draw the borders and backgrounds\n        chart.drawChartBox();\n\n\n        // Axes\n        if (chart.hasCartesianSeries) {\n            each(axes, function (axis) {\n                if (axis.visible) {\n                    axis.render();\n                }\n            });\n        }\n\n        // The series\n        if (!chart.seriesGroup) {\n            chart.seriesGroup = renderer.g('series-group')\n                .attr({ zIndex: 3 })\n                .add();\n        }\n        chart.renderSeries();\n\n        // Labels\n        chart.renderLabels();\n\n        // Credits\n        chart.addCredits();\n\n        // Set flag\n        chart.hasRendered = true;\n\n    },\n\n    /**\n     * Show chart credits based on config options\n     */\n    addCredits: function (credits) { // docs. credits/credits-update example\n        var chart = this;\n\n        credits = merge(true, this.options.credits, credits);\n        if (credits.enabled && !this.credits) {\n            this.credits = this.renderer.text(\n                credits.text,\n                0,\n                0\n            )\n            .addClass('highcharts-credits')\n            .on('click', function () {\n                if (credits.href) {\n                    win.location.href = credits.href;\n                }\n            })\n            .attr({\n                align: credits.position.align,\n                zIndex: 8\n            })\n            ";
if (build.classic) { 
s += "\n            .css(credits.style)\n            ";
} 
s += "\n            .add()\n            .align(credits.position);\n\n            // Dynamically update\n            this.credits.update = function (options) { // docs. credits/credits-update example\n                chart.credits = chart.credits.destroy();\n                chart.addCredits(options);\n            };\n        }\n    },\n\n    /**\n     * Clean up memory usage\n     */\n    destroy: function () {\n        var chart = this,\n            axes = chart.axes,\n            series = chart.series,\n            container = chart.container,\n            i,\n            parentNode = container && container.parentNode;\n\n        // fire the chart.destoy event\n        fireEvent(chart, 'destroy');\n\n        // Delete the chart from charts lookup array\n        charts[chart.index] = undefined;\n        H.chartCount--;\n        chart.renderTo.removeAttribute('data-highcharts-chart');\n\n        // remove events\n        removeEvent(chart);\n\n        // ==== Destroy collections:\n        // Destroy axes\n        i = axes.length;\n        while (i--) {\n            axes[i] = axes[i].destroy();\n        }\n\n        // Destroy each series\n        i = series.length;\n        while (i--) {\n            series[i] = series[i].destroy();\n        }\n\n        // ==== Destroy chart properties:\n        each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage',\n                'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller',\n                'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {\n            var prop = chart[name];\n\n            if (prop && prop.destroy) {\n                chart[name] = prop.destroy();\n            }\n        });\n\n        // remove container and all SVG\n        if (container) { // can break in IE when destroyed before finished loading\n            container.innerHTML = '';\n            removeEvent(container);\n            if (parentNode) {\n                discardElement(container);\n            }\n\n        }\n\n        // clean it all up\n        for (i in chart) {\n            delete chart[i];\n        }\n\n    },\n\n\n    /**\n     * VML namespaces can't be added until after complete. Listening\n     * for Perini's doScroll hack is not enough.\n     */\n    isReadyToRender: function () {\n        var chart = this;\n\n        // Note: win == win.top is required\n        if ((!svg && (win == win.top && win.readyState !== 'complete')) || (useCanVG && !win.canvg)) { // eslint-disable-line eqeqeq\n            if (useCanVG) {\n                // Delay rendering until canvg library is downloaded and ready\n                CanVGController.push(function () {\n                    chart.firstRender();\n                }, chart.options.global.canvasToolsURL);\n            } else {\n                doc.attachEvent('onreadystatechange', function () {\n                    doc.detachEvent('onreadystatechange', chart.firstRender);\n                    if (doc.readyState === 'complete') {\n                        chart.firstRender();\n                    }\n                });\n            }\n            return false;\n        }\n        return true;\n    },\n\n    /**\n     * Prepare for first rendering after all data are loaded\n     */\n    firstRender: function () {\n        var chart = this,\n            options = chart.options;\n\n        // Check whether the chart is ready to render\n        if (!chart.isReadyToRender()) {\n            return;\n        }\n\n        // Create the container\n        chart.getContainer();\n\n        // Run an early event after the container and renderer are established\n        fireEvent(chart, 'init');\n\n\n        chart.resetMargins();\n        chart.setChartSize();\n\n        // Set the common chart properties (mainly invert) from the given series\n        chart.propFromSeries();\n\n        // get axes\n        chart.getAxes();\n\n        // Initialize the series\n        each(options.series || [], function (serieOptions) {\n            chart.initSeries(serieOptions);\n        });\n\n        chart.linkSeries();\n\n        // Run an event after axes and series are initialized, but before render. At this stage,\n        // the series data is indexed and cached in the xData and yData arrays, so we can access\n        // those before rendering. Used in Highstock.\n        fireEvent(chart, 'beforeRender');\n\n        // depends on inverted and on margins being set\n        if (Pointer) {\n            chart.pointer = new Pointer(chart, options);\n        }\n\n        chart.render();\n\n        // add canvas\n        chart.renderer.draw();\n        \n        // Fire the load event if there are no external images\n        if (!chart.renderer.imgCount && chart.onload) {\n            chart.onload();\n        }\n\n        // If the chart was rendered outside the top container, put it back in (#3679)\n        chart.cloneRenderTo(true);\n\n    },\n\n    /** \n     * On chart load\n     */\n    onload: function () {\n        var chart = this;\n\n        // Run callbacks\n        each([this.callback].concat(this.callbacks), function (fn) {\n            if (fn && chart.index !== undefined) { // Chart destroyed in its own callback (#3600)\n                fn.apply(chart, [chart]);\n            }\n        });\n\n        fireEvent(chart, 'load');\n\n        // Don't run again\n        this.onload = null;\n    },\n\n    /**\n    * Creates arrays for spacing and margin from given options.\n    */\n    splashArray: function (target, options) {\n        var oVar = options[target],\n            tArray = H.isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];\n\n        return [pick(options[target + 'Top'], tArray[0]),\n                pick(options[target + 'Right'], tArray[1]),\n                pick(options[target + 'Bottom'], tArray[2]),\n                pick(options[target + 'Left'], tArray[3])];\n    }\n}; // end Chart\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var pick = H.pick,\n        relativeLength = H.relativeLength;\n\nH.CenteredSeriesMixin = {\n    /**\n     * Get the center of the pie based on the size and center options relative to the\n     * plot area. Borrowed by the polar and gauge series types.\n     */\n    getCenter: function () {\n\n        var options = this.options,\n            chart = this.chart,\n            slicingRoom = 2 * (options.slicedOffset || 0),\n            handleSlicingRoom,\n            plotWidth = chart.plotWidth - 2 * slicingRoom,\n            plotHeight = chart.plotHeight - 2 * slicingRoom,\n            centerOption = options.center,\n            positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],\n            smallestSize = Math.min(plotWidth, plotHeight),\n            i,\n            value;\n\n        for (i = 0; i < 4; ++i) {\n            value = positions[i];\n            handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));\n\n            // i == 0: centerX, relative to width\n            // i == 1: centerY, relative to height\n            // i == 2: size, relative to smallestSize\n            // i == 3: innerSize, relative to size\n            positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +\n                (handleSlicingRoom ? slicingRoom : 0);\n\n        }\n        // innerSize cannot be larger than size (#3632)\n        if (positions[3] > positions[2]) {\n            positions[3] = positions[2];\n        }\n        return positions;\n    }\n};\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var Point,\n\n        each = H.each,\n        extend = H.extend,\n        erase = H.erase,\n        fireEvent = H.fireEvent,\n        format = H.format,\n        isArray = H.isArray,\n        isNumber = H.isNumber,\n        pick = H.pick,\n        removeEvent = H.removeEvent;\n\n/**\n * The Point object and prototype. Inheritable and used as base for PiePoint\n */\nPoint = H.Point = function () {};\nPoint.prototype = {\n\n    /**\n     * Initialize the point\n     * @param {Object} series The series object containing this point\n     * @param {Object} options The data in either number, array or object format\n     */\n    init: function (series, options, x) {\n\n        var point = this,\n            colors,\n            colorCount = series.chart.colorCount;\n\n        point.series = series;\n        ";
if (build.classic) { 
s += "\n        point.color = series.color; // #3445\n        ";
} 
s += "\n        point.applyOptions(options, x);\n\n        if (series.options.colorByPoint) {\n            ";
if (build.classic) { 
s += "\n            colors = series.options.colors || series.chart.options.colors;\n            point.color = point.color || colors[series.colorCounter];\n            colorCount = colors.length;\n            ";
} 
s += "\n            point.colorIndex = series.colorCounter;\n            series.colorCounter++;\n            // loop back to zero\n            if (series.colorCounter === colorCount) {\n                series.colorCounter = 0;\n            }\n        } else {\n            point.colorIndex = series.colorIndex;\n        }\n\n        series.chart.pointCount++;\n        return point;\n    },\n    /**\n     * Apply the options containing the x and y data and possible some extra properties.\n     * This is called on point init or from point.update.\n     *\n     * @param {Object} options\n     */\n    applyOptions: function (options, x) {\n        var point = this,\n            series = point.series,\n            pointValKey = series.options.pointValKey || series.pointValKey;\n\n        options = Point.prototype.optionsToObject.call(this, options);\n\n        // copy options directly to point\n        extend(point, options);\n        point.options = point.options ? extend(point.options, options) : options;\n\n        // For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.\n        if (pointValKey) {\n            point.y = point[pointValKey];\n        }\n        point.isNull = point.x === null || point.y === null;\n\n        // If no x is set by now, get auto incremented value. All points must have an\n        // x value, however the y value can be null to create a gap in the series\n        if (point.x === undefined && series) {\n            point.x = x === undefined ? series.autoIncrement() : x;\n        }\n\n        return point;\n    },\n\n    /**\n     * Transform number or array configs into objects\n     */\n    optionsToObject: function (options) {\n        var ret = {},\n            series = this.series,\n            keys = series.options.keys,\n            pointArrayMap = keys || series.pointArrayMap || ['y'],\n            valueCount = pointArrayMap.length,\n            firstItemType,\n            i = 0,\n            j = 0;\n\n        if (isNumber(options) || options === null) {\n            ret[pointArrayMap[0]] = options;\n\n        } else if (isArray(options)) {\n            // with leading x value\n            if (!keys && options.length > valueCount) {\n                firstItemType = typeof options[0];\n                if (firstItemType === 'string') {\n                    ret.name = options[0];\n                } else if (firstItemType === 'number') {\n                    ret.x = options[0];\n                }\n                i++;\n            }\n            while (j < valueCount) {\n                if (!keys || options[i] !== undefined) { // Skip undefined positions for keys\n                    ret[pointArrayMap[j]] = options[i];\n                }\n                i++;\n                j++;\n            }\n        } else if (typeof options === 'object') {\n            ret = options;\n\n            // This is the fastest way to detect if there are individual point dataLabels that need\n            // to be considered in drawDataLabels. These can only occur in object configs.\n            if (options.dataLabels) {\n                series._hasPointLabels = true;\n            }\n\n            // Same approach as above for markers\n            if (options.marker) {\n                series._hasPointMarkers = true;\n            }\n        }\n        return ret;\n    },\n\n    /**\n     * Get the CSS class names for individual points\n     * @returns {String} The class name\n     */\n    getClassName: function () {\n        return 'highcharts-point' + \n            (this.selected ? ' highcharts-point-select' : '') + \n            (this.negative ? ' highcharts-negative' : '') + \n            (this.colorIndex !== undefined ? ' highcharts-color-' + this.colorIndex : '') +\n            (this.options.className ? ' ' + this.options.className : ''); // docs\n    },\n\n    /**\n     * Return the zone that the point belongs to\n     */\n    getZone: function () {\n        var series = this.series,\n            zones = series.zones,\n            zoneAxis = series.zoneAxis || 'y',\n            i = 0,\n            zone;\n\n        zone = zones[i];\n        while (this[zoneAxis] >= zone.value) {                \n            zone = zones[++i];\n        }\n\n        if (zone && zone.color && !this.options.color) {\n            this.color = zone.color;\n        }\n\n        return zone;\n    },\n\n    /**\n     * Destroy a point to clear memory. Its reference still stays in series.data.\n     */\n    destroy: function () {\n        var point = this,\n            series = point.series,\n            chart = series.chart,\n            hoverPoints = chart.hoverPoints,\n            prop;\n\n        chart.pointCount--;\n\n        if (hoverPoints) {\n            point.setState();\n            erase(hoverPoints, point);\n            if (!hoverPoints.length) {\n                chart.hoverPoints = null;\n            }\n\n        }\n        if (point === chart.hoverPoint) {\n            point.onMouseOut();\n        }\n\n        // remove all events\n        if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive\n            removeEvent(point);\n            point.destroyElements();\n        }\n\n        if (point.legendItem) { // pies have legend items\n            chart.legend.destroyItem(point);\n        }\n\n        for (prop in point) {\n            point[prop] = null;\n        }\n\n\n    },\n\n    /**\n     * Destroy SVG elements associated with the point\n     */\n    destroyElements: function () {\n        var point = this,\n            props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],\n            prop,\n            i = 6;\n        while (i--) {\n            prop = props[i];\n            if (point[prop]) {\n                point[prop] = point[prop].destroy();\n            }\n        }\n    },\n\n    /**\n     * Return the configuration hash needed for the data label and tooltip formatters\n     */\n    getLabelConfig: function () {\n        return {\n            x: this.category,\n            y: this.y,\n            color: this.color,\n            key: this.name || this.category,\n            series: this.series,\n            point: this,\n            percentage: this.percentage,\n            total: this.total || this.stackTotal\n        };\n    },\n\n    /**\n     * Extendable method for formatting each point's tooltip line\n     *\n     * @return {String} A string to be concatenated in to the common tooltip text\n     */\n    tooltipFormatter: function (pointFormat) {\n\n        // Insert options for valueDecimals, valuePrefix, and valueSuffix\n        var series = this.series,\n            seriesTooltipOptions = series.tooltipOptions,\n            valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n            valuePrefix = seriesTooltipOptions.valuePrefix || '',\n            valueSuffix = seriesTooltipOptions.valueSuffix || '';\n\n        // Loop over the point array map and replace unformatted values with sprintf formatting markup\n        each(series.pointArrayMap || ['y'], function (key) {\n            key = '{point.' + key; // without the closing bracket\n            if (valuePrefix || valueSuffix) {\n                pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);\n            }\n            pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');\n        });\n\n        return format(pointFormat, {\n            point: this,\n            series: this.series\n        });\n    },\n\n    /**\n     * Fire an event on the Point object.\n     * @param {String} eventType\n     * @param {Object} eventArgs Additional event arguments\n     * @param {Function} defaultFunction Default event handler\n     */\n    firePointEvent: function (eventType, eventArgs, defaultFunction) {\n        var point = this,\n            series = this.series,\n            seriesOptions = series.options;\n\n        // load event handlers on demand to save time on mouseover/out\n        if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {\n            this.importEvents();\n        }\n\n        // add default handler if in selection mode\n        if (eventType === 'click' && seriesOptions.allowPointSelect) {\n            defaultFunction = function (event) {\n                // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera\n                if (point.select) { // Could be destroyed by prior event handlers (#2911)\n                    point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n                }\n            };\n        }\n\n        fireEvent(this, eventType, eventArgs, defaultFunction);\n    },\n    visible: true\n};\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var addEvent = H.addEvent,\n        animObject = H.animObject,\n        arrayMax = H.arrayMax,\n        arrayMin = H.arrayMin,\n        correctFloat = H.correctFloat,\n        Date = H.Date,\n        defaultOptions = H.defaultOptions,\n        defaultPlotOptions = H.defaultPlotOptions,\n        defined = H.defined,\n        each = H.each,\n        erase = H.erase,\n        error = H.error,\n        extend = H.extend,\n        fireEvent = H.fireEvent,\n        grep = H.grep,\n        isArray = H.isArray,\n        isNumber = H.isNumber,\n        isObject = H.isObject,\n        isString = H.isString,\n        LegendSymbolMixin = H.LegendSymbolMixin, // @todo add as a requirement\n        merge = H.merge,\n        pick = H.pick,\n        Point = H.Point, // @todo  add as a requirement\n        removeEvent = H.removeEvent,\n        splat = H.splat,\n        stableSort = H.stableSort,\n        SVGElement = H.SVGElement,\n        syncTimeout = H.syncTimeout,\n        useCanVG = H.useCanVG,\n        win = H.win;\n\n/**\n * @classDescription The base function which all other series types inherit from. The data in the series is stored\n * in various arrays.\n *\n * - First, series.options.data contains all the original config options for\n * each point whether added by options or methods like series.addPoint.\n * - Next, series.data contains those values converted to points, but in case the series data length\n * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It\n * only contains the points that have been created on demand.\n * - Then there's series.points that contains all currently visible point objects. In case of cropping,\n * the cropped-away points are not part of this array. The series.points array starts at series.cropStart\n * compared to series.data and series.options.data. If however the series data is grouped, these can't\n * be correlated one to one.\n * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.\n * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.\n *\n * @param {Object} chart\n * @param {Object} options\n */\nH.Series = function () {}; // @todo return this object\n\nH.Series.prototype = {\n\n    isCartesian: true,\n    type: 'line',\n    pointClass: Point,\n    sorted: true, // requires the data to be sorted\n    requireSorting: true,\n    directTouch: false,\n    axisTypes: ['xAxis', 'yAxis'],\n    colorCounter: 0,\n    parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData\n    init: function (chart, options) {\n        var series = this,\n            eventType,\n            events,\n            chartSeries = chart.series,\n            sortByIndex = function (a, b) {\n                return pick(a.options.index, a._i) - pick(b.options.index, b._i);\n            };\n\n        series.chart = chart;\n        series.options = options = series.setOptions(options); // merge with plotOptions\n        series.linkedSeries = [];\n\n        // bind the axes\n        series.bindAxes();\n\n        // set some variables\n        extend(series, {\n            name: options.name,\n            state: '',\n            visible: options.visible !== false, // true by default\n            selected: options.selected === true // false by default\n        });\n\n        // special\n        if (useCanVG) {\n            options.animation = false;\n        }\n\n        // register event listeners\n        events = options.events;\n        for (eventType in events) {\n            addEvent(series, eventType, events[eventType]);\n        }\n        if (\n            (events && events.click) ||\n            (options.point && options.point.events && options.point.events.click) ||\n            options.allowPointSelect\n        ) {\n            chart.runTrackerClick = true;\n        }\n\n        series.getColor();\n        series.getSymbol();\n\n        // Set the data\n        each(series.parallelArrays, function (key) {\n            series[key + 'Data'] = [];\n        });\n        series.setData(options.data, false);\n\n        // Mark cartesian\n        if (series.isCartesian) {\n            chart.hasCartesianSeries = true;\n        }\n\n        // Register it in the chart\n        chartSeries.push(series);\n        series._i = chartSeries.length - 1;\n\n        // Sort series according to index option (#248, #1123, #2456)\n        stableSort(chartSeries, sortByIndex);\n        if (this.yAxis) {\n            stableSort(this.yAxis.series, sortByIndex);\n        }\n\n        each(chartSeries, function (series, i) {\n            series.index = i;\n            series.name = series.name || 'Series ' + (i + 1);\n        });\n\n    },\n\n    /**\n     * Set the xAxis and yAxis properties of cartesian series, and register the series\n     * in the axis.series array\n     */\n    bindAxes: function () {\n        var series = this,\n            seriesOptions = series.options,\n            chart = series.chart,\n            axisOptions;\n\n        each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis\n\n            each(chart[AXIS], function (axis) { // loop through the chart's axis objects\n                axisOptions = axis.options;\n\n                // apply if the series xAxis or yAxis option mathches the number of the\n                // axis, or if undefined, use the first axis\n                if ((seriesOptions[AXIS] === axisOptions.index) ||\n                        (seriesOptions[AXIS] !== undefined && seriesOptions[AXIS] === axisOptions.id) ||\n                        (seriesOptions[AXIS] === undefined && axisOptions.index === 0)) {\n\n                    // register this series in the axis.series lookup\n                    axis.series.push(series);\n\n                    // set this series.xAxis or series.yAxis reference\n                    series[AXIS] = axis;\n\n                    // mark dirty for redraw\n                    axis.isDirty = true;\n                }\n            });\n\n            // The series needs an X and an Y axis\n            if (!series[AXIS] && series.optionalAxis !== AXIS) {\n                error(18, true);\n            }\n\n        });\n    },\n\n    /**\n     * For simple series types like line and column, the data values are held in arrays like\n     * xData and yData for quick lookup to find extremes and more. For multidimensional series\n     * like bubble and map, this can be extended with arrays like zData and valueData by\n     * adding to the series.parallelArrays array.\n     */\n    updateParallelArrays: function (point, i) {\n        var series = point.series,\n            args = arguments,\n            fn = isNumber(i) ?\n                // Insert the value in the given position\n                function (key) {\n                    var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];\n                    series[key + 'Data'][i] = val;\n                } :\n                // Apply the method specified in i with the following arguments as arguments\n                function (key) {\n                    Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));\n                };\n\n        each(series.parallelArrays, fn);\n    },\n\n    /**\n     * Return an auto incremented x value based on the pointStart and pointInterval options.\n     * This is only used if an x value is not given for the point that calls autoIncrement.\n     */\n    autoIncrement: function () {\n\n        var options = this.options,\n            xIncrement = this.xIncrement,\n            date,\n            pointInterval,\n            pointIntervalUnit = options.pointIntervalUnit;\n\n        xIncrement = pick(xIncrement, options.pointStart, 0);\n\n        this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);\n\n        // Added code for pointInterval strings\n        if (pointIntervalUnit) {\n            date = new Date(xIncrement);\n\n            if (pointIntervalUnit === 'day') {\n                date = +date[Date.hcSetDate](date[Date.hcGetDate]() + pointInterval);\n            } else if (pointIntervalUnit === 'month') {\n                date = +date[Date.hcSetMonth](date[Date.hcGetMonth]() + pointInterval);\n            } else if (pointIntervalUnit === 'year') {\n                date = +date[Date.hcSetFullYear](date[Date.hcGetFullYear]() + pointInterval);\n            }\n            pointInterval = date - xIncrement;\n\n        }\n\n        this.xIncrement = xIncrement + pointInterval;\n        return xIncrement;\n    },\n    \n    /**\n     * Set the series options by merging from the options tree\n     * @param {Object} itemOptions\n     */\n    setOptions: function (itemOptions) {\n        var chart = this.chart,\n            chartOptions = chart.options,\n            plotOptions = chartOptions.plotOptions,\n            userOptions = chart.userOptions || {},\n            userPlotOptions = userOptions.plotOptions || {},\n            typeOptions = plotOptions[this.type],\n            options,\n            zones;\n\n        this.userOptions = itemOptions;\n\n        // General series options take precedence over type options because otherwise, default\n        // type options like column.animation would be overwritten by the general option.\n        // But issues have been raised here (#3881), and the solution may be to distinguish\n        // between default option and userOptions like in the tooltip below.\n        options = merge(\n            typeOptions,\n            plotOptions.series,\n            itemOptions\n        );\n\n        // The tooltip options are merged between global and series specific options\n        this.tooltipOptions = merge(\n            defaultOptions.tooltip,\n            defaultOptions.plotOptions[this.type].tooltip,\n            userOptions.tooltip,\n            userPlotOptions.series && userPlotOptions.series.tooltip,\n            userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,\n            itemOptions.tooltip\n        );\n\n        // Delete marker object if not allowed (#1125)\n        if (typeOptions.marker === null) {\n            delete options.marker;\n        }\n\n        // Handle color zones\n        this.zoneAxis = options.zoneAxis;\n        zones = this.zones = (options.zones || []).slice();\n        if ((options.negativeColor || options.negativeFillColor) && !options.zones) {\n            zones.push({\n                value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,\n                className: 'highcharts-negative',\n                ";
if (build.classic) { 
s += "\n                color: options.negativeColor,\n                fillColor: options.negativeFillColor\n                ";
} 
s += "\n            });\n        }\n        if (zones.length) { // Push one extra zone for the rest\n            if (defined(zones[zones.length - 1].value)) {\n                zones.push({\n                    ";
if (build.classic) { 
s += "\n                    color: this.color,\n                    fillColor: this.fillColor\n                    ";
} 
s += "\n                });\n            }\n        }\n        return options;\n    },\n\n    getCyclic: function (prop, value, defaults) {\n        var i,\n            userOptions = this.userOptions,\n            indexName = prop + 'Index',\n            counterName = prop + 'Counter',\n            len = defaults ? defaults.length : this.chart[prop + 'Count'],\n            setting;\n\n        if (!value) {\n            // Pick up either the colorIndex option, or the _colorIndex after Series.update()\n            setting = pick(userOptions[indexName], userOptions['_' + indexName]);\n            if (defined(setting)) { // after Series.update()\n                i = setting;\n            } else {\n                userOptions['_' + indexName] = i = this.chart[counterName] % len;\n                this.chart[counterName] += 1;\n            }\n            if (defaults) {\n                value = defaults[i];\n            }\n        }\n        // Set the colorIndex\n        if (i !== undefined) {\n            this[indexName] = i;\n        }\n        this[prop] = value;\n    },\n\n    /**\n     * Get the series' color\n     */\n    ";
if (!build.classic) { 
s += "\n    getColor: function () {\n        this.getCyclic('color');\n    },\n\n    ";
} else { 
s += "\n    getColor: function () {\n        if (this.options.colorByPoint) {\n            this.options.color = null; // #4359, selected slice got series.color even when colorByPoint was set.\n        } else {\n            this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);\n        }\n    },\n    ";
} 
s += "\n    /**\n     * Get the series' symbol\n     */\n    getSymbol: function () {\n        var seriesMarkerOption = this.options.marker;\n\n        this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);\n\n        // don't substract radius in image symbols (#604)\n        if (/^url/.test(this.symbol)) {\n            seriesMarkerOption.radius = 0;\n        }\n    },\n\n    drawLegendSymbol: LegendSymbolMixin.drawLineMarker,\n\n    /**\n     * Replace the series data with a new set of data\n     * @param {Object} data\n     * @param {Object} redraw\n     */\n    setData: function (data, redraw, animation, updatePoints) {\n        var series = this,\n            oldData = series.points,\n            oldDataLength = (oldData && oldData.length) || 0,\n            dataLength,\n            options = series.options,\n            chart = series.chart,\n            firstPoint = null,\n            xAxis = series.xAxis,\n            hasCategories = xAxis && !!xAxis.categories,\n            i,\n            turboThreshold = options.turboThreshold,\n            pt,\n            xData = this.xData,\n            yData = this.yData,\n            pointArrayMap = series.pointArrayMap,\n            valueCount = pointArrayMap && pointArrayMap.length;\n\n        data = data || [];\n        dataLength = data.length;\n        redraw = pick(redraw, true);\n\n        // If the point count is the same as is was, just run Point.update which is\n        // cheaper, allows animation, and keeps references to points.\n        if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {\n            each(data, function (point, i) {\n                // .update doesn't exist on a linked, hidden series (#3709)\n                if (oldData[i].update && point !== options.data[i]) {\n                    oldData[i].update(point, false, null, false);\n                }\n            });\n\n        } else {\n\n            // Reset properties\n            series.xIncrement = null;\n\n            series.colorCounter = 0; // for series with colorByPoint (#1547)\n\n            // Update parallel arrays\n            each(this.parallelArrays, function (key) {\n                series[key + 'Data'].length = 0;\n            });\n\n            // In turbo mode, only one- or twodimensional arrays of numbers are allowed. The\n            // first value is tested, and we assume that all the rest are defined the same\n            // way. Although the 'for' loops are similar, they are repeated inside each\n            // if-else conditional for max performance.\n            if (turboThreshold && dataLength > turboThreshold) {\n\n                // find the first non-null point\n                i = 0;\n                while (firstPoint === null && i < dataLength) {\n                    firstPoint = data[i];\n                    i++;\n                }\n\n\n                if (isNumber(firstPoint)) { // assume all points are numbers\n                    var x = pick(options.pointStart, 0),\n                        pointInterval = pick(options.pointInterval, 1);\n\n                    for (i = 0; i < dataLength; i++) {\n                        xData[i] = x;\n                        yData[i] = data[i];\n                        x += pointInterval;\n                    }\n                    series.xIncrement = x;\n                } else if (isArray(firstPoint)) { // assume all points are arrays\n                    if (valueCount) { // [x, low, high] or [x, o, h, l, c]\n                        for (i = 0; i < dataLength; i++) {\n                            pt = data[i];\n                            xData[i] = pt[0];\n                            yData[i] = pt.slice(1, valueCount + 1);\n                        }\n                    } else { // [x, y]\n                        for (i = 0; i < dataLength; i++) {\n                            pt = data[i];\n                            xData[i] = pt[0];\n                            yData[i] = pt[1];\n                        }\n                    }\n                } else {\n                    error(12); // Highcharts expects configs to be numbers or arrays in turbo mode\n                }\n            } else {\n                for (i = 0; i < dataLength; i++) {\n                    if (data[i] !== undefined) { // stray commas in oldIE\n                        pt = { series: series };\n                        series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);\n                        series.updateParallelArrays(pt, i);\n                        if (hasCategories && defined(pt.name)) { // #4401\n                            xAxis.names[pt.x] = pt.name; // #2046\n                        }\n                    }\n                }\n            }\n\n            // Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON\n            if (isString(yData[0])) {\n                error(14, true);\n            }\n\n            series.data = [];\n            series.options.data = series.userOptions.data = data;\n\n            // destroy old points\n            i = oldDataLength;\n            while (i--) {\n                if (oldData[i] && oldData[i].destroy) {\n                    oldData[i].destroy();\n                }\n            }\n\n            // reset minRange (#878)\n            if (xAxis) {\n                xAxis.minRange = xAxis.userMinRange;\n            }\n\n            // redraw\n            series.isDirty = series.isDirtyData = chart.isDirtyBox = true;\n            animation = false;\n        }\n\n        // Typically for pie series, points need to be processed and generated\n        // prior to rendering the legend\n        if (options.legendType === 'point') {\n            this.processData();\n            this.generatePoints();\n        }\n\n        if (redraw) {\n            chart.redraw(animation);\n        }\n    },\n\n    /**\n     * Process the data by cropping away unused data points if the series is longer\n     * than the crop threshold. This saves computing time for lage series.\n     */\n    processData: function (force) {\n        var series = this,\n            processedXData = series.xData, // copied during slice operation below\n            processedYData = series.yData,\n            dataLength = processedXData.length,\n            croppedData,\n            cropStart = 0,\n            cropped,\n            distance,\n            closestPointRange,\n            xAxis = series.xAxis,\n            i, // loop variable\n            options = series.options,\n            cropThreshold = options.cropThreshold,\n            getExtremesFromAll = series.getExtremesFromAll || options.getExtremesFromAll, // #4599\n            isCartesian = series.isCartesian,\n            xExtremes,\n            val2lin = xAxis && xAxis.val2lin,\n            isLog = xAxis && xAxis.isLog,\n            min,\n            max;\n\n        // If the series data or axes haven't changed, don't go through this. Return false to pass\n        // the message on to override methods like in data grouping.\n        if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\n            return false;\n        }\n\n        if (xAxis) {\n            xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)\n            min = xExtremes.min;\n            max = xExtremes.max;\n        }\n\n        // optionally filter out points outside the plot area\n        if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {\n\n            // it's outside current extremes\n            if (processedXData[dataLength - 1] < min || processedXData[0] > max) {\n                processedXData = [];\n                processedYData = [];\n\n            // only crop if it's actually spilling out\n            } else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {\n                croppedData = this.cropData(series.xData, series.yData, min, max);\n                processedXData = croppedData.xData;\n                processedYData = croppedData.yData;\n                cropStart = croppedData.start;\n                cropped = true;\n            }\n        }\n\n\n        // Find the closest distance between processed points\n        i = processedXData.length || 1;\n        while (--i) {\n            distance = isLog ?\n                val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :\n                processedXData[i] - processedXData[i - 1];\n\n            if (distance > 0 && (closestPointRange === undefined || distance < closestPointRange)) {\n                closestPointRange = distance;\n\n            // Unsorted data is not supported by the line tooltip, as well as data grouping and\n            // navigation in Stock charts (#725) and width calculation of columns (#1900)\n            } else if (distance < 0 && series.requireSorting) {\n                error(15);\n            }\n        }\n\n        // Record the properties\n        series.cropped = cropped; // undefined or true\n        series.cropStart = cropStart;\n        series.processedXData = processedXData;\n        series.processedYData = processedYData;\n\n        series.closestPointRange = closestPointRange;\n\n    },\n\n    /**\n     * Iterate over xData and crop values between min and max. Returns object containing crop start/end\n     * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range\n     */\n    cropData: function (xData, yData, min, max) {\n        var dataLength = xData.length,\n            cropStart = 0,\n            cropEnd = dataLength,\n            cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside\n            i,\n            j;\n\n        // iterate up to find slice start\n        for (i = 0; i < dataLength; i++) {\n            if (xData[i] >= min) {\n                cropStart = Math.max(0, i - cropShoulder);\n                break;\n            }\n        }\n\n        // proceed to find slice end\n        for (j = i; j < dataLength; j++) {\n            if (xData[j] > max) {\n                cropEnd = j + cropShoulder;\n                break;\n            }\n        }\n\n        return {\n            xData: xData.slice(cropStart, cropEnd),\n            yData: yData.slice(cropStart, cropEnd),\n            start: cropStart,\n            end: cropEnd\n        };\n    },\n\n\n    /**\n     * Generate the data point after the data has been processed by cropping away\n     * unused points and optionally grouped in Highcharts Stock.\n     */\n    generatePoints: function () {\n        var series = this,\n            options = series.options,\n            dataOptions = options.data,\n            data = series.data,\n            dataLength,\n            processedXData = series.processedXData,\n            processedYData = series.processedYData,\n            pointClass = series.pointClass,\n            processedDataLength = processedXData.length,\n            cropStart = series.cropStart || 0,\n            cursor,\n            hasGroupedData = series.hasGroupedData,\n            point,\n            points = [],\n            i;\n\n        if (!data && !hasGroupedData) {\n            var arr = [];\n            arr.length = dataOptions.length;\n            data = series.data = arr;\n        }\n\n        for (i = 0; i < processedDataLength; i++) {\n            cursor = cropStart + i;\n            if (!hasGroupedData) {\n                if (data[cursor]) {\n                    point = data[cursor];\n                } else if (dataOptions[cursor] !== undefined) { // #970\n                    data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);\n                }\n                points[i] = point;\n            } else {\n                // splat the y data in case of ohlc data array\n                points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));\n                points[i].dataGroup = series.groupMap[i];\n            }\n            points[i].index = cursor; // For faster access in Point.update\n        }\n\n        // Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when\n        // swithching view from non-grouped data to grouped data (#637)\n        if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {\n            for (i = 0; i < dataLength; i++) {\n                if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points\n                    i += processedDataLength;\n                }\n                if (data[i]) {\n                    data[i].destroyElements();\n                    data[i].plotX = undefined; // #1003\n                }\n            }\n        }\n\n        series.data = data;\n        series.points = points;\n    },\n\n    /**\n     * Calculate Y extremes for visible data\n     */\n    getExtremes: function (yData) {\n        var xAxis = this.xAxis,\n            yAxis = this.yAxis,\n            xData = this.processedXData,\n            yDataLength,\n            activeYData = [],\n            activeCounter = 0,\n            xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis\n            xMin = xExtremes.min,\n            xMax = xExtremes.max,\n            validValue,\n            withinRange,\n            x,\n            y,\n            i,\n            j;\n\n        yData = yData || this.stackedYData || this.processedYData || [];\n        yDataLength = yData.length;\n\n        for (i = 0; i < yDataLength; i++) {\n\n            x = xData[i];\n            y = yData[i];\n\n            // For points within the visible range, including the first point outside the\n            // visible range, consider y extremes\n            validValue = y !== null && y !== undefined && (!yAxis.isLog || (y.length || y > 0));\n            withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped ||\n                ((xData[i + 1] || x) >= xMin &&    (xData[i - 1] || x) <= xMax);\n\n            if (validValue && withinRange) {\n\n                j = y.length;\n                if (j) { // array, like ohlc or range data\n                    while (j--) {\n                        if (y[j] !== null) {\n                            activeYData[activeCounter++] = y[j];\n                        }\n                    }\n                } else {\n                    activeYData[activeCounter++] = y;\n                }\n            }\n        }\n        this.dataMin = arrayMin(activeYData);\n        this.dataMax = arrayMax(activeYData);\n    },\n\n    /**\n     * Translate data points from raw data values to chart specific positioning data\n     * needed later in drawPoints, drawGraph and drawTracker.\n     */\n    translate: function () {\n        if (!this.processedXData) { // hidden series\n            this.processData();\n        }\n        this.generatePoints();\n        var series = this,\n            options = series.options,\n            stacking = options.stacking,\n            xAxis = series.xAxis,\n            categories = xAxis.categories,\n            yAxis = series.yAxis,\n            points = series.points,\n            dataLength = points.length,\n            hasModifyValue = !!series.modifyValue,\n            i,\n            pointPlacement = options.pointPlacement,\n            dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),\n            threshold = options.threshold,\n            stackThreshold = options.startFromThreshold ? threshold : 0,\n            plotX,\n            plotY,\n            lastPlotX,\n            stackIndicator,\n            closestPointRangePx = Number.MAX_VALUE;\n\n        // Translate each point\n        for (i = 0; i < dataLength; i++) {\n            var point = points[i],\n                xValue = point.x,\n                yValue = point.y,\n                yBottom = point.low,\n                stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],\n                pointStack,\n                stackValues;\n\n            // Discard disallowed y values for log axes (#3434)\n            if (yAxis.isLog && yValue !== null && yValue <= 0) {\n                point.y = yValue = null;\n                error(10);\n            }\n\n            // Get the plotX translation\n            point.plotX = plotX = correctFloat( // #5236\n                Math.min(Math.max(-1e5, xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')), 1e5) // #3923\n            );\n\n            // Calculate the bottom y value for stacked series\n            if (stacking && series.visible && !point.isNull && stack && stack[xValue]) {\n                stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);\n                pointStack = stack[xValue];\n                stackValues = pointStack.points[stackIndicator.key];\n                yBottom = stackValues[0];\n                yValue = stackValues[1];\n\n                if (yBottom === stackThreshold && stackIndicator.key === stack[xValue].base) {\n                    yBottom = pick(threshold, yAxis.min);\n                }\n                if (yAxis.isLog && yBottom <= 0) { // #1200, #1232\n                    yBottom = null;\n                }\n\n                point.total = point.stackTotal = pointStack.total;\n                point.percentage = pointStack.total && (point.y / pointStack.total * 100);\n                point.stackY = yValue;\n\n                // Place the stack label\n                pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);\n\n            }\n\n            // Set translated yBottom or remove it\n            point.yBottom = defined(yBottom) ?\n                yAxis.translate(yBottom, 0, 1, 0, 1) :\n                null;\n\n            // general hook, used for Highstock compare mode\n            if (hasModifyValue) {\n                yValue = series.modifyValue(yValue, point);\n            }\n\n            // Set the the plotY value, reset it for redraws\n            point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?\n                Math.min(Math.max(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201\n                undefined;\n            point.isInside = plotY !== undefined && plotY >= 0 && plotY <= yAxis.len && // #3519\n                plotX >= 0 && plotX <= xAxis.len;\n\n\n            // Set client related positions for mouse tracking\n            point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514\n\n            point.negative = point.y < (threshold || 0);\n\n            // some API data\n            point.category = categories && categories[point.x] !== undefined ?\n                categories[point.x] : point.x;\n\n            // Determine auto enabling of markers (#3635, #5099)\n            if (!point.isNull) {\n                if (lastPlotX !== undefined) {\n                    closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));\n                }\n                lastPlotX = plotX;\n            }\n\n        }\n        series.closestPointRangePx = closestPointRangePx;\n    },\n\n    /**\n     * Return the series points with null points filtered out\n     */\n    getValidPoints: function (points, insideOnly) {\n        var chart = this.chart;\n        return grep(points || this.points || [], function isValidPoint(point) { // #3916, #5029\n            if (insideOnly && !chart.isInsidePlot(point.plotX, point.plotY, chart.inverted)) { // #5085\n                return false;\n            }\n            return !point.isNull;\n        });\n    },\n\n    /**\n     * Set the clipping for the series. For animated series it is called twice, first to initiate\n     * animating the clip then the second time without the animation to set the final clip.\n     */\n    setClip: function (animation) {\n        var chart = this.chart,\n            options = this.options,\n            renderer = chart.renderer,\n            inverted = chart.inverted,\n            seriesClipBox = this.clipBox,\n            clipBox = seriesClipBox || chart.clipBox,\n            sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height, options.xAxis, options.yAxis].join(','), // #4526\n            clipRect = chart[sharedClipKey],\n            markerClipRect = chart[sharedClipKey + 'm'];\n\n        // If a clipping rectangle with the same properties is currently present in the chart, use that.\n        if (!clipRect) {\n\n            // When animation is set, prepare the initial positions\n            if (animation) {\n                clipBox.width = 0;\n\n                chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(\n                    -99, // include the width of the first marker\n                    inverted ? -chart.plotLeft : -chart.plotTop,\n                    99,\n                    inverted ? chart.chartWidth : chart.chartHeight\n                );\n            }\n            chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);\n\n        }\n        if (animation) {\n            clipRect.count += 1;\n        }\n\n        if (options.clip !== false) {\n            this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);\n            this.markerGroup.clip(markerClipRect);\n            this.sharedClipKey = sharedClipKey;\n        }\n\n        // Remove the shared clipping rectangle when all series are shown\n        if (!animation) {\n            clipRect.count -= 1;\n            if (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {\n                if (!seriesClipBox) {\n                    chart[sharedClipKey] = chart[sharedClipKey].destroy();\n                }\n                if (chart[sharedClipKey + 'm']) {\n                    chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();\n                }\n            }\n        }\n    },\n\n    /**\n     * Animate in the series\n     */\n    animate: function (init) {\n        var series = this,\n            chart = series.chart,\n            clipRect,\n            animation = series.options.animation,\n            sharedClipKey;\n\n        // Animation option is set to true\n        if (animation && !isObject(animation)) {\n            animation = defaultPlotOptions[series.type].animation;\n        }\n\n        // Initialize the animation. Set up the clipping rectangle.\n        if (init) {\n\n            series.setClip(animation);\n\n        // Run the animation\n        } else {\n            sharedClipKey = this.sharedClipKey;\n            clipRect = chart[sharedClipKey];\n            if (clipRect) {\n                clipRect.animate({\n                    width: chart.plotSizeX\n                }, animation);\n            }\n            if (chart[sharedClipKey + 'm']) {\n                chart[sharedClipKey + 'm'].animate({\n                    width: chart.plotSizeX + 99\n                }, animation);\n            }\n\n            // Delete this function to allow it only once\n            series.animate = null;\n\n        }\n    },\n\n    /**\n     * This runs after animation to land on the final plot clipping\n     */\n    afterAnimate: function () {\n        this.setClip();\n        fireEvent(this, 'afterAnimate');\n    },\n\n    /**\n     * Draw the markers\n     */\n    drawPoints: function () {\n        var series = this,\n            points = series.points,\n            chart = series.chart,\n            plotX,\n            plotY,\n            i,\n            point,\n            radius,\n            symbol,\n            isImage,\n            graphic,\n            options = series.options,\n            seriesMarkerOptions = options.marker,\n            pointMarkerOptions,\n            hasPointMarker,\n            enabled,\n            isInside,\n            markerGroup = series.markerGroup,\n            xAxis = series.xAxis,\n            globallyEnabled = pick(\n                seriesMarkerOptions.enabled,\n                xAxis.isRadial,\n                series.closestPointRangePx > 2 * seriesMarkerOptions.radius\n            );\n\n        if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n\n            i = points.length;\n            while (i--) {\n                point = points[i];\n                plotX = Math.floor(point.plotX); // #1843\n                plotY = point.plotY;\n                graphic = point.graphic;\n                pointMarkerOptions = point.marker || {};\n                hasPointMarker = !!point.marker;\n                enabled = (globallyEnabled && pointMarkerOptions.enabled === undefined) || pointMarkerOptions.enabled;\n                isInside = point.isInside;\n\n                // only draw the point if y is defined\n                if (enabled && isNumber(plotY) && point.y !== null) {\n\n                    // Shortcuts\n                    radius = seriesMarkerOptions.radius;\n                    symbol = pick(pointMarkerOptions.symbol, series.symbol);\n                    isImage = symbol.indexOf('url') === 0;\n\n                    if (graphic) { // update\n                        graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled\n                            //.attr(pointAttr) // #4759\n                            .animate(extend({\n                                x: plotX - radius,\n                                y: plotY - radius\n                            }, graphic.symbolName ? { // don't apply to image symbols #507\n                                width: 2 * radius,\n                                height: 2 * radius\n                            } : {}));\n                    } else if (isInside && (radius > 0 || isImage)) {\n                        point.graphic = graphic = chart.renderer.symbol(\n                            symbol,\n                            plotX - radius,\n                            plotY - radius,\n                            2 * radius,\n                            2 * radius,\n                            hasPointMarker ? pointMarkerOptions : seriesMarkerOptions\n                        )\n                        .attr({ r: radius })\n                        .add(markerGroup);\n\n                        ";
if (build.classic) { 
s += "\n                        // Presentational attributes\n                        graphic.attr(series.pointAttribs(point, point.selected && 'select'));\n                        ";
} 
s += "\n                    }\n\n                    if (graphic) {\n                        graphic.addClass(point.getClassName(), true);\n                    }\n\n                } else if (graphic) {\n                    point.graphic = graphic.destroy(); // #1269\n                }\n            }\n        }\n\n    },\n\n    ";
if (build.classic) { 
s += "\n    /**\n     * Get presentational attributes for marker-based series (line, spline, scatter, bubble, mappoint...)\n     */\n    pointAttribs: function (point, state) {\n        var seriesMarkerOptions = this.options.marker,\n            seriesStateOptions,\n            pointMarkerOptions = (point && point.options && point.options.marker) || {},\n            pointStateOptions,\n            strokeWidth = seriesMarkerOptions.lineWidth,\n            color = this.color,\n            pointColorOption = point && point.options.color,\n            pointColor = point && point.color,\n            zoneColor,\n            fill,\n            stroke,\n            zone;\n\n        if (point && this.zones.length) {\n            zone = point.getZone();\n            if (zone && zone.color) {\n                zoneColor = zone.color;\n            }\n        }\n\n        color = pointColorOption || zoneColor || pointColor || color;\n        fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color;\n        stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color;\n\n        // Handle hover and select states\n        if (state) {\n            seriesStateOptions = seriesMarkerOptions.states[state];\n            pointStateOptions = (pointMarkerOptions.states && pointMarkerOptions.states[state]) || {};\n            strokeWidth = seriesStateOptions.lineWidth || strokeWidth + seriesStateOptions.lineWidthPlus;\n            fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;\n            stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;\n        }\n        \n        return {\n            'stroke': stroke,\n            'stroke-width': strokeWidth,\n            'fill': fill\n        };\n    },\n    ";
} 
s += "\n    /**\n     * Clear DOM objects and free up memory\n     */\n    destroy: function () {\n        var series = this,\n            chart = series.chart,\n            issue134 = /AppleWebKit\\/533/.test(win.navigator.userAgent),\n            destroy,\n            i,\n            data = series.data || [],\n            point,\n            prop,\n            axis;\n\n        // add event hook\n        fireEvent(series, 'destroy');\n\n        // remove all events\n        removeEvent(series);\n\n        // erase from axes\n        each(series.axisTypes || [], function (AXIS) {\n            axis = series[AXIS];\n            if (axis) {\n                erase(axis.series, series);\n                axis.isDirty = axis.forceRedraw = true;\n            }\n        });\n\n        // remove legend items\n        if (series.legendItem) {\n            series.chart.legend.destroyItem(series);\n        }\n\n        // destroy all points with their elements\n        i = data.length;\n        while (i--) {\n            point = data[i];\n            if (point && point.destroy) {\n                point.destroy();\n            }\n        }\n        series.points = null;\n\n        // Clear the animation timeout if we are destroying the series during initial animation\n        clearTimeout(series.animationTimeout);\n\n        // Destroy all SVGElements associated to the series\n        for (prop in series) {\n            if (series[prop] instanceof SVGElement && !series[prop].survive) { // Survive provides a hook for not destroying\n\n                // issue 134 workaround\n                destroy = issue134 && prop === 'group' ?\n                    'hide' :\n                    'destroy';\n\n                series[prop][destroy]();\n            }\n        }\n\n        // remove from hoverSeries\n        if (chart.hoverSeries === series) {\n            chart.hoverSeries = null;\n        }\n        erase(chart.series, series);\n\n        // clear all members\n        for (prop in series) {\n            delete series[prop];\n        }\n    },\n\n    /**\n     * Get the graph path\n     */\n    getGraphPath: function (points, nullsAsZeroes, connectCliffs) {\n        var series = this,\n            options = series.options,\n            step = options.step,\n            reversed,\n            graphPath = [],\n            gap;\n\n        points = points || series.points;\n\n        // Bottom of a stack is reversed\n        reversed = points.reversed;\n        if (reversed) {\n            points.reverse();\n        }\n        // Reverse the steps (#5004)\n        step = { right: 1, center: 2 }[step] || (step && 3);\n        if (step && reversed) {\n            step = 4 - step;\n        }\n\n        // Remove invalid points, especially in spline (#5015)\n        if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {\n            points = this.getValidPoints(points);\n        }\n\n        // Build the line\n        each(points, function (point, i) {\n\n            var plotX = point.plotX,\n                plotY = point.plotY,\n                lastPoint = points[i - 1],                    \n                pathToPoint; // the path to this point from the previous\n\n            if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {\n                gap = true; // ... and continue\n            }\n\n            // Line series, nullsAsZeroes is not handled\n            if (point.isNull && !defined(nullsAsZeroes) && i > 0) {\n                gap = !options.connectNulls;\n\n            // Area series, nullsAsZeroes is set\n            } else if (point.isNull && !nullsAsZeroes) {\n                gap = true;\n\n            } else {\n\n                if (i === 0 || gap) {\n                    pathToPoint = ['M', point.plotX, point.plotY];\n                \n                } else if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object\n                    \n                    pathToPoint = series.getPointSpline(points, point, i);\n\n                } else if (step) {\n\n                    if (step === 1) { // right\n                        pathToPoint = [\n                            'L',\n                            lastPoint.plotX,\n                            plotY\n                        ];\n                        \n                    } else if (step === 2) { // center\n                        pathToPoint = [\n                            'L',\n                            (lastPoint.plotX + plotX) / 2,\n                            lastPoint.plotY,\n                            'L',\n                            (lastPoint.plotX + plotX) / 2,\n                            plotY\n                        ];\n                        \n                    } else {\n                        pathToPoint = [\n                            'L',\n                            plotX,\n                            lastPoint.plotY\n                        ];\n                    }\n                    pathToPoint.push('L', plotX, plotY);\n\n                } else {\n                    // normal line to next point\n                    pathToPoint = [\n                        'L',\n                        plotX,\n                        plotY\n                    ];\n                }\n\n\n                graphPath.push.apply(graphPath, pathToPoint);\n                gap = false;\n            }\n        });\n\n        series.graphPath = graphPath;\n\n        return graphPath;\n\n    },\n\n    /**\n     * Draw the actual graph\n     */\n    drawGraph: function () {\n        var series = this,\n            options = this.options,\n            graphPath = this.getGraphPath(),\n            props = [[\n                'graph', \n                'highcharts-graph', \n                ";
if (build.classic) { 
s += "\n                options.lineColor || this.color, \n                options.dashStyle\n                ";
} 
s += "\n            ]];\n\n        // Add the zone properties if any\n        each(this.zones, function (zone, i) {\n            props.push([\n                'zone-graph-' + i,\n                'highcharts-graph highcharts-zone-graph-' + i + ' ' + (zone.className || ''),\n                ";
if (build.classic) { 
s += "\n                zone.color || series.color, \n                zone.dashStyle || options.dashStyle\n                ";
} 
s += "\n            ]);\n        });\n\n        // Draw the graph\n        each(props, function (prop, i) {\n            var graphKey = prop[0],\n                graph = series[graphKey],\n                attribs;\n\n            if (graph) {\n                graph.animate({ d: graphPath });\n\n            } else if (graphPath.length) { // #1487\n                \n                series[graphKey] = series.chart.renderer.path(graphPath)\n                    .addClass('highcharts-graph ' + (prop[1] || ''))\n                    .attr({ zIndex: 1 }) // #1069\n                    .add(series.group);\n\n                ";
if (build.classic) { 
s += "\n                attribs = {\n                    'stroke': prop[2],\n                    'stroke-width': options.lineWidth,\n                    'fill': (series.fillGraph && series.color) || 'none' // Polygon series use filled graph\n                };\n\n                if (prop[3]) {\n                    attribs.dashstyle = prop[3];\n                } else if (options.linecap !== 'square') {\n                    attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';\n                }\n\n                series[graphKey]\n                    .attr(attribs)\n                    .shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932\n                ";
} 
s += "\n            }\n        });\n    },\n\n    /**\n     * Clip the graphs into the positive and negative coloured graphs\n     */\n    applyZones: function () {\n        var series = this,\n            chart = this.chart,\n            renderer = chart.renderer,\n            zones = this.zones,\n            translatedFrom,\n            translatedTo,\n            clips = this.clips || [],\n            clipAttr,\n            graph = this.graph,\n            area = this.area,\n            chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),\n            axis = this[(this.zoneAxis || 'y') + 'Axis'],\n            extremes,\n            reversed = axis.reversed,\n            inverted = chart.inverted,\n            horiz = axis.horiz,\n            pxRange,\n            pxPosMin,\n            pxPosMax,\n            ignoreZones = false;\n\n        if (zones.length && (graph || area) && axis.min !== undefined) {\n            // The use of the Color Threshold assumes there are no gaps\n            // so it is safe to hide the original graph and area\n            if (graph) {\n                graph.hide();\n            }\n            if (area) {\n                area.hide();\n            }\n\n            // Create the clips\n            extremes = axis.getExtremes();\n            each(zones, function (threshold, i) {\n\n                translatedFrom = reversed ?\n                    (horiz ? chart.plotWidth : 0) :\n                    (horiz ? 0 : axis.toPixels(extremes.min));\n                translatedFrom = Math.min(Math.max(pick(translatedTo, translatedFrom), 0), chartSizeMax);\n                translatedTo = Math.min(Math.max(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);\n                \n                if (ignoreZones) {\n                    translatedFrom = translatedTo = axis.toPixels(extremes.max);\n                }\n\n                pxRange = Math.abs(translatedFrom - translatedTo);\n                pxPosMin = Math.min(translatedFrom, translatedTo);\n                pxPosMax = Math.max(translatedFrom, translatedTo);\n                if (axis.isXAxis) {\n                    clipAttr = {\n                        x: inverted ? pxPosMax : pxPosMin,\n                        y: 0,\n                        width: pxRange,\n                        height: chartSizeMax\n                    };\n                    if (!horiz) {\n                        clipAttr.x = chart.plotHeight - clipAttr.x;\n                    }\n                } else {\n                    clipAttr = {\n                        x: 0,\n                        y: inverted ? pxPosMax : pxPosMin,\n                        width: chartSizeMax,\n                        height: pxRange\n                    };\n                    if (horiz) {\n                        clipAttr.y = chart.plotWidth - clipAttr.y;\n                    }\n                }\n\n                /// VML SUPPPORT\n                if (chart.inverted && renderer.isVML) {\n                    if (axis.isXAxis) {\n                        clipAttr = {\n                            x: 0,\n                            y: reversed ? pxPosMin : pxPosMax,\n                            height: clipAttr.width,\n                            width: chart.chartWidth\n                        };\n                    } else {\n                        clipAttr = {\n                            x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,\n                            y: 0,\n                            width: clipAttr.height,\n                            height: chart.chartHeight\n                        };\n                    }\n                }\n                /// END OF VML SUPPORT\n\n                if (clips[i]) {\n                    clips[i].animate(clipAttr);\n                } else {\n                    clips[i] = renderer.clipRect(clipAttr);\n\n                    if (graph) {\n                        series['zone-graph-' + i].clip(clips[i]);\n                    }\n\n                    if (area) {\n                        series['zone-area-' + i].clip(clips[i]);\n                    }\n                }\n                // if this zone extends out of the axis, ignore the others\n                ignoreZones = threshold.value > extremes.max;\n            });\n            this.clips = clips;\n        }\n    },\n\n    /**\n     * Initialize and perform group inversion on series.group and series.markerGroup\n     */\n    invertGroups: function () {\n        var series = this,\n            chart = series.chart;\n\n        // Pie, go away (#1736)\n        if (!series.xAxis) {\n            return;\n        }\n\n        // A fixed size is needed for inversion to work\n        function setInvert() {\n            var size = {\n                width: series.yAxis.len,\n                height: series.xAxis.len\n            };\n\n            each(['group', 'markerGroup'], function (groupName) {\n                if (series[groupName]) {\n                    series[groupName].attr(size).invert();\n                }\n            });\n        }\n\n        addEvent(chart, 'resize', setInvert); // do it on resize\n        addEvent(series, 'destroy', function () {\n            removeEvent(chart, 'resize', setInvert);\n        });\n\n        // Do it now\n        setInvert(); // do it now\n\n        // On subsequent render and redraw, just do setInvert without setting up events again\n        series.invertGroups = setInvert;\n    },\n\n    /**\n     * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and\n     * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.\n     */\n    plotGroup: function (prop, name, visibility, zIndex, parent) {\n        var group = this[prop],\n            isNew = !group;\n\n        // Generate it on first call\n        if (isNew) {\n            this[prop] = group = this.chart.renderer.g(name)\n                .attr({\n                    zIndex: zIndex || 0.1 // IE8 and pointer logic use this\n                })\n                .add(parent);\n\n            group.addClass('highcharts-series-' + this.index + ' highcharts-' + this.type + '-series highcharts-color-' + this.colorIndex +\n                ' ' + (this.options.className || '')); // docs: className\n        }\n\n        // Place it on first and subsequent (redraw) calls\n        group.attr({ visibility: visibility })[isNew ? 'attr' : 'animate'](this.getPlotBox());\n        return group;\n    },\n\n    /**\n     * Get the translation and scale for the plot area of this series\n     */\n    getPlotBox: function () {\n        var chart = this.chart,\n            xAxis = this.xAxis,\n            yAxis = this.yAxis;\n\n        // Swap axes for inverted (#2339)\n        if (chart.inverted) {\n            xAxis = yAxis;\n            yAxis = this.xAxis;\n        }\n        return {\n            translateX: xAxis ? xAxis.left : chart.plotLeft,\n            translateY: yAxis ? yAxis.top : chart.plotTop,\n            scaleX: 1, // #1623\n            scaleY: 1\n        };\n    },\n\n    /**\n     * Render the graph and markers\n     */\n    render: function () {\n        var series = this,\n            chart = series.chart,\n            group,\n            options = series.options,\n            // Animation doesn't work in IE8 quirks when the group div is hidden,\n            // and looks bad in other oldIE\n            animDuration = !!series.animate && chart.renderer.isSVG && animObject(options.animation).duration,\n            visibility = series.visible ? 'inherit' : 'hidden', // #2597\n            zIndex = options.zIndex,\n            hasRendered = series.hasRendered,\n            chartSeriesGroup = chart.seriesGroup;\n\n        // the group\n        group = series.plotGroup(\n            'group',\n            'series',\n            visibility,\n            zIndex,\n            chartSeriesGroup\n        );\n\n        series.markerGroup = series.plotGroup(\n            'markerGroup',\n            'markers',\n            visibility,\n            zIndex,\n            chartSeriesGroup\n        );\n\n        // initiate the animation\n        if (animDuration) {\n            series.animate(true);\n        }\n\n        // SVGRenderer needs to know this before drawing elements (#1089, #1795)\n        group.inverted = series.isCartesian ? chart.inverted : false;\n\n        // draw the graph if any\n        if (series.drawGraph) {\n            series.drawGraph();\n            series.applyZones();\n        }\n\n        each(series.points, function (point) {\n            if (point.redraw) {\n                point.redraw();\n            }\n        });\n\n        // draw the data labels (inn pies they go before the points)\n        if (series.drawDataLabels) {\n            series.drawDataLabels();\n        }\n\n        // draw the points\n        if (series.visible) {\n            series.drawPoints();\n        }\n\n\n        // draw the mouse tracking area\n        if (series.drawTracker && series.options.enableMouseTracking !== false) {\n            series.drawTracker();\n        }\n\n        // Handle inverted series and tracker groups\n        if (chart.inverted) {\n            series.invertGroups();\n        }\n\n        // Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).\n        if (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n            group.clip(chart.clipRect);\n        }\n\n        // Run the animation\n        if (animDuration) {\n            series.animate();\n        }\n\n        // Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option\n        // which should be available to the user).\n        if (!hasRendered) {\n            series.animationTimeout = syncTimeout(function () {\n                series.afterAnimate();\n            }, animDuration);\n        }\n\n        series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n        // (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n        series.hasRendered = true;\n    },\n\n    /**\n     * Redraw the series after an update in the axes.\n     */\n    redraw: function () {\n        var series = this,\n            chart = series.chart,\n            wasDirty = series.isDirty || series.isDirtyData, // cache it here as it is set to false in render, but used after\n            group = series.group,\n            xAxis = series.xAxis,\n            yAxis = series.yAxis;\n\n        // reposition on resize\n        if (group) {\n            if (chart.inverted) {\n                group.attr({\n                    width: chart.plotWidth,\n                    height: chart.plotHeight\n                });\n            }\n\n            group.animate({\n                translateX: pick(xAxis && xAxis.left, chart.plotLeft),\n                translateY: pick(yAxis && yAxis.top, chart.plotTop)\n            });\n        }\n\n        series.translate();\n        series.render();\n        if (wasDirty) { // #3868, #3945\n            delete this.kdTree;\n        }\n    },\n\n    /**\n     * KD Tree && PointSearching Implementation\n     */\n\n    kdDimensions: 1,\n    kdAxisArray: ['clientX', 'plotY'],\n\n    searchPoint: function (e, compareX) {\n        var series = this,\n            xAxis = series.xAxis,\n            yAxis = series.yAxis,\n            inverted = series.chart.inverted;\n\n        return this.searchKDTree({\n            clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,\n            plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos\n        }, compareX);\n    },\n\n    buildKDTree: function () {\n        var series = this,\n            dimensions = series.kdDimensions;\n\n        // Internal function\n        function _kdtree(points, depth, dimensions) {\n            var axis,\n                median,\n                length = points && points.length;\n\n            if (length) {\n\n                // alternate between the axis\n                axis = series.kdAxisArray[depth % dimensions];\n\n                // sort point array\n                points.sort(function (a, b) {\n                    return a[axis] - b[axis];\n                });\n\n                median = Math.floor(length / 2);\n\n                // build and return nod\n                return {\n                    point: points[median],\n                    left: _kdtree(points.slice(0, median), depth + 1, dimensions),\n                    right: _kdtree(points.slice(median + 1), depth + 1, dimensions)\n                };\n\n            }\n        }\n\n        // Start the recursive build process with a clone of the points array and null points filtered out (#3873)\n        function startRecursive() {\n            series.kdTree = _kdtree(\n                series.getValidPoints(\n                    null,\n                    !series.directTouch // For line-type series restrict to plot area, but column-type series not (#3916, #4511)\n                ),\n                dimensions,\n                dimensions\n            );\n        }\n        delete series.kdTree;\n\n        // For testing tooltips, don't build async\n        syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);\n    },\n\n    searchKDTree: function (point, compareX) {\n        var series = this,\n            kdX = this.kdAxisArray[0],\n            kdY = this.kdAxisArray[1],\n            kdComparer = compareX ? 'distX' : 'dist';\n\n        // Set the one and two dimensional distance on the point object\n        function setDistance(p1, p2) {\n            var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,\n                y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,\n                r = (x || 0) + (y || 0);\n\n            p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n            p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;\n        }\n        function _search(search, tree, depth, dimensions) {\n            var point = tree.point,\n                axis = series.kdAxisArray[depth % dimensions],\n                tdist,\n                sideA,\n                sideB,\n                ret = point,\n                nPoint1,\n                nPoint2;\n\n            setDistance(search, point);\n\n            // Pick side based on distance to splitting point\n            tdist = search[axis] - point[axis];\n            sideA = tdist < 0 ? 'left' : 'right';\n            sideB = tdist < 0 ? 'right' : 'left';\n\n            // End of tree\n            if (tree[sideA]) {\n                nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);\n\n                ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);\n            }\n            if (tree[sideB]) {\n                // compare distance to current best to splitting point to decide wether to check side B or not\n                if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {\n                    nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);\n                    ret = (nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret);\n                }\n            }\n\n            return ret;\n        }\n\n        if (!this.kdTree) {\n            this.buildKDTree();\n        }\n\n        if (this.kdTree) {\n            return _search(point,\n                this.kdTree, this.kdDimensions, this.kdDimensions);\n        }\n    }\n\n}; // end Series prototype\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var Axis = H.Axis,\n        Chart = H.Chart,\n        correctFloat = H.correctFloat,\n        defined = H.defined,\n        destroyObjectProperties = H.destroyObjectProperties,\n        each = H.each,\n        format = H.format,\n        pick = H.pick,\n        Series = H.Series;\n/**\n * The class for stack items\n */\nfunction StackItem(axis, options, isNegative, x, stackOption) {\n\n    var inverted = axis.chart.inverted;\n\n    this.axis = axis;\n\n    // Tells if the stack is negative\n    this.isNegative = isNegative;\n\n    // Save the options to be able to style the label\n    this.options = options;\n\n    // Save the x value to be able to position the label later\n    this.x = x;\n\n    // Initialize total value\n    this.total = null;\n\n    // This will keep each points' extremes stored by series.index and point index\n    this.points = {};\n\n    // Save the stack option on the series configuration object, and whether to treat it as percent\n    this.stack = stackOption;\n    this.leftCliff = 0;\n    this.rightCliff = 0;\n\n    // The align options and text align varies on whether the stack is negative and\n    // if the chart is inverted or not.\n    // First test the user supplied value, then use the dynamic.\n    this.alignOptions = {\n        align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),\n        verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),\n        y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),\n        x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)\n    };\n\n    this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');\n}\n\nStackItem.prototype = {\n    destroy: function () {\n        destroyObjectProperties(this, this.axis);\n    },\n\n    /**\n     * Renders the stack total label and adds it to the stack label group.\n     */\n    render: function (group) {\n        var options = this.options,\n            formatOption = options.format,\n            str = formatOption ?\n                format(formatOption, this) :\n                options.formatter.call(this);  // format the text in the label\n\n        // Change the text to reflect the new total and set visibility to hidden in case the serie is hidden\n        if (this.label) {\n            this.label.attr({ text: str, visibility: 'hidden' });\n        // Create new label\n        } else {\n            this.label =\n                this.axis.chart.renderer.text(str, null, null, options.useHTML)        // dummy positions, actual position updated with setOffset method in columnseries\n                    .css(options.style)                // apply style\n                    .attr({\n                        align: this.textAlign,                // fix the text-anchor\n                        rotation: options.rotation,    // rotation\n                        visibility: 'hidden'                    // hidden until setOffset is called\n                    })                \n                    .add(group);                            // add to the labels-group\n        }\n    },\n\n    /**\n     * Sets the offset that the stack has from the x value and repositions the label.\n     */\n    setOffset: function (xOffset, xWidth) {\n        var stackItem = this,\n            axis = stackItem.axis,\n            chart = axis.chart,\n            inverted = chart.inverted,\n            reversed = axis.reversed,\n            neg = (this.isNegative && !reversed) || (!this.isNegative && reversed), // #4056\n            y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates\n            yZero = axis.translate(0),                        // stack origin\n            h = Math.abs(y - yZero),                            // stack height\n            x = chart.xAxis[0].translate(this.x) + xOffset,    // stack x position\n            plotHeight = chart.plotHeight,\n            stackBox = {    // this is the box for the complete stack\n                x: inverted ? (neg ? y : y - h) : x,\n                y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),\n                width: inverted ? h : xWidth,\n                height: inverted ? xWidth : h\n            },\n            label = this.label,\n            alignAttr;\n\n        if (label) {\n            label.align(this.alignOptions, null, stackBox);    // align the label to the box\n\n            // Set visibility (#678)\n            alignAttr = label.alignAttr;\n            label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);\n        }\n    }\n};\n\n/**\n * Generate stacks for each series and calculate stacks total values\n */\nChart.prototype.getStacks = function () {\n    var chart = this;\n\n    // reset stacks for each yAxis\n    each(chart.yAxis, function (axis) {\n        if (axis.stacks && axis.hasVisibleSeries) {\n            axis.oldStacks = axis.stacks;\n        }\n    });\n\n    each(chart.series, function (series) {\n        if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {\n            series.stackKey = series.type + pick(series.options.stack, '');\n        }\n    });\n};\n\n\n// Stacking methods defined on the Axis prototype\n\n/**\n * Build the stacks from top down\n */\nAxis.prototype.buildStacks = function () {\n    var axisSeries = this.series,\n        series,\n        reversedStacks = pick(this.options.reversedStacks, true),\n        len = axisSeries.length,\n        i;\n    if (!this.isXAxis) {\n        this.usePercentage = false;\n        i = len;\n        while (i--) {\n            axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();\n        }\n\n        i = len;\n        while (i--) {\n            series = axisSeries[reversedStacks ? i : len - i - 1];\n            if (series.setStackCliffs) {\n                series.setStackCliffs();\n            }\n        }\n        // Loop up again to compute percent stack\n        if (this.usePercentage) {\n            for (i = 0; i < len; i++) {\n                axisSeries[i].setPercentStacks();\n            }\n        }\n    }\n};\n\nAxis.prototype.renderStackTotals = function () {\n    var axis = this,\n        chart = axis.chart,\n        renderer = chart.renderer,\n        stacks = axis.stacks,\n        stackKey,\n        oneStack,\n        stackCategory,\n        stackTotalGroup = axis.stackTotalGroup;\n\n    // Create a separate group for the stack total labels\n    if (!stackTotalGroup) {\n        axis.stackTotalGroup = stackTotalGroup =\n            renderer.g('stack-labels')\n                .attr({\n                    visibility: 'visible',\n                    zIndex: 6\n                })\n                .add();\n    }\n\n    // plotLeft/Top will change when y axis gets wider so we need to translate the\n    // stackTotalGroup at every render call. See bug #506 and #516\n    stackTotalGroup.translate(chart.plotLeft, chart.plotTop);\n\n    // Render each stack total\n    for (stackKey in stacks) {\n        oneStack = stacks[stackKey];\n        for (stackCategory in oneStack) {\n            oneStack[stackCategory].render(stackTotalGroup);\n        }\n    }\n};\n\n/**\n * Set all the stacks to initial states and destroy unused ones.\n */\nAxis.prototype.resetStacks = function () {\n    var stacks = this.stacks,\n        type,\n        i;\n    if (!this.isXAxis) {\n        for (type in stacks) {\n            for (i in stacks[type]) {\n\n                // Clean up memory after point deletion (#1044, #4320)\n                if (stacks[type][i].touched < this.stacksTouched) {\n                    stacks[type][i].destroy();\n                    delete stacks[type][i];\n\n                // Reset stacks\n                } else {\n                    stacks[type][i].total = null;\n                    stacks[type][i].cum = 0;\n                }\n            }\n        }\n    }\n};\n\nAxis.prototype.cleanStacks = function () {\n    var stacks, type, i;\n\n    if (!this.isXAxis) {\n        if (this.oldStacks) {\n            stacks = this.stacks = this.oldStacks;\n        }\n\n        // reset stacks\n        for (type in stacks) {\n            for (i in stacks[type]) {\n                stacks[type][i].cum = stacks[type][i].total;\n            }\n        }\n    }\n};\n\n\n// Stacking methods defnied for Series prototype\n\n/**\n * Adds series' points value to corresponding stack\n */\nSeries.prototype.setStackedPoints = function () {\n    if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {\n        return;\n    }\n\n    var series = this,\n        xData = series.processedXData,\n        yData = series.processedYData,\n        stackedYData = [],\n        yDataLength = yData.length,\n        seriesOptions = series.options,\n        threshold = seriesOptions.threshold,\n        stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,\n        stackOption = seriesOptions.stack,\n        stacking = seriesOptions.stacking,\n        stackKey = series.stackKey,\n        negKey = '-' + stackKey,\n        negStacks = series.negStacks,\n        yAxis = series.yAxis,\n        stacks = yAxis.stacks,\n        oldStacks = yAxis.oldStacks,\n        stackIndicator,\n        isNegative,\n        stack,\n        other,\n        key,\n        pointKey,\n        i,\n        x,\n        y;\n\n\n    yAxis.stacksTouched += 1;\n\n    // loop over the non-null y values and read them into a local array\n    for (i = 0; i < yDataLength; i++) {\n        x = xData[i];\n        y = yData[i];\n        stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);\n        pointKey = stackIndicator.key;\n        // Read stacked values into a stack based on the x value,\n        // the sign of y and the stack key. Stacking is also handled for null values (#739)\n        isNegative = negStacks && y < (stackThreshold ? 0 : threshold);\n        key = isNegative ? negKey : stackKey;\n\n        // Create empty object for this stack if it doesn't exist yet\n        if (!stacks[key]) {\n            stacks[key] = {};\n        }\n\n        // Initialize StackItem for this x\n        if (!stacks[key][x]) {\n            if (oldStacks[key] && oldStacks[key][x]) {\n                stacks[key][x] = oldStacks[key][x];\n                stacks[key][x].total = null;\n            } else {\n                stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);\n            }\n        }\n\n        // If the StackItem doesn't exist, create it first\n        stack = stacks[key][x];\n        if (y !== null) {\n            stack.points[pointKey] = stack.points[series.index] = [pick(stack.cum, stackThreshold)];\n\n            // Record the base of the stack\n            if (!defined(stack.cum)) {\n                stack.base = pointKey;\n            }\n            stack.touched = yAxis.stacksTouched;\n        \n\n            // In area charts, if there are multiple points on the same X value, let the \n            // area fill the full span of those points\n            if (stackIndicator.index > 0 && series.singleStacks === false) {\n                stack.points[pointKey][0] = stack.points[series.index + ',' + x + ',0'][0];\n            }\n        }\n\n        // Add value to the stack total\n        if (stacking === 'percent') {\n\n            // Percent stacked column, totals are the same for the positive and negative stacks\n            other = isNegative ? stackKey : negKey;\n            if (negStacks && stacks[other] && stacks[other][x]) {\n                other = stacks[other][x];\n                stack.total = other.total = Math.max(other.total, stack.total) + Math.abs(y) || 0;\n\n            // Percent stacked areas\n            } else {\n                stack.total = correctFloat(stack.total + (Math.abs(y) || 0));\n            }\n        } else {\n            stack.total = correctFloat(stack.total + (y || 0));\n        }\n\n        stack.cum = pick(stack.cum, stackThreshold) + (y || 0);\n\n        if (y !== null) {\n            stack.points[pointKey].push(stack.cum);\n            stackedYData[i] = stack.cum;\n        }\n\n    }\n\n    if (stacking === 'percent') {\n        yAxis.usePercentage = true;\n    }\n\n    this.stackedYData = stackedYData; // To be used in getExtremes\n\n    // Reset old stacks\n    yAxis.oldStacks = {};\n};\n\n/**\n * Iterate over all stacks and compute the absolute values to percent\n */\nSeries.prototype.setPercentStacks = function () {\n    var series = this,\n        stackKey = series.stackKey,\n        stacks = series.yAxis.stacks,\n        processedXData = series.processedXData,\n        stackIndicator;\n\n    each([stackKey, '-' + stackKey], function (key) {\n        var i = processedXData.length,\n            x,\n            stack,\n            pointExtremes,\n            totalFactor;\n\n        while (i--) {\n            x = processedXData[i];\n            stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);\n            stack = stacks[key] && stacks[key][x];\n            pointExtremes = stack && stack.points[stackIndicator.key];\n            if (pointExtremes) {\n                totalFactor = stack.total ? 100 / stack.total : 0;\n                pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value\n                pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value\n                series.stackedYData[i] = pointExtremes[1];\n            }\n        }\n    });\n};\n\n/**\n* Get stack indicator, according to it's x-value, to determine points with the same x-value\n*/\nSeries.prototype.getStackIndicator = function (stackIndicator, x, index) {\n    if (!defined(stackIndicator) || stackIndicator.x !== x) {\n        stackIndicator = {\n            x: x,\n            index: 0\n        };\n    } else {\n        stackIndicator.index++;\n    }\n\n    stackIndicator.key = [index, x, stackIndicator.index].join(',');\n\n    return stackIndicator;\n};\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var addEvent = H.addEvent,\n        animate = H.animate,\n        Axis = H.Axis,\n        Chart = H.Chart,\n        createElement = H.createElement,\n        css = H.css,\n        each = H.each,\n        erase = H.erase,\n        extend = H.extend,\n        fireEvent = H.fireEvent,\n        inArray = H.inArray,\n        isArray = H.isArray,\n        isObject = H.isObject,\n        merge = H.merge,\n        pick = H.pick,\n        Point = H.Point,\n        Series = H.Series,\n        seriesTypes = H.seriesTypes,\n        setAnimation = H.setAnimation,\n        splat = H.splat;\n        \n// Extend the Chart prototype for dynamic methods\nextend(Chart.prototype, {\n\n    /**\n     * Add a series dynamically after  time\n     *\n     * @param {Object} options The config options\n     * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.\n     * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n     *    configuration\n     *\n     * @return {Object} series The newly created series object\n     */\n    addSeries: function (options, redraw, animation) {\n        var series,\n            chart = this;\n\n        if (options) {\n            redraw = pick(redraw, true); // defaults to true\n\n            fireEvent(chart, 'addSeries', { options: options }, function () {\n                series = chart.initSeries(options);\n\n                chart.isDirtyLegend = true; // the series array is out of sync with the display\n                chart.linkSeries();\n                if (redraw) {\n                    chart.redraw(animation);\n                }\n            });\n        }\n\n        return series;\n    },\n\n    /**\n     * Add an axis to the chart\n     * @param {Object} options The axis option\n     * @param {Boolean} isX Whether it is an X axis or a value axis\n     */\n    addAxis: function (options, isX, redraw, animation) {\n        var key = isX ? 'xAxis' : 'yAxis',\n            chartOptions = this.options,\n            userOptions = merge(options, {\n                index: this[key].length,\n                isX: isX\n            });\n\n        new Axis(this, userOptions); // eslint-disable-line no-new\n\n        // Push the new axis options to the chart options\n        chartOptions[key] = splat(chartOptions[key] || {});\n        chartOptions[key].push(userOptions);\n\n        if (pick(redraw, true)) {\n            this.redraw(animation);\n        }\n    },\n\n    /**\n     * Dim the chart and show a loading text or symbol\n     * @param {String} str An optional text to show in the loading label instead of the default one\n     */\n    showLoading: function (str) {\n        var chart = this,\n            options = chart.options,\n            loadingDiv = chart.loadingDiv,\n            loadingOptions = options.loading,\n            setLoadingSize = function () {\n                if (loadingDiv) {\n                    css(loadingDiv, {\n                        left: chart.plotLeft + 'px',\n                        top: chart.plotTop + 'px',\n                        width: chart.plotWidth + 'px',\n                        height: chart.plotHeight + 'px'\n                    });\n                }\n            };\n\n        // create the layer at the first call\n        if (!loadingDiv) {\n            chart.loadingDiv = loadingDiv = createElement('div', {\n                className: 'highcharts-loading highcharts-loading-hidden'\n            }, null, chart.container);\n\n            chart.loadingSpan = createElement(\n                'span',\n                { className: 'highcharts-loading-inner' },\n                null,\n                loadingDiv\n            );\n            addEvent(chart, 'redraw', setLoadingSize); // #1080\n        }\n        setTimeout(function () {\n            loadingDiv.className = 'highcharts-loading';\n        });\n\n        // Update text\n        chart.loadingSpan.innerHTML = str || options.lang.loading;\n\n        ";
if (build.classic) { 
s += "\n        // Update visuals\n        css(loadingDiv, extend(loadingOptions.style, {\n            zIndex: 10\n        }));\n        css(chart.loadingSpan, loadingOptions.labelStyle);\n\n        // Show it\n        if (!chart.loadingShown) {\n            css(loadingDiv, {\n                opacity: 0,\n                display: ''\n            });\n            animate(loadingDiv, {\n                opacity: loadingOptions.style.opacity || 0.5\n            }, {\n                duration: loadingOptions.showDuration || 0\n            });\n        }\n        ";
} 
s += "\n\n        chart.loadingShown = true;\n        setLoadingSize();\n    },\n\n    /**\n     * Hide the loading layer\n     */\n    hideLoading: function () {\n        var options = this.options,\n            loadingDiv = this.loadingDiv;\n\n        if (loadingDiv) {\n            loadingDiv.className = 'highcharts-loading highcharts-loading-hidden';\n            ";
if (build.classic) { 
s += "\n            animate(loadingDiv, {\n                opacity: 0\n            }, {\n                duration: options.loading.hideDuration || 100,\n                complete: function () {\n                    css(loadingDiv, { display: 'none' });\n                }\n            });\n            ";
} 
s += "\n        }\n        this.loadingShown = false;\n    },\n\n    /**\n     * Chart.update function that takes the whole options stucture.\n     */\n    update: function (options, redraw) {\n        var key,\n            adders = {\n                credits: 'addCredits',\n                title: 'setTitle',\n                subtitle: 'setSubtitle'\n            },\n            updateAllSeries;\n\n        // Some option stuctures correspond one-to-one to chart objects that have\n        // update methods, for example\n        // options.credits => chart.credits\n        // options.legend => chart.legend\n        // options.title => chart.title\n        // options.tooltip => chart.tooltip\n        // options.subtitle => chart.subtitle\n        for (key in options) {\n            if (this[key] && typeof this[key].update === 'function') {\n                this[key].update(options[key], false);\n\n            // If a one-to-one object does not exist, look for an adder function\n            } else if (typeof this[adders[key]] === 'function') {\n                this[adders[key]](options[key]);\n            }\n        }\n\n        ";
if (build.classic) { 
s += "\n        if (options.colors) {\n            this.options.colors = options.colors;\n            updateAllSeries = true;\n        }\n        ";
} 
s += "\n\n        if (options.plotOptions) {\n            merge(true, this.options.plotOptions, options.plotOptions);\n            updateAllSeries = true;\n        }\n\n        // Certain options require the whole series structure to be thrown away\n        // and rebuilt\n        if (updateAllSeries) {\n            each(this.series, function (series) {\n                series.update({}, false);\n            });\n        }\n\n        // For loading, just update the options, do not redraw\n        if (options.loading) {\n            merge(true, this.options.loading, options.loading);\n        }\n\n        if (pick(redraw, true)) {\n            this.redraw();\n        }\n    },\n\n    /**\n     * Setter function to allow use from chart.update\n     */\n    setSubtitle: function (options) {\n        this.setTitle(undefined, options);\n    }\n\n    \n});\n\n// extend the Point prototype for dynamic methods\nextend(Point.prototype, {\n    /**\n     * Point.update with new options (typically x/y data) and optionally redraw the series.\n     *\n     * @param {Object} options Point options as defined in the series.data array\n     * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n     * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n     *    configuration\n     */\n    update: function (options, redraw, animation, runEvent) {\n        var point = this,\n            series = point.series,\n            graphic = point.graphic,\n            i,\n            chart = series.chart,\n            seriesOptions = series.options,\n            names = series.xAxis && series.xAxis.names;\n\n        redraw = pick(redraw, true);\n\n        function update() {\n\n            point.applyOptions(options);\n\n            // Update visuals\n            if (point.y === null && graphic) { // #4146\n                point.graphic = graphic.destroy();\n            }\n            if (isObject(options) && !isArray(options)) {\n                // Defer the actual redraw until getAttribs has been called (#3260)\n                point.redraw = function () {\n                    if (graphic && graphic.element) {\n                        if (options && options.marker && options.marker.symbol) {\n                            point.graphic = graphic.destroy();\n                        }\n                    }\n                    if (options && options.dataLabels && point.dataLabel) { // #2468\n                        point.dataLabel = point.dataLabel.destroy();\n                    }\n                    point.redraw = null;\n                };\n            }\n\n            // record changes in the parallel arrays\n            i = point.index;\n            series.updateParallelArrays(point, i);\n            if (names && point.name) {\n                names[point.x] = point.name;\n            }\n\n            // Record the options to options.data. If there is an object from before,\n            // use point options, otherwise use raw options. (#4701)\n            seriesOptions.data[i] =  (isObject(seriesOptions.data[i]) && !isArray(seriesOptions.data[i])) ? point.options : options;\n\n            // redraw\n            series.isDirty = series.isDirtyData = true;\n            if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320\n                chart.isDirtyBox = true;\n            }\n\n            if (seriesOptions.legendType === 'point') { // #1831, #1885\n                chart.isDirtyLegend = true;\n            }\n            if (redraw) {\n                chart.redraw(animation);\n            }\n        }\n\n        // Fire the event with a default handler of doing the update\n        if (runEvent === false) { // When called from setData\n            update();\n        } else {\n            point.firePointEvent('update', { options: options }, update);\n        }\n    },\n\n    /**\n     * Remove a point and optionally redraw the series and if necessary the axes\n     * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n     * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n     *    configuration\n     */\n    remove: function (redraw, animation) {\n        this.series.removePoint(inArray(this, this.series.data), redraw, animation);\n    }\n});\n\n// Extend the series prototype for dynamic methods\nextend(Series.prototype, {\n    /**\n     * Add a point dynamically after chart load time\n     * @param {Object} options Point options as given in series.data\n     * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n     * @param {Boolean} shift If shift is true, a point is shifted off the start\n     *    of the series as one is appended to the end.\n     * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n     *    configuration\n     */\n    addPoint: function (options, redraw, shift, animation) {\n        var series = this,\n            seriesOptions = series.options,\n            data = series.data,\n            graph = series.graph,\n            area = series.area,\n            chart = series.chart,\n            names = series.xAxis && series.xAxis.names,\n            currentShift = (graph && graph.shift) || 0,\n            shiftShapes = ['graph', 'area'],\n            dataOptions = seriesOptions.data,\n            point,\n            isInTheMiddle,\n            xData = series.xData,\n            i,\n            x;\n\n        setAnimation(animation, chart);\n\n        // Make graph animate sideways\n        if (shift) {\n            i = series.zones.length;\n            while (i--) {\n                shiftShapes.push('zone-graph-' + i, 'zone-area-' + i);\n            }\n            each(shiftShapes, function (shape) {\n                if (series[shape]) {\n                    series[shape].shift = currentShift + (seriesOptions.step ? 2 : 1);\n                }\n            });\n        }\n        if (area) {\n            area.isArea = true; // needed in animation, both with and without shift\n        }\n\n        // Optional redraw, defaults to true\n        redraw = pick(redraw, true);\n\n        // Get options and push the point to xData, yData and series.options. In series.generatePoints\n        // the Point instance will be created on demand and pushed to the series.data array.\n        point = { series: series };\n        series.pointClass.prototype.applyOptions.apply(point, [options]);\n        x = point.x;\n\n        // Get the insertion point\n        i = xData.length;\n        if (series.requireSorting && x < xData[i - 1]) {\n            isInTheMiddle = true;\n            while (i && xData[i - 1] > x) {\n                i--;\n            }\n        }\n\n        series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item\n        series.updateParallelArrays(point, i); // update it\n\n        if (names && point.name) {\n            names[x] = point.name;\n        }\n        dataOptions.splice(i, 0, options);\n\n        if (isInTheMiddle) {\n            series.data.splice(i, 0, null);\n            series.processData();\n        }\n\n        // Generate points to be added to the legend (#1329)\n        if (seriesOptions.legendType === 'point') {\n            series.generatePoints();\n        }\n\n        // Shift the first point off the parallel arrays\n        if (shift) {\n            if (data[0] && data[0].remove) {\n                data[0].remove(false);\n            } else {\n                data.shift();\n                series.updateParallelArrays(point, 'shift');\n\n                dataOptions.shift();\n            }\n        }\n\n        // redraw\n        series.isDirty = true;\n        series.isDirtyData = true;\n        if (redraw) {\n            ";
if (build.clasic) { 
s += "\n            series.getAttribs(); // #1937\n            ";
} 
s += "\n            chart.redraw();\n        }\n    },\n\n    /**\n     * Remove a point (rendered or not), by index\n     */\n    removePoint: function (i, redraw, animation) {\n\n        var series = this,\n            data = series.data,\n            point = data[i],\n            points = series.points,\n            chart = series.chart,\n            remove = function () {\n\n                if (points && points.length === data.length) { // #4935\n                    points.splice(i, 1);\n                }\n                data.splice(i, 1);\n                series.options.data.splice(i, 1);\n                series.updateParallelArrays(point || { series: series }, 'splice', i, 1);\n\n                if (point) {\n                    point.destroy();\n                }\n\n                // redraw\n                series.isDirty = true;\n                series.isDirtyData = true;\n                if (redraw) {\n                    chart.redraw();\n                }\n            };\n\n        setAnimation(animation, chart);\n        redraw = pick(redraw, true);\n\n        // Fire the event with a default handler of removing the point\n        if (point) {\n            point.firePointEvent('remove', null, remove);\n        } else {\n            remove();\n        }\n    },\n\n    /**\n     * Remove a series and optionally redraw the chart\n     *\n     * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n     * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n     *    configuration\n     */\n    remove: function (redraw, animation) {\n        var series = this,\n            chart = series.chart;\n\n        // Fire the event with a default handler of removing the point\n        fireEvent(series, 'remove', null, function () {\n\n            // Destroy elements\n            series.destroy();\n\n            // Redraw\n            chart.isDirtyLegend = chart.isDirtyBox = true;\n            chart.linkSeries();\n\n            if (pick(redraw, true)) {\n                chart.redraw(animation);\n            }\n        });\n    },\n\n    /**\n     * Series.update with a new set of options\n     */\n    update: function (newOptions, redraw) {\n        var series = this,\n            chart = this.chart,\n            // must use user options when changing type because this.options is merged\n            // in with type specific plotOptions\n            oldOptions = this.userOptions,\n            oldType = this.type,\n            proto = seriesTypes[oldType].prototype,\n            preserve = ['group', 'markerGroup', 'dataLabelsGroup'],\n            n;\n\n        // If we're changing type or zIndex, create new groups (#3380, #3404)\n        if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {\n            preserve.length = 0;\n        }\n\n        // Make sure groups are not destroyed (#3094)\n        each(preserve, function (prop) {\n            preserve[prop] = series[prop];\n            delete series[prop];\n        });\n\n        // Do the merge, with some forced options\n        newOptions = merge(oldOptions, {\n            animation: false,\n            index: this.index,\n            pointStart: this.xData[0] // when updating after addPoint\n        }, { data: this.options.data }, newOptions);\n\n        // Destroy the series and delete all properties. Reinsert all methods\n        // and properties from the new type prototype (#2270, #3719)\n        this.remove(false);\n        for (n in proto) {\n            this[n] = undefined;\n        }\n        extend(this, seriesTypes[newOptions.type || oldType].prototype);\n\n        // Re-register groups (#3094)\n        each(preserve, function (prop) {\n            series[prop] = preserve[prop];\n        });\n\n        this.init(chart, newOptions);\n        chart.linkSeries(); // Links are lost in this.remove (#3028)\n        if (pick(redraw, true)) {\n            chart.redraw(false);\n        }\n    }\n});\n\n// Extend the Axis.prototype for dynamic methods\nextend(Axis.prototype, {\n\n    /**\n     * Axis.update with a new options structure\n     */\n    update: function (newOptions, redraw) {\n        var chart = this.chart;\n\n        newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);\n\n        this.destroy(true);\n        this._addedPlotLB = this.chart._labelPanes = undefined; // #1611, #2887, #4314\n\n        this.init(chart, extend(newOptions, { events: undefined }));\n\n        chart.isDirtyBox = true;\n        if (pick(redraw, true)) {\n            chart.redraw();\n        }\n    },\n\n    /**\n     * Remove the axis from the chart\n     */\n    remove: function (redraw) {\n        var chart = this.chart,\n            key = this.coll, // xAxis or yAxis\n            axisSeries = this.series,\n            i = axisSeries.length;\n\n        // Remove associated series (#2687)\n        while (i--) {\n            if (axisSeries[i]) {\n                axisSeries[i].remove(false);\n            }\n        }\n\n        // Remove the axis\n        erase(chart.axes, this);\n        erase(chart[key], this);\n        chart.options[key].splice(this.options.index, 1);\n        each(chart[key], function (axis, i) { // Re-index, #1706\n            axis.options.index = i;\n        });\n        this.destroy();\n        chart.isDirtyBox = true;\n\n        if (pick(redraw, true)) {\n            chart.redraw();\n        }\n    },\n\n    /**\n     * Update the axis title by options\n     */\n    setTitle: function (newTitleOptions, redraw) {\n        this.update({ title: newTitleOptions }, redraw);\n    },\n\n    /**\n     * Set new axis categories and optionally redraw\n     * @param {Array} categories\n     * @param {Boolean} redraw\n     */\n    setCategories: function (categories, redraw) {\n        this.update({ categories: categories }, redraw);\n    }\n\n});\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var extendClass = H.extendClass,\n        Series = H.Series,\n        seriesTypes = H.seriesTypes;\n/**\n * LineSeries object\n */\nseriesTypes.line = extendClass(Series);\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var defaultPlotOptions = H.defaultPlotOptions,\n        defaultSeriesOptions = H.defaultSeriesOptions,\n        extendClass = H.extendClass,\n        Color = H.Color,\n        each = H.each,\n        LegendSymbolMixin = H.LegendSymbolMixin,\n        map = H.map,\n        merge = H.merge,\n        pick = H.pick,\n        Series = H.Series,\n        seriesTypes = H.seriesTypes;\n/**\n * Set the default options for area\n */\ndefaultPlotOptions.area = merge(defaultSeriesOptions, {\n    softThreshold: false,\n    threshold: 0\n    // trackByArea: false,\n    // lineColor: null, // overrides color, but lets fillColor be unaltered\n    // fillOpacity: 0.75,\n    // fillColor: null\n});\n\n/**\n * Area series object\n */\nseriesTypes.area = extendClass(Series, {\n    type: 'area',\n    singleStacks: false,\n    /** \n     * Return an array of stacked points, where null and missing points are replaced by \n     * dummy points in order for gaps to be drawn correctly in stacks.\n     */\n    getStackPoints: function () {\n        var series = this,\n            segment = [],\n            keys = [],\n            xAxis = this.xAxis,\n            yAxis = this.yAxis,\n            stack = yAxis.stacks[this.stackKey],\n            pointMap = {},\n            points = this.points,\n            seriesIndex = series.index,\n            yAxisSeries = yAxis.series,\n            seriesLength = yAxisSeries.length,\n            visibleSeries,\n            upOrDown = pick(yAxis.options.reversedStacks, true) ? 1 : -1,\n            i,\n            x;\n\n        if (this.options.stacking) {\n            // Create a map where we can quickly look up the points by their X value.\n            for (i = 0; i < points.length; i++) {\n                pointMap[points[i].x] = points[i];\n            }\n\n            // Sort the keys (#1651)\n            for (x in stack) {\n                if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)\n                    keys.push(x);\n                }\n            }\n            keys.sort(function (a, b) {\n                return a - b;\n            });\n\n            visibleSeries = map(yAxisSeries, function () {\n                return this.visible;\n            });\n\n            each(keys, function (x, idx) {\n                var y = 0,\n                    stackPoint,\n                    stackedValues;\n\n                if (pointMap[x] && !pointMap[x].isNull) {\n                    segment.push(pointMap[x]);\n\n                    // Find left and right cliff. -1 goes left, 1 goes right.\n                    each([-1, 1], function (direction) {\n                        var nullName = direction === 1 ? 'rightNull' : 'leftNull',\n                            cliffName = direction === 1 ? 'rightCliff' : 'leftCliff',\n                            cliff = 0,\n                            otherStack = stack[keys[idx + direction]];\n\n                        // If there is a stack next to this one, to the left or to the right...\n                        if (otherStack) {\n                            i = seriesIndex;\n                            while (i >= 0 && i < seriesLength) { // Can go either up or down, depending on reversedStacks\n                                stackPoint = otherStack.points[i];\n                                if (!stackPoint) {\n                                    // If the next point in this series is missing, mark the point\n                                    // with point.leftNull or point.rightNull = true.\n                                    if (i === seriesIndex) {\n                                        pointMap[x][nullName] = true;\n\n                                    // If there are missing points in the next stack in any of the \n                                    // series below this one, we need to substract the missing values\n                                    // and add a hiatus to the left or right.\n                                    } else if (visibleSeries[i]) {\n                                        stackedValues = stack[x].points[i];\n                                        if (stackedValues) {\n                                            cliff -= stackedValues[1] - stackedValues[0];\n                                        }\n                                    }\n                                }\n                                // When reversedStacks is true, loop up, else loop down\n                                i += upOrDown; \n                            }                    \n                        }\n                        pointMap[x][cliffName] = cliff;\n                    });\n\n\n                // There is no point for this X value in this series, so we \n                // insert a dummy point in order for the areas to be drawn\n                // correctly.\n                } else {\n\n                    // Loop down the stack to find the series below this one that has\n                    // a value (#1991)\n                    i = seriesIndex;\n                    while (i >= 0 && i < seriesLength) {\n                        stackPoint = stack[x].points[i];\n                        if (stackPoint) {\n                            y = stackPoint[1];\n                            break;\n                        }\n                        // When reversedStacks is true, loop up, else loop down\n                        i += upOrDown;\n                    }\n\n                    y = yAxis.toPixels(y, true);\n                    segment.push({ \n                        isNull: true,\n                        plotX: xAxis.toPixels(x, true),\n                        plotY: y,\n                        yBottom: y\n                    });\n                }\n            });\n\n        } \n\n        return segment;\n    },\n\n    getGraphPath: function (points) {\n        var getGraphPath = Series.prototype.getGraphPath,\n            graphPath,\n            options = this.options,\n            stacking = options.stacking,\n            yAxis = this.yAxis,\n            topPath,\n            //topPoints = [],\n            bottomPath,\n            bottomPoints = [],\n            graphPoints = [],\n            seriesIndex = this.index,\n            i,\n            areaPath,\n            plotX,\n            stacks = yAxis.stacks[this.stackKey],\n            threshold = options.threshold,\n            translatedThreshold = yAxis.getThreshold(options.threshold),\n            isNull,\n            yBottom,\n            connectNulls = options.connectNulls || stacking === 'percent',\n            /**\n             * To display null points in underlying stacked series, this series graph must be \n             * broken, and the area also fall down to fill the gap left by the null point. #2069\n             */\n            addDummyPoints = function (i, otherI, side) {\n                var point = points[i],\n                    stackedValues = stacking && stacks[point.x].points[seriesIndex],\n                    nullVal = point[side + 'Null'] || 0,\n                    cliffVal = point[side + 'Cliff'] || 0,\n                    top,\n                    bottom,\n                    isNull = true;\n\n                if (cliffVal || nullVal) {\n\n                    top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;\n                    bottom = stackedValues[0] + cliffVal;\n                    isNull = !!nullVal;\n                \n                } else if (!stacking && points[otherI] && points[otherI].isNull) {\n                    top = bottom = threshold;\n                }\n\n                // Add to the top and bottom line of the area\n                if (top !== undefined) {\n                    graphPoints.push({\n                        plotX: plotX,\n                        plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),\n                        isNull: isNull\n                    });\n                    bottomPoints.push({\n                        plotX: plotX,\n                        plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom)\n                    });\n                }\n            };\n\n        // Find what points to use\n        points = points || this.points;\n\n        \n        // Fill in missing points\n        if (stacking) {\n            points = this.getStackPoints();\n        }\n\n        for (i = 0; i < points.length; i++) {\n            isNull = points[i].isNull;\n            plotX = pick(points[i].rectPlotX, points[i].plotX);\n            yBottom = pick(points[i].yBottom, translatedThreshold);\n\n            if (!isNull || connectNulls) {\n\n                if (!connectNulls) {\n                    addDummyPoints(i, i - 1, 'left');\n                }\n\n                if (!(isNull && !stacking && connectNulls)) { // Skip null point when stacking is false and connectNulls true\n                    graphPoints.push(points[i]);\n                    bottomPoints.push({\n                        x: i,\n                        plotX: plotX,\n                        plotY: yBottom\n                    });\n                }\n\n                if (!connectNulls) {\n                    addDummyPoints(i, i + 1, 'right');\n                }\n            }\n        }\n\n        topPath = getGraphPath.call(this, graphPoints, true, true);\n        \n        bottomPoints.reversed = true;\n        bottomPath = getGraphPath.call(this, bottomPoints, true, true);\n        if (bottomPath.length) {\n            bottomPath[0] = 'L';\n        }\n\n        areaPath = topPath.concat(bottomPath);\n        graphPath = getGraphPath.call(this, graphPoints, false, connectNulls); // TODO: don't set leftCliff and rightCliff when connectNulls?\n\n        this.areaPath = areaPath;\n        return graphPath;\n    },\n\n    /**\n     * Draw the graph and the underlying area. This method calls the Series base\n     * function and adds the area. The areaPath is calculated in the getSegmentPath\n     * method called from Series.prototype.drawGraph.\n     */\n    drawGraph: function () {\n\n        // Define or reset areaPath\n        this.areaPath = [];\n\n        // Call the base method\n        Series.prototype.drawGraph.apply(this);\n\n        // Define local variables\n        var series = this,\n            areaPath = this.areaPath,\n            options = this.options,\n            zones = this.zones,\n            props = [[\n                'area',\n                'highcharts-area',\n                ";
if (build.classic) { 
s += "\n                this.color,\n                options.fillColor\n                ";
} 
s += "\n            ]]; // area name, main color, fill color\n        \n        each(zones, function (zone, i) {\n            props.push([\n                'zone-area-' + i, \n                'highcharts-area highcharts-zone-area-' + i + ' ' + zone.className,\n                ";
if (build.classic) { 
s += "\n                zone.color || series.color, \n                zone.fillColor || options.fillColor\n                ";
} 
s += "\n            ]);\n        });\n\n        each(props, function (prop) {\n            var areaKey = prop[0],\n                area = series[areaKey];\n\n            // Create or update the area\n            if (area) { // update\n                area.animate({ d: areaPath });\n\n            } else { // create\n                series[areaKey] = series.chart.renderer.path(areaPath)\n                    .addClass(prop[1])\n                    .attr({\n                        ";
if (build.classic) { 
s += "\n                        fill: pick(\n                            prop[3],\n                            Color(prop[2]).setOpacity(pick(options.fillOpacity, 0.75)).get()\n                        ),\n                        ";
} 
s += "\n                        zIndex: 0 // #1069\n                    }).add(series.group);\n            }\n        });\n    },\n\n    drawLegendSymbol: LegendSymbolMixin.drawRectangle\n});\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var defaultPlotOptions = H.defaultPlotOptions,\n        defaultSeriesOptions = H.defaultSeriesOptions,\n        extendClass = H.extendClass,\n        merge = H.merge,\n        pick = H.pick,\n        Series = H.Series,\n        seriesTypes = H.seriesTypes;\n\n/**\n * Set the default options for spline\n */\ndefaultPlotOptions.spline = merge(defaultSeriesOptions);\n\n/**\n * SplineSeries object\n */\nseriesTypes.spline  = extendClass(Series, {\n    type: 'spline',\n\n    /**\n     * Get the spline segment from a given point's previous neighbour to the given point\n     */\n    getPointSpline: function (points, point, i) {\n        var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc\n            denom = smoothing + 1,\n            plotX = point.plotX,\n            plotY = point.plotY,\n            lastPoint = points[i - 1],\n            nextPoint = points[i + 1],\n            leftContX,\n            leftContY,\n            rightContX,\n            rightContY,\n            ret;\n\n        // Find control points\n        if (lastPoint && !lastPoint.isNull && nextPoint && !nextPoint.isNull) {\n            var lastX = lastPoint.plotX,\n                lastY = lastPoint.plotY,\n                nextX = nextPoint.plotX,\n                nextY = nextPoint.plotY,\n                correction = 0;\n\n            leftContX = (smoothing * plotX + lastX) / denom;\n            leftContY = (smoothing * plotY + lastY) / denom;\n            rightContX = (smoothing * plotX + nextX) / denom;\n            rightContY = (smoothing * plotY + nextY) / denom;\n\n            // Have the two control points make a straight line through main point\n            if (rightContX !== leftContX) { // #5016, division by zero\n                correction = ((rightContY - leftContY) * (rightContX - plotX)) /\n                    (rightContX - leftContX) + plotY - rightContY;\n            }\n\n            leftContY += correction;\n            rightContY += correction;\n\n            // to prevent false extremes, check that control points are between\n            // neighbouring points' y values\n            if (leftContY > lastY && leftContY > plotY) {\n                leftContY = Math.max(lastY, plotY);\n                rightContY = 2 * plotY - leftContY; // mirror of left control point\n            } else if (leftContY < lastY && leftContY < plotY) {\n                leftContY = Math.min(lastY, plotY);\n                rightContY = 2 * plotY - leftContY;\n            }\n            if (rightContY > nextY && rightContY > plotY) {\n                rightContY = Math.max(nextY, plotY);\n                leftContY = 2 * plotY - rightContY;\n            } else if (rightContY < nextY && rightContY < plotY) {\n                rightContY = Math.min(nextY, plotY);\n                leftContY = 2 * plotY - rightContY;\n            }\n\n            // record for drawing in next point\n            point.rightContX = rightContX;\n            point.rightContY = rightContY;\n\n            \n        }\n\n        // Visualize control points for debugging\n        /*\n        if (leftContX) {\n            this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)\n                .attr({\n                    stroke: 'red',\n                    'stroke-width': 1,\n                    fill: 'none'\n                })\n                .add();\n            this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,\n                'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n                .attr({\n                    stroke: 'red',\n                    'stroke-width': 1\n                })\n                .add();\n            this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)\n                .attr({\n                    stroke: 'green',\n                    'stroke-width': 1,\n                    fill: 'none'\n                })\n                .add();\n            this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,\n                'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n                .attr({\n                    stroke: 'green',\n                    'stroke-width': 1\n                })\n                .add();\n        }\n        // */\n        ret = [\n            'C',\n            pick(lastPoint.rightContX, lastPoint.plotX),\n            pick(lastPoint.rightContY, lastPoint.plotY),\n            pick(leftContX, plotX),\n            pick(leftContY, plotY),\n            plotX,\n            plotY\n        ];\n        lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later\n        return ret;\n    }\n});\n\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var areaProto = H.seriesTypes.area.prototype,\n        defaultPlotOptions = H.defaultPlotOptions,\n        extendClass = H.extendClass,\n        LegendSymbolMixin = H.LegendSymbolMixin,\n        merge = H.merge,\n        seriesTypes = H.seriesTypes;\n/**\n * Set the default options for areaspline\n */\ndefaultPlotOptions.areaspline = merge(defaultPlotOptions.area);\n\n/**\n * AreaSplineSeries object\n */\nseriesTypes.areaspline = extendClass(seriesTypes.spline, {\n        type: 'areaspline',\n        getStackPoints: areaProto.getStackPoints,\n        getGraphPath: areaProto.getGraphPath,\n        setStackCliffs: areaProto.setStackCliffs,\n        drawGraph: areaProto.drawGraph,\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle\n    });\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var animObject = H.animObject,\n        Color = H.Color,\n        defaultPlotOptions = H.defaultPlotOptions,\n        defaultSeriesOptions = H.defaultSeriesOptions,\n        each = H.each,\n        extend = H.extend,\n        extendClass = H.extendClass,\n        isNumber = H.isNumber,\n        LegendSymbolMixin = H.LegendSymbolMixin,\n        merge = H.merge,\n        noop = H.noop,\n        pick = H.pick,\n        Series = H.Series,\n        seriesTypes = H.seriesTypes,\n        stop = H.stop,\n        svg = H.svg;\n/**\n * Set the default options for column\n */\ndefaultPlotOptions.column = merge(defaultSeriesOptions, {\n    borderRadius: 0,\n    //colorByPoint: undefined,\n    groupPadding: 0.2,\n    //grouping: true,\n    marker: null, // point options are specified in the base options\n    pointPadding: 0.1,\n    //pointWidth: null,\n    minPointLength: 0,\n    cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes\n    pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories\n    states: {\n        hover: {\n            halo: false\n        }\n    },\n    dataLabels: {\n        align: null, // auto\n        verticalAlign: null, // auto\n        y: null\n    },\n    softThreshold: false,\n    startFromThreshold: true, // false doesn't work well: http://jsfiddle.net/highcharts/hz8fopan/14/\n    stickyTracking: false,\n    tooltip: {\n        distance: 6\n    },\n    threshold: 0\n});\n\n";
if (build.classic) { 
s += "\n// Presentational options\nmerge(true, defaultPlotOptions.column, {\n    borderColor: '#FFFFFF',\n    // borderWidth: 1,\n    states: {\n        hover: {\n            brightness: 0.1,\n            shadow: false\n        },\n        select: {\n            color: '#C0C0C0',\n            borderColor: '#000000',\n            shadow: false\n        }\n    }\n});\n";
} 
s += "\n\n/**\n * ColumnSeries object\n */\nseriesTypes.column = extendClass(Series, {\n    type: 'column',\n    cropShoulder: 0,\n    directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.\n    trackerGroups: ['group', 'dataLabelsGroup'],\n    negStacks: true, // use separate negative stacks, unlike area stacks where a negative\n        // point is substracted from previous (#1910)\n\n    /**\n     * Initialize the series\n     */\n    init: function () {\n        Series.prototype.init.apply(this, arguments);\n\n        var series = this,\n            chart = series.chart;\n\n        // if the series is added dynamically, force redraw of other\n        // series affected by a new column\n        if (chart.hasRendered) {\n            each(chart.series, function (otherSeries) {\n                if (otherSeries.type === series.type) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n    },\n\n    /**\n     * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,\n     * pointWidth etc.\n     */\n    getColumnMetrics: function () {\n\n        var series = this,\n            options = series.options,\n            xAxis = series.xAxis,\n            yAxis = series.yAxis,\n            reversedXAxis = xAxis.reversed,\n            stackKey,\n            stackGroups = {},\n            columnCount = 0;\n\n        // Get the total number of column type series.\n        // This is called on every series. Consider moving this logic to a\n        // chart.orderStacks() function and call it on init, addSeries and removeSeries\n        if (options.grouping === false) {\n            columnCount = 1;\n        } else {\n            each(series.chart.series, function (otherSeries) {\n                var otherOptions = otherSeries.options,\n                    otherYAxis = otherSeries.yAxis,\n                    columnIndex;\n                if (otherSeries.type === series.type && otherSeries.visible &&\n                        yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086\n                    if (otherOptions.stacking) {\n                        stackKey = otherSeries.stackKey;\n                        if (stackGroups[stackKey] === undefined) {\n                            stackGroups[stackKey] = columnCount++;\n                        }\n                        columnIndex = stackGroups[stackKey];\n                    } else if (otherOptions.grouping !== false) { // #1162\n                        columnIndex = columnCount++;\n                    }\n                    otherSeries.columnIndex = columnIndex;\n                }\n            });\n        }\n\n        var categoryWidth = Math.min(\n                Math.abs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610\n                xAxis.len // #1535\n            ),\n            groupPadding = categoryWidth * options.groupPadding,\n            groupWidth = categoryWidth - 2 * groupPadding,\n            pointOffsetWidth = groupWidth / columnCount,\n            pointWidth = Math.min(\n                options.maxPointWidth || xAxis.len,\n                pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))\n            ),\n            pointPadding = (pointOffsetWidth - pointWidth) / 2,\n            colIndex = (series.columnIndex || 0) + (reversedXAxis ? 1 : 0), // #1251, #3737\n            pointXOffset = pointPadding + (groupPadding + colIndex *\n                pointOffsetWidth - (categoryWidth / 2)) *\n                (reversedXAxis ? -1 : 1);\n\n        // Save it for reading in linked series (Error bars particularly)\n        series.columnMetrics = {\n            width: pointWidth,\n            offset: pointXOffset\n        };\n        return series.columnMetrics;\n\n    },\n\n    /**\n     * Make the columns crisp. The edges are rounded to the nearest full pixel.\n     */\n    crispCol: function (x, y, w, h) {\n        var chart = this.chart,\n            borderWidth = this.borderWidth,\n            xCrisp = -(borderWidth % 2 ? 0.5 : 0),\n            yCrisp = borderWidth % 2 ? 0.5 : 1,\n            right,\n            bottom,\n            fromTop;\n\n        if (chart.inverted && chart.renderer.isVML) {\n            yCrisp += 1;\n        }\n\n        // Horizontal. We need to first compute the exact right edge, then round it\n        // and compute the width from there.\n        right = Math.round(x + w) + xCrisp;\n        x = Math.round(x) + xCrisp;\n        w = right - x;\n\n        // Vertical\n        bottom = Math.round(y + h) + yCrisp;\n        fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656\n        y = Math.round(y) + yCrisp;\n        h = bottom - y;\n\n        // Top edges are exceptions\n        if (fromTop && h) { // #5146\n            y -= 1;\n            h += 1;\n        }\n\n        return {\n            x: x,\n            y: y,\n            width: w,\n            height: h\n        };\n    },\n\n    /**\n     * Translate each point to the plot area coordinate system and find shape positions\n     */\n    translate: function () {\n        var series = this,\n            chart = series.chart,\n            options = series.options,\n            dense = series.closestPointRange * series.xAxis.transA < 2,\n            borderWidth = series.borderWidth = pick(\n                options.borderWidth, \n                dense ? 0 : 1  // #3635\n            ),\n            yAxis = series.yAxis,\n            threshold = options.threshold,\n            translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),\n            minPointLength = pick(options.minPointLength, 5),\n            metrics = series.getColumnMetrics(),\n            pointWidth = metrics.width,\n            seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width\n            pointXOffset = series.pointXOffset = metrics.offset;\n\n        if (chart.inverted) {\n            translatedThreshold -= 0.5; // #3355\n        }\n\n        // When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual\n        // columns to have individual sizes. When pointPadding is greater, we strive for equal-width\n        // columns (#2694).\n        if (options.pointPadding) {\n            seriesBarW = Math.ceil(seriesBarW);\n        }\n\n        Series.prototype.translate.apply(series);\n\n        // Record the new values\n        each(series.points, function (point) {\n            var yBottom = pick(point.yBottom, translatedThreshold),\n                safeDistance = 999 + Math.abs(yBottom),\n                plotY = Math.min(Math.max(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)\n                barX = point.plotX + pointXOffset,\n                barW = seriesBarW,\n                barY = Math.min(plotY, yBottom),\n                up,\n                barH = Math.max(plotY, yBottom) - barY;\n\n            // Handle options.minPointLength\n            if (Math.abs(barH) < minPointLength) {\n                if (minPointLength) {\n                    barH = minPointLength;\n                    up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);\n                    barY = Math.abs(barY - translatedThreshold) > minPointLength ? // stacked\n                            yBottom - minPointLength : // keep position\n                            translatedThreshold - (up ? minPointLength : 0); // #1485, #4051\n                }\n            }\n\n            // Cache for access in polar\n            point.barX = barX;\n            point.pointWidth = pointWidth;\n\n            // Fix the tooltip on center of grouped columns (#1216, #424, #3648)\n            point.tooltipPos = chart.inverted ?\n                [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] :\n                [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];\n\n            // Register shape type and arguments to be used in drawPoints\n            point.shapeType = 'rect';\n            point.shapeArgs = series.crispCol(barX, barY, barW, barH);\n        });\n\n    },\n\n    getSymbol: noop,\n\n    /**\n     * Use a solid rectangle like the area series types\n     */\n    drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n\n    /**\n     * Columns have no graph\n     */\n    drawGraph: noop,\n\n    ";
if (build.classic) { 
s += "\n    /**\n     * Get presentational attributes\n     */\n    pointAttribs: function (point, state) {\n        var options = this.options,\n            stateOptions,\n            ret,\n            p2o = this.pointAttrToOptions || {},\n            strokeOption = p2o.stroke || 'borderColor',\n            strokeWidthOption = p2o['stroke-width'] || 'borderWidth',\n            fill = (point && point.color) || this.color,\n            stroke = options[strokeOption] || this.color,\n            dashstyle = options.dashStyle,\n            zone,\n            brightness;\n        \n        if (point && this.zones.length) {\n            zone = point.getZone();\n            if (zone && zone.color) {\n                fill = zone.color;\n            }\n        }\n\n        // Select or hover states\n        if (state) {\n            stateOptions = options.states[state];\n            brightness = stateOptions.brightness;\n            fill = stateOptions.color || \n                (brightness !== undefined && Color(fill).brighten(stateOptions.brightness).get()) ||\n                fill;\n            stroke = stateOptions[strokeOption] || stroke;\n            dashstyle = stateOptions.dashStyle || dashstyle;\n        }\n\n        ret = {\n            'fill': fill,\n            'stroke': stroke,\n            'stroke-width': point[strokeWidthOption] || options[strokeWidthOption] || this[strokeWidthOption] || 0\n        };\n        if (options.borderRadius) {\n            ret.r = options.borderRadius;\n        }\n\n        if (dashstyle) {\n            ret.dashstyle = dashstyle;\n        }\n\n        return ret;\n    },\n    ";
} 
s += "\n\n    /**\n     * Draw the columns. For bars, the series.group is rotated, so the same coordinates\n     * apply for columns and bars. This method is inherited by scatter series.\n     *\n     */\n    drawPoints: function () {\n        var series = this,\n            chart = this.chart,\n            options = series.options,\n            renderer = chart.renderer,\n            animationLimit = options.animationLimit || 250,\n            shapeArgs;\n\n        // draw the columns\n        each(series.points, function (point) {\n            var plotY = point.plotY,\n                graphic = point.graphic;\n\n            if (isNumber(plotY) && point.y !== null) {\n                shapeArgs = point.shapeArgs;\n\n                if (graphic) { // update\n                    stop(graphic);\n                    graphic[chart.pointCount < animationLimit ? 'animate' : 'attr'](\n                        merge(shapeArgs)\n                    );\n\n                } else {\n                    point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n                        .attr({\n                            'class': point.getClassName()\n                        })\n                        .add(point.group || series.group);\n\n                    ";
if (build.classic) { 
s += "\n                    // Presentational\n                    graphic\n                        .attr(series.pointAttribs(point, point.selected && 'select'))\n                        .shadow(options.shadow, null, options.stacking && !options.borderRadius);\n                    ";
} 
s += "\n                }\n\n            } else if (graphic) {\n                point.graphic = graphic.destroy(); // #1269\n            }\n        });\n    },\n\n    /**\n     * Animate the column heights one by one from zero\n     * @param {Boolean} init Whether to initialize the animation or run it\n     */\n    animate: function (init) {\n        var series = this,\n            yAxis = this.yAxis,\n            options = series.options,\n            inverted = this.chart.inverted,\n            attr = {},\n            translatedThreshold;\n\n        if (svg) { // VML is too slow anyway\n            if (init) {\n                attr.scaleY = 0.001;\n                translatedThreshold = Math.min(yAxis.pos + yAxis.len, Math.max(yAxis.pos, yAxis.toPixels(options.threshold)));\n                if (inverted) {\n                    attr.translateX = translatedThreshold - yAxis.len;\n                } else {\n                    attr.translateY = translatedThreshold;\n                }\n                series.group.attr(attr);\n\n            } else { // run the animation\n\n                attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;\n                series.group.animate(attr, extend(animObject(series.options.animation), {\n                    // Do the scale synchronously to ensure smooth updating (#5030)\n                    step: function (val, fx) {\n                        series.group.attr({\n                            scaleY: Math.max(0.001, fx.pos) // #5250\n                        });\n                    }\n                }));\n\n                // delete this function to allow it only once\n                series.animate = null;\n            }\n        }\n    },\n\n    /**\n     * Remove this series from the chart\n     */\n    remove: function () {\n        var series = this,\n            chart = series.chart;\n\n        // column and bar series affects other series of the same type\n        // as they are either stacked or grouped\n        if (chart.hasRendered) {\n            each(chart.series, function (otherSeries) {\n                if (otherSeries.type === series.type) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n\n        Series.prototype.remove.apply(series, arguments);\n    }\n});\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var defaultPlotOptions = H.defaultPlotOptions,\n        extendClass = H.extendClass,\n        merge = H.merge,\n        seriesTypes = H.seriesTypes;\n/**\n * Set the default options for bar\n */\ndefaultPlotOptions.bar = merge(defaultPlotOptions.column);\n/**\n * The Bar series class\n */\nseriesTypes.bar = extendClass(seriesTypes.column, {\n    type: 'bar',\n    inverted: true\n});\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var defaultPlotOptions = H.defaultPlotOptions,\n        defaultSeriesOptions = H.defaultSeriesOptions,\n        extendClass = H.extendClass,\n        merge = H.merge,\n        Series = H.Series,\n        seriesTypes = H.seriesTypes;\n/**\n * Set the default options for scatter\n */\ndefaultPlotOptions.scatter = merge(defaultSeriesOptions, {\n    lineWidth: 0,\n    marker: {\n        enabled: true // Overrides auto-enabling in line series (#3647)\n    },\n    tooltip: {\n        headerFormat: '<span style=___doublequote___color:{point.color}___doublequote___>\\u25CF</span> <span style=___doublequote___font-size: 0.85em___doublequote___> {series.name}</span><br/>',\n        pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n    }\n});\n\n/**\n * The scatter series class\n */\nseriesTypes.scatter = extendClass(Series, {\n    type: 'scatter',\n    sorted: false,\n    requireSorting: false,\n    noSharedTooltip: true,\n    trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n    takeOrdinalPosition: false, // #2342\n    kdDimensions: 2,\n    drawGraph: function () {\n        if (this.options.lineWidth) {\n            Series.prototype.drawGraph.call(this);\n        }\n    }\n});\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var PiePoint,\n        \n        addEvent = H.addEvent,\n        CenteredSeriesMixin = H.CenteredSeriesMixin,\n        defaultPlotOptions = H.defaultPlotOptions,\n        defaultSeriesOptions = H.defaultSeriesOptions,\n        defined = H.defined,\n        each = H.each,\n        extend = H.extend,\n        extendClass = H.extendClass,\n        inArray = H.inArray,\n        LegendSymbolMixin = H.LegendSymbolMixin,\n        merge = H.merge,\n        noop = H.noop,\n        pick = H.pick,\n        Point = H.Point,\n        Series = H.Series,\n        seriesTypes = H.seriesTypes,\n        setAnimation = H.setAnimation;\n/**\n * Set the default options for pie\n */\ndefaultPlotOptions.pie = merge(defaultSeriesOptions, {\n    center: [null, null],\n    clip: false,\n    colorByPoint: true, // always true for pies\n    dataLabels: {\n        // align: null,\n        // connectorWidth: 1,\n        // connectorColor: point.color,\n        // connectorPadding: 5,\n        distance: 30,\n        enabled: true,\n        formatter: function () { // #2945\n            return this.y === null ? undefined : this.point.name;\n        },\n        // softConnector: true,\n        x: 0\n        // y: 0\n    },\n    ignoreHiddenPoint: true,\n    //innerSize: 0,\n    legendType: 'point',\n    marker: null, // point options are specified in the base options\n    size: null,\n    showInLegend: false,\n    slicedOffset: 10,\n    stickyTracking: false,\n    tooltip: {\n        followPointer: true\n    },\n    ";
if (build.classic) { 
s += "\n    borderColor: '#FFFFFF',\n    borderWidth: 1,\n    states: {\n        hover: {\n            brightness: 0.1,\n            shadow: false\n        }\n    }\n    ";
} 
s += "\n});\n\n/**\n * Extended point object for pies\n */\nPiePoint = extendClass(Point, {\n    /**\n     * Initiate the pie slice\n     */\n    init: function () {\n\n        Point.prototype.init.apply(this, arguments);\n\n        var point = this,\n            toggleSlice;\n\n        point.name = pick(point.name, 'Slice');\n\n        // add event listener for select\n        toggleSlice = function (e) {\n            point.slice(e.type === 'select');\n        };\n        addEvent(point, 'select', toggleSlice);\n        addEvent(point, 'unselect', toggleSlice);\n\n        return point;\n    },\n\n    /**\n     * Toggle the visibility of the pie slice\n     * @param {Boolean} vis Whether to show the slice or not. If undefined, the\n     *    visibility is toggled\n     */\n    setVisible: function (vis, redraw) {\n        var point = this,\n            series = point.series,\n            chart = series.chart,\n            ignoreHiddenPoint = series.options.ignoreHiddenPoint;\n\n        redraw = pick(redraw, ignoreHiddenPoint);\n\n        if (vis !== point.visible) {\n\n            // If called without an argument, toggle visibility\n            point.visible = point.options.visible = vis = vis === undefined ? !point.visible : vis;\n            series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n            // Show and hide associated elements. This is performed regardless of redraw or not,\n            // because chart.redraw only handles full series.\n            each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {\n                if (point[key]) {\n                    point[key][vis ? 'show' : 'hide'](true);\n                }\n            });\n\n            if (point.legendItem) {\n                chart.legend.colorizeItem(point, vis);\n            }\n\n            // #4170, hide halo after hiding point\n            if (!vis && point.state === 'hover') {\n                point.setState('');\n            }\n\n            // Handle ignore hidden slices\n            if (ignoreHiddenPoint) {\n                series.isDirty = true;\n            }\n\n            if (redraw) {\n                chart.redraw();\n            }\n        }\n    },\n\n    /**\n     * Set or toggle whether the slice is cut out from the pie\n     * @param {Boolean} sliced When undefined, the slice state is toggled\n     * @param {Boolean} redraw Whether to redraw the chart. True by default.\n     */\n    slice: function (sliced, redraw, animation) {\n        var point = this,\n            series = point.series,\n            chart = series.chart,\n            translation;\n\n        setAnimation(animation, chart);\n\n        // redraw is true by default\n        redraw = pick(redraw, true);\n\n        // if called without an argument, toggle\n        point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;\n        series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n        translation = sliced ? point.slicedTranslation : {\n            translateX: 0,\n            translateY: 0\n        };\n\n        point.graphic.animate(translation);\n        \n        ";
if (build.classic) { 
s += "\n        if (point.shadowGroup) {\n            point.shadowGroup.animate(translation);\n        }\n        ";
} 
s += "\n    },\n\n    haloPath: function (size) {\n        var shapeArgs = this.shapeArgs,\n            chart = this.series.chart;\n\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {\n            innerR: this.shapeArgs.r,\n            start: shapeArgs.start,\n            end: shapeArgs.end\n        });\n    }\n});\n\n/**\n * The Pie series class\n */\nseriesTypes.pie = extendClass(Series, {\n    type: 'pie',\n    isCartesian: false,\n    pointClass: PiePoint,\n    requireSorting: false,\n    directTouch: true,\n    noSharedTooltip: true,\n    trackerGroups: ['group', 'dataLabelsGroup'],\n    axisTypes: [],\n    pointAttribs: seriesTypes.column.prototype.pointAttribs,\n    /**\n     * Animate the pies in\n     */\n    animate: function (init) {\n        var series = this,\n            points = series.points,\n            startAngleRad = series.startAngleRad;\n\n        if (!init) {\n            each(points, function (point) {\n                var graphic = point.graphic,\n                    args = point.shapeArgs;\n\n                if (graphic) {\n                    // start values\n                    graphic.attr({\n                        r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)\n                        start: startAngleRad,\n                        end: startAngleRad\n                    });\n\n                    // animate\n                    graphic.animate({\n                        r: args.r,\n                        start: args.start,\n                        end: args.end\n                    }, series.options.animation);\n                }\n            });\n\n            // delete this function to allow it only once\n            series.animate = null;\n        }\n    },\n\n    /**\n     * Recompute total chart sum and update percentages of points.\n     */\n    updateTotals: function () {\n        var i,\n            total = 0,\n            points = this.points,\n            len = points.length,\n            point,\n            ignoreHiddenPoint = this.options.ignoreHiddenPoint;\n\n        // Get the total sum\n        for (i = 0; i < len; i++) {\n            point = points[i];\n            total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;\n        }\n        this.total = total;\n\n        // Set each point's properties\n        for (i = 0; i < len; i++) {\n            point = points[i];\n            point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;\n            point.total = total;\n        }\n    },\n\n    /**\n     * Extend the generatePoints method by adding total and percentage properties to each point\n     */\n    generatePoints: function () {\n        Series.prototype.generatePoints.call(this);\n        this.updateTotals();\n    },\n\n    /**\n     * Do translation for pie slices\n     */\n    translate: function (positions) {\n        this.generatePoints();\n\n        var series = this,\n            cumulative = 0,\n            precision = 1000, // issue #172\n            options = series.options,\n            slicedOffset = options.slicedOffset,\n            connectorOffset = slicedOffset + (options.borderWidth || 0),\n            start,\n            end,\n            angle,\n            startAngle = options.startAngle || 0,\n            startAngleRad = series.startAngleRad = Math.PI / 180 * (startAngle - 90),\n            endAngleRad = series.endAngleRad = Math.PI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),\n            circ = endAngleRad - startAngleRad, //2 * Math.PI,\n            points = series.points,\n            radiusX, // the x component of the radius vector for a given point\n            radiusY,\n            labelDistance = options.dataLabels.distance,\n            ignoreHiddenPoint = options.ignoreHiddenPoint,\n            i,\n            len = points.length,\n            point;\n\n        // Get positions - either an integer or a percentage string must be given.\n        // If positions are passed as a parameter, we're in a recursive loop for adjusting\n        // space for data labels.\n        if (!positions) {\n            series.center = positions = series.getCenter();\n        }\n\n        // utility for getting the x value from a given y, used for anticollision logic in data labels\n        series.getX = function (y, left) {\n\n            angle = Math.asin(Math.min((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));\n\n            return positions[0] +\n                (left ? -1 : 1) *\n                (Math.cos(angle) * (positions[2] / 2 + labelDistance));\n        };\n\n        // Calculate the geometry for each point\n        for (i = 0; i < len; i++) {\n\n            point = points[i];\n\n            // set start and end angle\n            start = startAngleRad + (cumulative * circ);\n            if (!ignoreHiddenPoint || point.visible) {\n                cumulative += point.percentage / 100;\n            }\n            end = startAngleRad + (cumulative * circ);\n\n            // set the shape\n            point.shapeType = 'arc';\n            point.shapeArgs = {\n                x: positions[0],\n                y: positions[1],\n                r: positions[2] / 2,\n                innerR: positions[3] / 2,\n                start: Math.round(start * precision) / precision,\n                end: Math.round(end * precision) / precision\n            };\n\n            // The angle must stay within -90 and 270 (#2645)\n            angle = (end + start) / 2;\n            if (angle > 1.5 * Math.PI) {\n                angle -= 2 * Math.PI;\n            } else if (angle < -Math.PI / 2) {\n                angle += 2 * Math.PI;\n            }\n\n            // Center for the sliced out slice\n            point.slicedTranslation = {\n                translateX: Math.round(Math.cos(angle) * slicedOffset),\n                translateY: Math.round(Math.sin(angle) * slicedOffset)\n            };\n\n            // set the anchor point for tooltips\n            radiusX = Math.cos(angle) * positions[2] / 2;\n            radiusY = Math.sin(angle) * positions[2] / 2;\n            point.tooltipPos = [\n                positions[0] + radiusX * 0.7,\n                positions[1] + radiusY * 0.7\n            ];\n            \n            point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;\n            point.angle = angle;\n\n            // set the anchor point for data labels\n            connectorOffset = Math.min(connectorOffset, labelDistance / 2); // #1678\n            point.labelPos = [\n                positions[0] + radiusX + Math.cos(angle) * labelDistance, // first break of connector\n                positions[1] + radiusY + Math.sin(angle) * labelDistance, // a/a\n                positions[0] + radiusX + Math.cos(angle) * connectorOffset, // second break, right outside pie\n                positions[1] + radiusY + Math.sin(angle) * connectorOffset, // a/a\n                positions[0] + radiusX, // landing point for connector\n                positions[1] + radiusY, // a/a\n                labelDistance < 0 ? // alignment\n                    'center' :\n                    point.half ? 'right' : 'left', // alignment\n                angle // center angle\n            ];\n\n        }\n    },\n\n    drawGraph: null,\n\n    /**\n     * Draw the data points\n     */\n    drawPoints: function () {\n        var series = this,\n            chart = series.chart,\n            renderer = chart.renderer,\n            groupTranslation,\n            //center,\n            graphic,\n            //group,\n            pointAttr,\n            shapeArgs;\n\n        ";
if (build.classic) { 
s += "\n        var shadow = series.options.shadow;\n        if (shadow && !series.shadowGroup) {\n            series.shadowGroup = renderer.g('shadow')\n                .add(series.group);\n        }\n        ";
} 
s += "\n\n        // draw the slices\n        each(series.points, function (point) {\n            if (point.y !== null) {\n                graphic = point.graphic;\n                shapeArgs = point.shapeArgs;\n\n\n                // if the point is sliced, use special translation, else use plot area traslation\n                groupTranslation = point.sliced ? point.slicedTranslation : {};\n\n                ";
if (build.classic) { 
s += "\n                // Put the shadow behind all points\n                var shadowGroup = point.shadowGroup;\n                if (shadow && !shadowGroup) {\n                    shadowGroup = point.shadowGroup = renderer.g('shadow')\n                        .add(series.shadowGroup);\n                }\n\n                if (shadowGroup) {\n                    shadowGroup.attr(groupTranslation);\n                }\n                ";
} 
s += "\n\n                // Draw the slice\n                if (graphic) {\n                    graphic\n                        .setRadialReference(series.center)\n                        .attr(pointAttr)\n                        .animate(extend(shapeArgs, groupTranslation));\n                } else {\n\n                    point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n                        .addClass(point.getClassName())\n                        .setRadialReference(series.center)\n                        .attr(groupTranslation)\n                        .add(series.group);\n\n                    if (!point.visible) {\n                        graphic.attr({ visibility: 'hidden' });\n                    }\n\n                    ";
if (build.classic) { 
s += "\n                    graphic\n                        .attr(series.pointAttribs(point, point.selected && 'select'))\n                        .attr({ 'stroke-linejoin': 'round' })\n                        .shadow(shadow, shadowGroup);\n                    ";
} 
s += "\n                }\n            }\n        });\n\n    },\n\n\n    searchPoint: noop,\n\n    /**\n     * Utility for sorting data labels\n     */\n    sortByAngle: function (points, sign) {\n        points.sort(function (a, b) {\n            return a.angle !== undefined && (b.angle - a.angle) * sign;\n        });\n    },\n\n    /**\n     * Use a simple symbol from LegendSymbolMixin\n     */\n    drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n    /**\n     * Use the getCenter method from drawLegendSymbol\n     */\n    getCenter: CenteredSeriesMixin.getCenter,\n\n    /**\n     * Pies don't have point marker symbols\n     */\n    getSymbol: noop\n\n});\n\n    return H;\n}(Highcharts));\n(function (H) {\n    var addEvent = H.addEvent,\n        arrayMax = H.arrayMax,\n        defined = H.defined,\n        each = H.each,\n        extend = H.extend,\n        format = H.format,\n        merge = H.merge,\n        noop = H.noop,\n        pick = H.pick,\n        relativeLength = H.relativeLength,\n        Series = H.Series,\n        seriesTypes = H.seriesTypes,\n        stop = H.stop;\n/**\n * Draw the data labels\n */\nSeries.prototype.drawDataLabels = function () {\n\n    var series = this,\n        seriesOptions = series.options,\n        options = seriesOptions.dataLabels,\n        points = series.points,\n        pointOptions,\n        generalOptions,\n        hasRendered = series.hasRendered || 0,\n        str,\n        dataLabelsGroup,\n        defer = pick(options.defer, true),\n        renderer = series.chart.renderer;\n\n    if (options.enabled || series._hasPointLabels) {\n\n        // Process default alignment of data labels for columns\n        if (series.dlProcessOptions) {\n            series.dlProcessOptions(options);\n        }\n\n        // Create a separate group for the data labels to avoid rotation\n        dataLabelsGroup = series.plotGroup(\n            'dataLabelsGroup',\n            'data-labels',\n            defer && !hasRendered ? 'hidden' : 'visible', // #5133\n            options.zIndex || 6\n        );\n\n        if (defer) {\n            dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300\n            if (!hasRendered) {\n                addEvent(series, 'afterAnimate', function () {\n                    if (series.visible) { // #3023, #3024\n                        dataLabelsGroup.show();\n                    }\n                    dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });\n                });\n            }\n        }\n\n        // Make the labels for each point\n        generalOptions = options;\n        each(points, function (point) {\n\n            var enabled,\n                dataLabel = point.dataLabel,\n                labelConfig,\n                attr,\n                name,\n                rotation,\n                connector = point.connector,\n                isNew = true,\n                style,\n                moreStyle = {};\n\n            // Determine if each data label is enabled\n            pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps\n            enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled) && point.y !== null; // #2282, #4641\n\n\n            // If the point is outside the plot area, destroy it. #678, #820\n            if (dataLabel && !enabled) {\n                point.dataLabel = dataLabel.destroy();\n\n            // Individual labels are disabled if the are explicitly disabled\n            // in the point options, or if they fall outside the plot area.\n            } else if (enabled) {\n\n                // Create individual options structure that can be extended without\n                // affecting others\n                options = merge(generalOptions, pointOptions);\n                style = options.style;\n\n                rotation = options.rotation;\n\n                // Get the string\n                labelConfig = point.getLabelConfig();\n                str = options.format ?\n                    format(options.format, labelConfig) :\n                    options.formatter.call(labelConfig, options);\n\n                ";
if (build.classic) { 
s += "\n                // Determine the color\n                style.color = pick(options.color, style.color, series.color, 'black');\n                ";
} 
s += "\n\n                // update existing label\n                if (dataLabel) {\n\n                    if (defined(str)) {\n                        dataLabel\n                            .attr({\n                                text: str\n                            });\n                        isNew = false;\n\n                    } else { // #1437 - the label is shown conditionally\n                        point.dataLabel = dataLabel = dataLabel.destroy();\n                        if (connector) {\n                            point.connector = connector.destroy();\n                        }\n                    }\n\n                // create new label\n                } else if (defined(str)) {\n                    attr = {\n                        //align: align,\n                        ";
if (build.classic) { 
s += "\n                        fill: options.backgroundColor,\n                        stroke: options.borderColor,\n                        'stroke-width': options.borderWidth,\n                        ";
} 
s += "\n                        r: options.borderRadius || 0,\n                        rotation: rotation,\n                        padding: options.padding,\n                        zIndex: 1\n                    };\n                    \n                    ";
if (build.classic) { 
s += "\n                    // Get automated contrast color\n                    if (style.color === 'contrast') {\n                        moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ?\n                            renderer.getContrast(point.color || series.color) :\n                            '#000000';\n                    }\n\n                    if (seriesOptions.cursor) {\n                        moreStyle.cursor = seriesOptions.cursor;\n                    }\n                    ";
} 
s += "\n\n\n                    // Remove unused attributes (#947)\n                    for (name in attr) {\n                        if (attr[name] === undefined) {\n                            delete attr[name];\n                        }\n                    }\n\n                    dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation\n                        str,\n                        0,\n                        -9999,\n                        options.shape,\n                        null,\n                        null,\n                        options.useHTML,\n                        null, \n                        'data-label'\n                    )\n                    .attr(attr)\n                    .css(extend(style, moreStyle))\n                    .add(dataLabelsGroup);\n\n                    if (options.className) { // docs\n                        dataLabel.addClass(options.className);\n                    }\n\n                    ";
if (build.classic) { 
s += "\n                    dataLabel.shadow(options.shadow);\n                    ";
} 
s += "\n\n                }\n\n                if (dataLabel) {\n                    // Now the data label is created and placed at 0,0, so we need to align it\n                    series.alignDataLabel(point, dataLabel, options, null, isNew);\n                }\n            }\n        });\n    }\n};\n\n/**\n * Align each individual data label\n */\nSeries.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {\n    var chart = this.chart,\n        inverted = chart.inverted,\n        plotX = pick(point.plotX, -9999),\n        plotY = pick(point.plotY, -9999),\n        bBox = dataLabel.getBBox(),\n        fontSize,\n        baseline,\n        rotation = options.rotation,\n        normRotation,\n        negRotation,\n        align = options.align,\n        rotCorr, // rotation correction\n        // Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)\n        visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, Math.round(plotY), inverted) ||\n            (alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),\n        alignAttr, // the final position;\n        justify = pick(options.overflow, 'justify') === 'justify';\n\n    if (visible) {\n\n        ";
if (build.classic) { 
s += "\n        fontSize = options.style.fontSize;\n        ";
} 
s += "\n\n        baseline = chart.renderer.fontMetrics(fontSize, dataLabel).b;\n\n        // The alignment box is a singular point\n        alignTo = extend({\n            x: inverted ? chart.plotWidth - plotY : plotX,\n            y: Math.round(inverted ? chart.plotHeight - plotX : plotY),\n            width: 0,\n            height: 0\n        }, alignTo);\n\n        // Add the text size for alignment calculation\n        extend(options, {\n            width: bBox.width,\n            height: bBox.height\n        });\n\n        // Allow a hook for changing alignment in the last moment, then do the alignment\n        if (rotation) {\n            justify = false; // Not supported for rotated text\n            rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723\n            alignAttr = {\n                x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,\n                y: alignTo.y + options.y + { top: 0, middle: 0.5, bottom: 1 }[options.verticalAlign] * alignTo.height\n            };\n            dataLabel[isNew ? 'attr' : 'animate'](alignAttr)\n                .attr({ // #3003\n                    align: align\n                });\n\n            // Compensate for the rotated label sticking out on the sides\n            normRotation = (rotation + 720) % 360;\n            negRotation = normRotation > 180 && normRotation < 360;\n\n            if (align === 'left') {\n                alignAttr.y -= negRotation ? bBox.height : 0;\n            } else if (align === 'center') {\n                alignAttr.x -= bBox.width / 2;\n                alignAttr.y -= bBox.height / 2;\n            } else if (align === 'right') {\n                alignAttr.x -= bBox.width;\n                alignAttr.y -= negRotation ? 0 : bBox.height;\n            }\n            \n\n        } else {\n            dataLabel.align(options, null, alignTo);\n            alignAttr = dataLabel.alignAttr;\n        }\n\n        // Handle justify or crop\n        if (justify) {\n            this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);\n            \n        // Now check that the data label is within the plot area\n        } else if (pick(options.crop, true)) {\n            visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);\n        }\n\n        // When we're using a shape, make it possible with a connector or an arrow pointing to thie point\n        if (options.shape && !rotation) {\n            dataLabel.attr({\n                anchorX: point.plotX,\n                anchorY: point.plotY\n            });\n        }\n    }\n\n    // Show or hide based on the final aligned position\n    if (!visible) {\n        stop(dataLabel);\n        dataLabel.attr({ y: -9999 });\n        dataLabel.placed = false; // don't animate back in\n    }\n\n};\n\n/**\n * If data labels fall partly outside the plot area, align them back in, in a way that\n * doesn't hide the point.\n */\nSeries.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {\n    var chart = this.chart,\n        align = options.align,\n        verticalAlign = options.verticalAlign,\n        off,\n        justified,\n        padding = dataLabel.box ? 0 : (dataLabel.padding || 0);\n\n    // Off left\n    off = alignAttr.x + padding;\n    if (off < 0) {\n        if (align === 'right') {\n            options.align = 'left';\n        } else {\n            options.x = -off;\n        }\n        justified = true;\n    }\n\n    // Off right\n    off = alignAttr.x + bBox.width - padding;\n    if (off > chart.plotWidth) {\n        if (align === 'left') {\n            options.align = 'right';\n        } else {\n            options.x = chart.plotWidth - off;\n        }\n        justified = true;\n    }\n\n    // Off top\n    off = alignAttr.y + padding;\n    if (off < 0) {\n        if (verticalAlign === 'bottom') {\n            options.verticalAlign = 'top';\n        } else {\n            options.y = -off;\n        }\n        justified = true;\n    }\n\n    // Off bottom\n    off = alignAttr.y + bBox.height - padding;\n    if (off > chart.plotHeight) {\n        if (verticalAlign === 'top') {\n            options.verticalAlign = 'bottom';\n        } else {\n            options.y = chart.plotHeight - off;\n        }\n        justified = true;\n    }\n\n    if (justified) {\n        dataLabel.placed = !isNew;\n        dataLabel.align(options, null, alignTo);\n    }\n};\n\n/**\n * Override the base drawDataLabels method by pie specific functionality\n */\nif (seriesTypes.pie) {\n    seriesTypes.pie.prototype.drawDataLabels = function () {\n        var series = this,\n            data = series.data,\n            point,\n            chart = series.chart,\n            options = series.options.dataLabels,\n            connectorPadding = pick(options.connectorPadding, 10),\n            connectorWidth = pick(options.connectorWidth, 1),\n            plotWidth = chart.plotWidth,\n            plotHeight = chart.plotHeight,\n            connector,\n            connectorPath,\n            softConnector = pick(options.softConnector, true),\n            distanceOption = options.distance,\n            seriesCenter = series.center,\n            radius = seriesCenter[2] / 2,\n            centerY = seriesCenter[1],\n            outside = distanceOption > 0,\n            dataLabel,\n            dataLabelWidth,\n            labelPos,\n            labelHeight,\n            halves = [// divide the points into right and left halves for anti collision\n                [], // right\n                []  // left\n            ],\n            x,\n            y,\n            visibility,\n            rankArr,\n            i,\n            j,\n            overflow = [0, 0, 0, 0], // top, right, bottom, left\n            sort = function (a, b) {\n                return b.y - a.y;\n            };\n\n        // get out if not enabled\n        if (!series.visible || (!options.enabled && !series._hasPointLabels)) {\n            return;\n        }\n\n        // run parent method\n        Series.prototype.drawDataLabels.apply(series);\n\n        each(data, function (point) {\n            if (point.dataLabel && point.visible) { // #407, #2510\n\n                // Arrange points for detection collision\n                halves[point.half].push(point);\n\n                // Reset positions (#4905)\n                point.dataLabel._pos = null;\n            }\n        });\n\n        /* Loop over the points in each half, starting from the top and bottom\n         * of the pie to detect overlapping labels.\n         */\n        i = 2;\n        while (i--) {\n\n            var slots = [],\n                slotsLength,\n                usedSlots = [],\n                points = halves[i],\n                pos,\n                bottom,\n                length = points.length,\n                slotIndex;\n\n            if (!length) {\n                continue;\n            }\n\n            // Sort by angle\n            series.sortByAngle(points, i - 0.5);\n\n            // Assume equal label heights on either hemisphere (#2630)\n            j = labelHeight = 0;\n            while (!labelHeight && points[j]) { // #1569\n                labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968\n                j++;\n            }\n\n            // Only do anti-collision when we are outside the pie and have connectors (#856)\n            if (distanceOption > 0) {\n\n                // Build the slots\n                bottom = Math.min(centerY + radius + distanceOption, chart.plotHeight);\n                for (pos = Math.max(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {\n                    slots.push(pos);\n                }\n                slotsLength = slots.length;\n\n\n                /* Visualize the slots\n                if (!series.slotElements) {\n                    series.slotElements = [];\n                }\n                if (i === 1) {\n                    series.slotElements.forEach(function (elem) {\n                        elem.destroy();\n                    });\n                    series.slotElements.length = 0;\n                }\n\n                slots.forEach(function (pos, no) {\n                    var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),\n                        slotY = pos + chart.plotTop;\n\n                    if (isNumber(slotX)) {\n                        series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)\n                            .attr({\n                                'stroke-width': 1,\n                                stroke: 'silver',\n                                fill: 'rgba(0,0,255,0.1)'\n                            })\n                            .add());\n                        series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)\n                            .attr({\n                                fill: 'silver'\n                            }).add());\n                    }\n                });\n                // */\n\n                // if there are more values than available slots, remove lowest values\n                if (length > slotsLength) {\n                    // create an array for sorting and ranking the points within each quarter\n                    rankArr = [].concat(points);\n                    rankArr.sort(sort);\n                    j = length;\n                    while (j--) {\n                        rankArr[j].rank = j;\n                    }\n                    j = length;\n                    while (j--) {\n                        if (points[j].rank >= slotsLength) {\n                            points.splice(j, 1);\n                        }\n                    }\n                    length = points.length;\n                }\n\n                // The label goes to the nearest open slot, but not closer to the edge than\n                // the label's index.\n                for (j = 0; j < length; j++) {\n\n                    point = points[j];\n                    labelPos = point.labelPos;\n\n                    var closest = 9999,\n                        distance,\n                        slotI;\n\n                    // find the closest slot index\n                    for (slotI = 0; slotI < slotsLength; slotI++) {\n                        distance = Math.abs(slots[slotI] - labelPos[1]);\n                        if (distance < closest) {\n                            closest = distance;\n                            slotIndex = slotI;\n                        }\n                    }\n\n                    // if that slot index is closer to the edges of the slots, move it\n                    // to the closest appropriate slot\n                    if (slotIndex < j && slots[j] !== null) { // cluster at the top\n                        slotIndex = j;\n                    } else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom\n                        slotIndex = slotsLength - length + j;\n                        while (slots[slotIndex] === null) { // make sure it is not taken\n                            slotIndex++;\n                        }\n                    } else {\n                        // Slot is taken, find next free slot below. In the next run, the next slice will find the\n                        // slot above these, because it is the closest one\n                        while (slots[slotIndex] === null) { // make sure it is not taken\n                            slotIndex++;\n                        }\n                    }\n\n                    usedSlots.push({ i: slotIndex, y: slots[slotIndex] });\n                    slots[slotIndex] = null; // mark as taken\n                }\n                // sort them in order to fill in from the top\n                usedSlots.sort(sort);\n            }\n\n            // now the used slots are sorted, fill them up sequentially\n            for (j = 0; j < length; j++) {\n\n                var slot, naturalY;\n\n                point = points[j];\n                labelPos = point.labelPos;\n                dataLabel = point.dataLabel;\n                visibility = point.visible === false ? 'hidden' : 'inherit';\n                naturalY = labelPos[1];\n\n                if (distanceOption > 0) {\n                    slot = usedSlots.pop();\n                    slotIndex = slot.i;\n\n                    // if the slot next to currrent slot is free, the y value is allowed\n                    // to fall back to the natural position\n                    y = slot.y;\n                    if ((naturalY > y && slots[slotIndex + 1] !== null) ||\n                            (naturalY < y &&  slots[slotIndex - 1] !== null)) {\n                        y = Math.min(Math.max(0, naturalY), chart.plotHeight);\n                    }\n\n                } else {\n                    y = naturalY;\n                }\n\n                // get the x - use the natural x position for first and last slot, to prevent the top\n                // and botton slice connectors from touching each other on either side\n                x = options.justify ?\n                    seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :\n                    series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);\n\n\n                // Record the placement and visibility\n                dataLabel._attr = {\n                    visibility: visibility,\n                    align: labelPos[6]\n                };\n                dataLabel._pos = {\n                    x: x + options.x +\n                        ({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),\n                    y: y + options.y - 10 // 10 is for the baseline (label vs text)\n                };\n                dataLabel.connX = x;\n                dataLabel.connY = y;\n\n\n                // Detect overflowing data labels\n                if (this.options.size === null) {\n                    dataLabelWidth = dataLabel.width;\n                    // Overflow left\n                    if (x - dataLabelWidth < connectorPadding) {\n                        overflow[3] = Math.max(Math.round(dataLabelWidth - x + connectorPadding), overflow[3]);\n\n                    // Overflow right\n                    } else if (x + dataLabelWidth > plotWidth - connectorPadding) {\n                        overflow[1] = Math.max(Math.round(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);\n                    }\n\n                    // Overflow top\n                    if (y - labelHeight / 2 < 0) {\n                        overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0]);\n\n                    // Overflow left\n                    } else if (y + labelHeight / 2 > plotHeight) {\n                        overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2]);\n                    }\n                }\n            } // for each point\n        } // for each half\n\n        // Do not apply the final placement and draw the connectors until we have verified\n        // that labels are not spilling over.\n        if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {\n\n            // Place the labels in the final position\n            this.placeDataLabels();\n\n            // Draw the connectors\n            if (outside && connectorWidth) {\n                each(this.points, function (point) {\n                    var isNew;\n\n                    connector = point.connector;\n                    labelPos = point.labelPos;\n                    dataLabel = point.dataLabel;\n\n                    if (dataLabel && dataLabel._pos && point.visible) {\n                        visibility = dataLabel._attr.visibility;\n                        x = dataLabel.connX;\n                        y = dataLabel.connY;\n                        connectorPath = softConnector ? [\n                            'M',\n                            x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n                            'C',\n                            x, y, // first break, next to the label\n                            2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],\n                            labelPos[2], labelPos[3], // second break\n                            'L',\n                            labelPos[4], labelPos[5] // base\n                        ] : [\n                            'M',\n                            x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n                            'L',\n                            labelPos[2], labelPos[3], // second break\n                            'L',\n                            labelPos[4], labelPos[5] // base\n                        ];\n\n                        isNew = !connector;\n\n                        if (isNew) {\n                            point.connector = connector = chart.renderer.path()\n                                .addClass('highcharts-data-label-connector highcharts-color-' + point.colorIndex)\n                                .add(series.dataLabelsGroup);\n\n                            ";
if (build.classic) { 
s += "\n                            connector.attr({\n                                'stroke-width': connectorWidth,\n                                'stroke': options.connectorColor || point.color || '#606060'\n                            });\n                            ";
} 
s += "\n                        }\n                        connector[isNew ? 'attr' : 'animate']({ d: connectorPath });\n                        connector.attr('visibility', visibility);\n\n                    } else if (connector) {\n                        point.connector = connector.destroy();\n                    }\n                });\n            }\n        }\n    };\n    /**\n     * Perform the final placement of the data labels after we have verified that they\n     * fall within the plot area.\n     */\n    seriesTypes.pie.prototype.placeDataLabels = function () {\n        each(this.points, function (point) {\n            var dataLabel = point.dataLabel,\n                _pos;\n\n            if (dataLabel && point.visible) {\n                _pos = dataLabel._pos;\n                if (_pos) {\n                    dataLabel.attr(dataLabel._attr);\n                    dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);\n                    dataLabel.moved = true;\n                } else if (dataLabel) {\n                    dataLabel.attr({ y: -9999 });\n                }\n            }\n        });\n    };\n\n    seriesTypes.pie.prototype.alignDataLabel =  noop;\n\n    /**\n     * Verify whether the data labels are allowed to draw, or we should run more translation and data\n     * label positioning to keep them inside the plot area. Returns true when data labels are ready\n     * to draw.\n     */\n    seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {\n\n        var center = this.center,\n            options = this.options,\n            centerOption = options.center,\n            minSize = options.minSize || 80,\n            newSize = minSize,\n            ret;\n\n        // Handle horizontal size and center\n        if (centerOption[0] !== null) { // Fixed center\n            newSize = Math.max(center[2] - Math.max(overflow[1], overflow[3]), minSize);\n\n        } else { // Auto center\n            newSize = Math.max(\n                center[2] - overflow[1] - overflow[3], // horizontal overflow\n                minSize\n            );\n            center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center\n        }\n\n        // Handle vertical size and center\n        if (centerOption[1] !== null) { // Fixed center\n            newSize = Math.max(Math.min(newSize, center[2] - Math.max(overflow[0], overflow[2])), minSize);\n\n        } else { // Auto center\n            newSize = Math.max(\n                Math.min(\n                    newSize,\n                    center[2] - overflow[0] - overflow[2] // vertical overflow\n                ),\n                minSize\n            );\n            center[1] += (overflow[0] - overflow[2]) / 2; // vertical center\n        }\n\n        // If the size must be decreased, we need to run translate and drawDataLabels again\n        if (newSize < center[2]) {\n            center[2] = newSize;\n            center[3] = Math.min(relativeLength(options.innerSize || 0, newSize), newSize); // #3632\n            this.translate(center);\n            \n            if (this.drawDataLabels) {\n                this.drawDataLabels();\n            }\n        // Else, return true to indicate that the pie and its labels is within the plot area\n        } else {\n            ret = true;\n        }\n        return ret;\n    };\n}\n\nif (seriesTypes.column) {\n\n    /**\n     * Override the basic data label alignment by adjusting for the position of the column\n     */\n    seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {\n        var inverted = this.chart.inverted,\n            series = point.series,\n            dlBox = point.dlBox || point.shapeArgs, // data label box for alignment\n            below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series\n            inside = pick(options.inside, !!this.options.stacking), // draw it inside the box?\n            overshoot;\n\n        // Align to the column itself, or the top of it\n        if (dlBox) { // Area range uses this method but not alignTo\n            alignTo = merge(dlBox);\n\n            if (alignTo.y < 0) {\n                alignTo.height += alignTo.y;\n                alignTo.y = 0;\n            }\n            overshoot = alignTo.y + alignTo.height - series.yAxis.len;\n            if (overshoot > 0) {\n                alignTo.height -= overshoot;\n            }\n\n            if (inverted) {\n                alignTo = {\n                    x: series.yAxis.len - alignTo.y - alignTo.height,\n                    y: series.xAxis.len - alignTo.x - alignTo.width,\n                    width: alignTo.height,\n                    height: alignTo.width\n                };\n            }\n\n            // Compute the alignment box\n            if (!inside) {\n                if (inverted) {\n                    alignTo.x += below ? 0 : alignTo.width;\n                    alignTo.width = 0;\n                } else {\n                    alignTo.y += below ? alignTo.height : 0;\n                    alignTo.height = 0;\n                }\n            }\n        }\n\n\n        // When alignment is undefined (typically columns and bars), display the individual\n        // point below or above the point depending on the threshold\n        options.align = pick(\n            options.align,\n            !inverted || inside ? 'center' : below ? 'right' : 'left'\n        );\n        options.verticalAlign = pick(\n            options.verticalAlign,\n            inverted || inside ? 'middle' : below ? 'top' : 'bottom'\n        );\n\n        // Call the parent method\n        Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n    };\n}\n\n    return H;\n}(Highcharts));\n/**\n * Highcharts module to hide overlapping data labels. This module is included in Highcharts.\n */\n(function (H) {\n    var Chart = H.Chart,\n        each = H.each,\n        pick = H.pick,\n        addEvent = H.addEvent;\n\n    // Collect potensial overlapping data labels. Stack labels probably don't need to be \n    // considered because they are usually accompanied by data labels that lie inside the columns.\n    Chart.prototype.callbacks.push(function (chart) {\n        function collectAndHide() {\n            var labels = [];\n\n            each(chart.series, function (series) {\n                var dlOptions = series.options.dataLabels,\n                    collections = series.dataLabelCollections || ['dataLabel']; // Range series have two collections\n                if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866\n                    each(collections, function (coll) {\n                        each(series.points, function (point) {\n                            if (point[coll]) {\n                                point[coll].labelrank = pick(point.labelrank, point.shapeArgs && point.shapeArgs.height); // #4118\n                                labels.push(point[coll]);\n                            }\n                        });\n                    });\n                }\n            });\n            chart.hideOverlappingLabels(labels);\n        }\n\n        // Do it now ...\n        collectAndHide();\n\n        // ... and after each chart redraw\n        addEvent(chart, 'redraw', collectAndHide);\n\n    });\n\n    /**\n     * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth \n     * visual imression.\n     */        \n    Chart.prototype.hideOverlappingLabels = function (labels) {\n\n        var len = labels.length,\n            label,\n            i,\n            j,\n            label1,\n            label2,\n            isIntersecting,\n            pos1,\n            pos2,\n            parent1,\n            parent2,\n            padding,\n            intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {\n                return !(\n                    x2 > x1 + w1 ||\n                    x2 + w2 < x1 ||\n                    y2 > y1 + h1 ||\n                    y2 + h2 < y1\n                );\n            };\n    \n        // Mark with initial opacity\n        for (i = 0; i < len; i++) {\n            label = labels[i];\n            if (label) {\n                label.oldOpacity = label.opacity;\n                label.newOpacity = 1;\n            }\n        }\n\n        // Prevent a situation in a gradually rising slope, that each label\n        // will hide the previous one because the previous one always has\n        // lower rank.\n        labels.sort(function (a, b) {\n            return (b.labelrank || 0) - (a.labelrank || 0);\n        });\n\n        // Detect overlapping labels\n        for (i = 0; i < len; i++) {\n            label1 = labels[i];\n\n            for (j = i + 1; j < len; ++j) {\n                label2 = labels[j];\n                if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0) {\n                    pos1 = label1.alignAttr;\n                    pos2 = label2.alignAttr;\n                    parent1 = label1.parentGroup; // Different panes have different positions\n                    parent2 = label2.parentGroup;\n                    padding = 2 * (label1.box ? 0 : label1.padding); // Substract the padding if no background or border (#4333)\n                    isIntersecting = intersectRect(\n                        pos1.x + parent1.translateX,\n                        pos1.y + parent1.translateY,\n                        label1.width - padding,\n                        label1.height - padding,\n                        pos2.x + parent2.translateX,\n                        pos2.y + parent2.translateY,\n                        label2.width - padding,\n                        label2.height - padding\n                    );\n\n                    if (isIntersecting) {\n                        (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;\n                    }\n                }\n            }\n        }\n\n        // Hide or show\n        each(labels, function (label) {\n            var complete,\n                newOpacity;\n\n            if (label) {\n                newOpacity = label.newOpacity;\n\n                if (label.oldOpacity !== newOpacity && label.placed) {\n\n                    // Make sure the label is completely hidden to avoid catching clicks (#4362)\n                    if (newOpacity) {\n                        label.show(true);\n                    } else {\n                        complete = function () {\n                            label.hide();\n                        };\n                    }\n\n                    // Animate or set the opacity                    \n                    label.alignAttr.opacity = newOpacity;\n                    label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);\n                    \n                }\n                label.isOld = true;\n            }\n        });\n    };\n}(Highcharts));\n(function (H) {\n    var addEvent = H.addEvent,\n        Chart = H.Chart,\n        createElement = H.createElement,\n        css = H.css,\n        defaultOptions = H.defaultOptions,\n        defaultPlotOptions = H.defaultPlotOptions,\n        each = H.each,\n        extend = H.extend,\n        fireEvent = H.fireEvent,\n        hasTouch = H.hasTouch,\n        inArray = H.inArray,\n        isObject = H.isObject,\n        Legend = H.Legend,\n        merge = H.merge,\n        pick = H.pick,\n        Point = H.Point,\n        Series = H.Series,\n        seriesTypes = H.seriesTypes,\n        svg = H.svg,\n        TrackerMixin;\n/**\n * TrackerMixin for points and graphs\n */\nTrackerMixin = H.TrackerMixin = {\n\n    drawTrackerPoint: function () {\n        var series = this,\n            chart = series.chart,\n            pointer = chart.pointer,\n            onMouseOver = function (e) {\n                var target = e.target,\n                    point;\n\n                while (target && !point) {\n                    point = target.point;\n                    target = target.parentNode;\n                }\n\n                if (point !== undefined && point !== chart.hoverPoint) { // undefined on graph in scatterchart\n                    point.onMouseOver(e);\n                }\n            };\n\n        // Add reference to the point\n        each(series.points, function (point) {\n            if (point.graphic) {\n                point.graphic.element.point = point;\n            }\n            if (point.dataLabel) {\n                point.dataLabel.element.point = point;\n            }\n        });\n\n        // Add the event listeners, we need to do this only once\n        if (!series._hasTracking) {\n            each(series.trackerGroups, function (key) {\n                if (series[key]) { // we don't always have dataLabelsGroup\n                    series[key]\n                        .addClass('highcharts-tracker')\n                        .on('mouseover', onMouseOver)\n                        .on('mouseout', function (e) {\n                            pointer.onTrackerMouseOut(e);\n                        })\n                        .css(css);\n                    if (hasTouch) {\n                        series[key].on('touchstart', onMouseOver);\n                    }\n\n                    ";
if (build.classic) { 
s += "\n                    if (series.options.cursor) {\n                        series[key].css({ cursor: series.options.cursor });\n                    }\n                    ";
} 
s += "\n                }\n            });\n            series._hasTracking = true;\n        }\n    },\n\n    /**\n     * Draw the tracker object that sits above all data labels and markers to\n     * track mouse events on the graph or points. For the line type charts\n     * the tracker uses the same graphPath, but with a greater stroke width\n     * for better control.\n     */\n    drawTrackerGraph: function () {\n        var series = this,\n            options = series.options,\n            trackByArea = options.trackByArea,\n            trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n            trackerPathLength = trackerPath.length,\n            chart = series.chart,\n            pointer = chart.pointer,\n            renderer = chart.renderer,\n            snap = chart.options.tooltip.snap,\n            tracker = series.tracker,\n            i,\n            onMouseOver = function () {\n                if (chart.hoverSeries !== series) {\n                    series.onMouseOver();\n                }\n            },\n            /*\n             * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable\n             * IE6: 0.002\n             * IE7: 0.002\n             * IE8: 0.002\n             * IE9: 0.00000000001 (unlimited)\n             * IE10: 0.0001 (exporting only)\n             * FF: 0.00000000001 (unlimited)\n             * Chrome: 0.000001\n             * Safari: 0.000001\n             * Opera: 0.00000000001 (unlimited)\n             */\n            TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';\n\n        // Extend end points. A better way would be to use round linecaps,\n        // but those are not clickable in VML.\n        if (trackerPathLength && !trackByArea) {\n            i = trackerPathLength + 1;\n            while (i--) {\n                if (trackerPath[i] === 'M') { // extend left side\n                    trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], 'L');\n                }\n                if ((i && trackerPath[i] === 'M') || i === trackerPathLength) { // extend right side\n                    trackerPath.splice(i, 0, 'L', trackerPath[i - 2] + snap, trackerPath[i - 1]);\n                }\n            }\n        }\n\n        // handle single points\n        /*for (i = 0; i < singlePoints.length; i++) {\n            singlePoint = singlePoints[i];\n            trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,\n            L, singlePoint.plotX + snap, singlePoint.plotY);\n        }*/\n\n        // draw the tracker\n        if (tracker) {\n            tracker.attr({ d: trackerPath });\n        } else if (series.graph) { // create\n\n            series.tracker = renderer.path(trackerPath)\n            .attr({\n                'stroke-linejoin': 'round', // #1225\n                visibility: series.visible ? 'visible' : 'hidden',\n                stroke: TRACKER_FILL,\n                fill: trackByArea ? TRACKER_FILL : 'none',\n                'stroke-width': series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap),\n                zIndex: 2\n            })\n            .add(series.group);\n\n            // The tracker is added to the series group, which is clipped, but is covered\n            // by the marker group. So the marker group also needs to capture events.\n            each([series.tracker, series.markerGroup], function (tracker) {\n                tracker.addClass('highcharts-tracker')\n                    .on('mouseover', onMouseOver)\n                    .on('mouseout', function (e) {\n                        pointer.onTrackerMouseOut(e);\n                    });\n\n                ";
if (build.classic) { 
s += "\n                if (options.cursor) {\n                    tracker.css({ cursor: options.cursor });\n                }\n                ";
} 
s += "\n\n                if (hasTouch) {\n                    tracker.on('touchstart', onMouseOver);\n                }\n            });\n        }\n    }\n};\n/* End TrackerMixin */\n\n\n/**\n * Add tracking event listener to the series group, so the point graphics\n * themselves act as trackers\n */\n\nif (seriesTypes.column) {\n    seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;    \n}\n\nif (seriesTypes.pie) {\n    seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n\nif (seriesTypes.scatter) {\n    seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n\n/*\n * Extend Legend for item events\n */\nextend(Legend.prototype, {\n\n    setItemEvents: function (item, legendItem, useHTML) {\n        var legend = this,\n            chart = legend.chart,\n            activeClass = 'highcharts-legend-' + (item.series ? 'point' : 'series') + '-active';\n\n        // Set the events on the item group, or in case of useHTML, the item itself (#1249)\n        (useHTML ? legendItem : item.legendGroup).on('mouseover', function () {\n            item.setState('hover');\n            \n            // A CSS class to dim or hide other than the hovered series\n            chart.seriesGroup.addClass(activeClass);\n            \n            ";
if (build.classic) { 
s += "\n            legendItem.css(legend.options.itemHoverStyle);\n            ";
} 
s += "\n        })\n        .on('mouseout', function () {\n            ";
if (build.classic) { 
s += "\n            legendItem.css(item.visible ? legend.itemStyle : legend.itemHiddenStyle);\n            ";
} 
s += "\n\n            // A CSS class to dim or hide other than the hovered series\n            chart.seriesGroup.removeClass(activeClass);\n            \n            item.setState();\n        })\n        .on('click', function (event) {\n            var strLegendItemClick = 'legendItemClick',\n                fnLegendItemClick = function () {\n                    if (item.setVisible) {\n                        item.setVisible();\n                    }\n                };\n\n            // Pass over the click/touch event. #4.\n            event = {\n                browserEvent: event\n            };\n\n            // click the name or symbol\n            if (item.firePointEvent) { // point\n                item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n            } else {\n                fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n            }\n        });\n    },\n\n    createCheckboxForItem: function (item) {\n        var legend = this;\n\n        item.checkbox = createElement('input', {\n            type: 'checkbox',\n            checked: item.selected,\n            defaultChecked: item.selected // required by IE7\n        }, legend.options.itemCheckboxStyle, legend.chart.container);\n\n        addEvent(item.checkbox, 'click', function (event) {\n            var target = event.target;\n            fireEvent(\n                item.series || item, \n                'checkboxClick', \n                { // #3712\n                    checked: target.checked,\n                    item: item\n                },\n                function () {\n                    item.select();\n                }\n            );\n        });\n    }\n});\n\n\n";
if (build.classic) { 
s += "\n// Add pointer cursor to legend itemstyle in defaultOptions\ndefaultOptions.legend.itemStyle.cursor = 'pointer';\n";
} 
s += "\n\n\n/*\n * Extend the Chart object with interaction\n */\n\nextend(Chart.prototype, {\n    /**\n     * Display the zoom button\n     */\n    showResetZoom: function () {\n        var chart = this,\n            lang = defaultOptions.lang,\n            btnOptions = chart.options.chart.resetZoomButton,\n            theme = btnOptions.theme,\n            states = theme.states,\n            alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n\n        function zoomOut() {\n            chart.zoomOut();\n        }\n\n        this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)\n            .attr({\n                align: btnOptions.position.align,\n                title: lang.resetZoomTitle\n            })\n            .add()\n            .align(btnOptions.position, false, alignTo);\n\n    },\n\n    /**\n     * Zoom out to 1:1\n     */\n    zoomOut: function () {\n        var chart = this;\n        fireEvent(chart, 'selection', { resetSelection: true }, function () {\n            chart.zoom();\n        });\n    },\n\n    /**\n     * Zoom into a given portion of the chart given by axis coordinates\n     * @param {Object} event\n     */\n    zoom: function (event) {\n        var chart = this,\n            hasZoomed,\n            pointer = chart.pointer,\n            displayButton = false,\n            resetZoomButton;\n\n        // If zoom is called with no arguments, reset the axes\n        if (!event || event.resetSelection) {\n            each(chart.axes, function (axis) {\n                hasZoomed = axis.zoom();\n            });\n        } else { // else, zoom in on all axes\n            each(event.xAxis.concat(event.yAxis), function (axisData) {\n                var axis = axisData.axis,\n                    isXAxis = axis.isXAxis;\n\n                // don't zoom more than minRange\n                if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {\n                    hasZoomed = axis.zoom(axisData.min, axisData.max);\n                    if (axis.displayBtn) {\n                        displayButton = true;\n                    }\n                }\n            });\n        }\n\n        // Show or hide the Reset zoom button\n        resetZoomButton = chart.resetZoomButton;\n        if (displayButton && !resetZoomButton) {\n            chart.showResetZoom();\n        } else if (!displayButton && isObject(resetZoomButton)) {\n            chart.resetZoomButton = resetZoomButton.destroy();\n        }\n\n\n        // Redraw\n        if (hasZoomed) {\n            chart.redraw(\n                pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation\n            );\n        }\n    },\n\n    /**\n     * Pan the chart by dragging the mouse across the pane. This function is called\n     * on mouse move, and the distance to pan is computed from chartX compared to\n     * the first chartX position in the dragging operation.\n     */\n    pan: function (e, panning) {\n\n        var chart = this,\n            hoverPoints = chart.hoverPoints,\n            doRedraw;\n\n        // remove active points for shared tooltip\n        if (hoverPoints) {\n            each(hoverPoints, function (point) {\n                point.setState();\n            });\n        }\n\n        each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps\n            var axis = chart[isX ? 'xAxis' : 'yAxis'][0],\n                horiz = axis.horiz,\n                mousePos = e[horiz ? 'chartX' : 'chartY'],\n                mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',\n                startPos = chart[mouseDown],\n                halfPointRange = (axis.pointRange || 0) / 2,\n                extremes = axis.getExtremes(),\n                newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,\n                newMax = axis.toValue(startPos + axis.len - mousePos, true) - halfPointRange,\n                goingLeft = startPos > mousePos; // #3613\n            \n            if (axis.series.length &&\n                    (goingLeft || newMin > Math.min(extremes.dataMin, extremes.min)) &&        \n                    (!goingLeft || newMax < Math.max(extremes.dataMax, extremes.max))) {\n                axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });\n                doRedraw = true;\n            }\n\n            chart[mouseDown] = mousePos; // set new reference for next run\n        });\n\n        if (doRedraw) {\n            chart.redraw(false);\n        }\n        css(chart.container, { cursor: 'move' });\n    }\n});\n\n/*\n * Extend the Point object with interaction\n */\nextend(Point.prototype, {\n    /**\n     * Toggle the selection status of a point\n     * @param {Boolean} selected Whether to select or unselect the point.\n     * @param {Boolean} accumulate Whether to add to the previous selection. By default,\n     *         this happens if the control key (Cmd on Mac) was pressed during clicking.\n     */\n    select: function (selected, accumulate) {\n        var point = this,\n            series = point.series,\n            chart = series.chart;\n\n        selected = pick(selected, !point.selected);\n\n        // fire the event with the default handler\n        point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {\n            point.selected = point.options.selected = selected;\n            series.options.data[inArray(point, series.data)] = point.options;\n\n            point.setState(selected && 'select');\n\n            // unselect all other points unless Ctrl or Cmd + click\n            if (!accumulate) {\n                each(chart.getSelectedPoints(), function (loopPoint) {\n                    if (loopPoint.selected && loopPoint !== point) {\n                        loopPoint.selected = loopPoint.options.selected = false;\n                        series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;\n                        loopPoint.setState('');\n                        loopPoint.firePointEvent('unselect');\n                    }\n                });\n            }\n        });\n    },\n\n    /**\n     * Runs on mouse over the point\n     *\n     * @param {Object} e The event arguments\n     * @param {Boolean} byProximity Falsy for kd points that are closest to the mouse, or to\n     *        actually hovered points. True for other points in shared tooltip.\n     */\n    onMouseOver: function (e, byProximity) {\n        var point = this,\n            series = point.series,\n            chart = series.chart,\n            tooltip = chart.tooltip,\n            hoverPoint = chart.hoverPoint;\n\n        if (chart.hoverSeries !== series) {\n            series.onMouseOver();\n        }\n\n        // set normal state to previous series\n        if (hoverPoint && hoverPoint !== point) {\n            hoverPoint.onMouseOut();\n        }\n\n        if (point.series) { // It may have been destroyed, #4130\n\n            // trigger the event\n            point.firePointEvent('mouseOver');\n\n            // update the tooltip\n            if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {\n                tooltip.refresh(point, e);\n            }\n\n            // hover this\n            point.setState('hover');\n            if (!byProximity) {\n                chart.hoverPoint = point;\n            }\n        }\n    },\n\n    /**\n     * Runs on mouse out from the point\n     */\n    onMouseOut: function () {\n        var chart = this.series.chart,\n            hoverPoints = chart.hoverPoints;\n\n        this.firePointEvent('mouseOut');\n\n        if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240\n            this.setState();\n            chart.hoverPoint = null;\n        }\n    },\n\n    /**\n     * Import events from the series' and point's options. Only do it on\n     * demand, to save processing time on hovering.\n     */\n    importEvents: function () {\n        if (!this.hasImportedEvents) {\n            var point = this,\n                options = merge(point.series.options.point, point.options),\n                events = options.events,\n                eventType;\n\n            point.events = events;\n\n            for (eventType in events) {\n                addEvent(point, eventType, events[eventType]);\n            }\n            this.hasImportedEvents = true;\n\n        }\n    },\n\n    /**\n     * Set the point's state\n     * @param {String} state\n     */\n    setState: function (state, move) {\n        var point = this,\n            plotX = Math.floor(point.plotX), // #4586\n            plotY = point.plotY,\n            series = point.series,\n            stateOptions = series.options.states[state] || {},\n            markerOptions = (defaultPlotOptions[series.type].marker && series.options.marker) || {},\n            normalDisabled = markerOptions.enabled === false,\n            markerStateOptions = (markerOptions.states && markerOptions.states[state]) || {},\n            stateDisabled = markerStateOptions.enabled === false,\n            stateMarkerGraphic = series.stateMarkerGraphic,\n            pointMarker = point.marker || {},\n            chart = series.chart,\n            radius,\n            halo = series.halo,\n            haloOptions,\n            attribs,\n            newSymbol;\n\n        state = state || ''; // empty string\n\n        if (\n                // already has this state\n                (state === point.state && !move) ||\n                // selected points don't respond to hover\n                (point.selected && state !== 'select') ||\n                // series' state options is disabled\n                (stateOptions.enabled === false) ||\n                // general point marker's state options is disabled\n                (state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||\n                // individual point marker's state options is disabled\n                (state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610\n\n            ) {\n            return;\n        }\n\n        radius = markerStateOptions.radius || (markerOptions.radius + (markerStateOptions.radiusPlus || 0));\n        \n        // Apply hover styles to the existing point\n        if (point.graphic) {\n\n            if (point.state) {\n                point.graphic.removeClass('highcharts-point-' + point.state);\n            }\n            if (state) {\n                point.graphic.addClass('highcharts-point-' + state);\n            }\n\n            attribs = radius ? { // new symbol attributes (#507, #612)\n                x: plotX - radius,\n                y: plotY - radius,\n                width: 2 * radius,\n                height: 2 * radius\n            } : {};\n\n            ";
if (build.classic) { 
s += "\n            attribs = merge(series.pointAttribs(point, state), attribs);\n            ";
} 
s += "\n\n            point.graphic.attr(attribs);\n\n            // Zooming in from a range with no markers to a range with markers\n            if (stateMarkerGraphic) {\n                stateMarkerGraphic.hide();\n            }\n        } else {\n            // if a graphic is not applied to each point in the normal state, create a shared\n            // graphic for the hover state\n            if (state && markerStateOptions) {\n                newSymbol = pointMarker.symbol || series.symbol;\n\n                // If the point has another symbol than the previous one, throw away the\n                // state marker graphic and force a new one (#1459)\n                if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {\n                    stateMarkerGraphic = stateMarkerGraphic.destroy();\n                }\n\n                // Add a new state marker graphic\n                if (!stateMarkerGraphic) {\n                    if (newSymbol) {\n                        series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(\n                            newSymbol,\n                            plotX - radius,\n                            plotY - radius,\n                            2 * radius,\n                            2 * radius\n                        )\n                        .add(series.markerGroup);\n                        stateMarkerGraphic.currentSymbol = newSymbol;\n\n                        ";
if (build.classic) { 
s += "\n                        stateMarkerGraphic.attr(series.pointAttribs(point, state));\n                        ";
} 
s += "\n                    }\n\n                // Move the existing graphic\n                } else {\n                    stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054\n                        x: plotX - radius,\n                        y: plotY - radius\n                    });\n                }\n            }\n\n            if (stateMarkerGraphic) {\n                stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450\n                stateMarkerGraphic.element.point = point; // #4310\n            }\n        }\n\n        // Show me your halo\n        haloOptions = stateOptions.halo;\n        if (haloOptions && haloOptions.size) {\n            if (!halo) {\n                series.halo = halo = chart.renderer.path()\n                    .add(chart.seriesGroup);\n            }\n            halo[move ? 'animate' : 'attr']({\n                d: point.haloPath(haloOptions.size)\n            });\n            halo.attr({\n                'class': 'highcharts-halo highcharts-color-' + pick(point.colorIndex, series.colorIndex) \n            });\n\n            ";
if (build.classic) { 
s += "\n            halo.attr(extend({\n                'fill': point.color || series.color,\n                'fill-opacity': haloOptions.opacity,\n                'zIndex': -1 // #4929, IE8 added halo above everything\n            },\n            haloOptions.attributes))[move ? 'animate' : 'attr']({\n                d: point.haloPath(haloOptions.size)\n            });\n            ";
} 
s += "\n        } else if (halo) {\n            halo.attr({ d: [] });\n        }\n\n        point.state = state;\n    },\n\n    /**\n     * Get the circular path definition for the halo\n     * @param  {Number} size The radius of the circular halo\n     * @returns {Array} The path definition\n     */\n    haloPath: function (size) {\n        var series = this.series,\n            chart = series.chart,\n            plotBox = series.getPlotBox(),\n            inverted = chart.inverted,\n            plotX = Math.floor(this.plotX);\n\n        return chart.renderer.symbols.circle(\n            plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : plotX) - size, \n            plotBox.translateY + (inverted ? series.xAxis.len - plotX : this.plotY) - size, \n            size * 2, \n            size * 2\n        );\n    }\n});\n\n/*\n * Extend the Series object with interaction\n */\n\nextend(Series.prototype, {\n    /**\n     * Series mouse over handler\n     */\n    onMouseOver: function () {\n        var series = this,\n            chart = series.chart,\n            hoverSeries = chart.hoverSeries;\n\n        // set normal state to previous series\n        if (hoverSeries && hoverSeries !== series) {\n            hoverSeries.onMouseOut();\n        }\n\n        // trigger the event, but to save processing time,\n        // only if defined\n        if (series.options.events.mouseOver) {\n            fireEvent(series, 'mouseOver');\n        }\n\n        // hover this\n        series.setState('hover');\n        chart.hoverSeries = series;\n    },\n\n    /**\n     * Series mouse out handler\n     */\n    onMouseOut: function () {\n        // trigger the event only if listeners exist\n        var series = this,\n            options = series.options,\n            chart = series.chart,\n            tooltip = chart.tooltip,\n            hoverPoint = chart.hoverPoint;\n\n        chart.hoverSeries = null; // #182, set to null before the mouseOut event fires\n\n        // trigger mouse out on the point, which must be in this series\n        if (hoverPoint) {\n            hoverPoint.onMouseOut();\n        }\n\n        // fire the mouse out event\n        if (series && options.events.mouseOut) {\n            fireEvent(series, 'mouseOut');\n        }\n\n\n        // hide the tooltip\n        if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {\n            tooltip.hide();\n        }\n\n        // set normal state\n        series.setState();\n    },\n\n    /**\n     * Set the state of the graph\n     */\n    setState: function (state) {\n        var series = this,\n            options = series.options,\n            graph = series.graph,\n            stateOptions = options.states,\n            lineWidth = options.lineWidth,\n            attribs,\n            i = 0;\n\n        state = state || '';\n\n        if (series.state !== state) {\n\n            // Toggle class names\n            each([series.group, series.markerGroup], function (group) {\n                if (group) {\n                    // Old state\n                    if (series.state) {\n                        group.removeClass('highcharts-series-' + series.state);    \n                    }\n                    // New state\n                    if (state) {\n                        group.addClass('highcharts-series-' + state);\n                    }\n                }\n            });\n\n            series.state = state;\n\n            ";
if (build.classic) { 
s += "\n\n            if (stateOptions[state] && stateOptions[state].enabled === false) {\n                return;\n            }\n\n            if (state) {\n                lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035\n            }\n\n            if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML\n                attribs = {\n                    'stroke-width': lineWidth\n                };\n                // use attr because animate will cause any other animation on the graph to stop\n                graph.attr(attribs);\n                while (series['zone-graph-' + i]) {\n                    series['zone-graph-' + i].attr(attribs);\n                    i = i + 1;\n                }\n            }\n            ";
} 
s += "\n        }\n    },\n\n    /**\n     * Set the visibility of the graph\n     *\n     * @param vis {Boolean} True to show the series, false to hide. If undefined,\n     *                the visibility is toggled.\n     */\n    setVisible: function (vis, redraw) {\n        var series = this,\n            chart = series.chart,\n            legendItem = series.legendItem,\n            showOrHide,\n            ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n            oldVisibility = series.visible;\n\n        // if called without an argument, toggle visibility\n        series.visible = vis = series.userOptions.visible = vis === undefined ? !oldVisibility : vis;\n        showOrHide = vis ? 'show' : 'hide';\n\n        // show or hide elements\n        each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {\n            if (series[key]) {\n                series[key][showOrHide]();\n            }\n        });\n\n\n        // hide tooltip (#1361)\n        if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {\n            series.onMouseOut();\n        }\n\n\n        if (legendItem) {\n            chart.legend.colorizeItem(series, vis);\n        }\n\n\n        // rescale or adapt to resized chart\n        series.isDirty = true;\n        // in a stack, all other series are affected\n        if (series.options.stacking) {\n            each(chart.series, function (otherSeries) {\n                if (otherSeries.options.stacking && otherSeries.visible) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n\n        // show or hide linked series\n        each(series.linkedSeries, function (otherSeries) {\n            otherSeries.setVisible(vis, false);\n        });\n\n        if (ignoreHiddenSeries) {\n            chart.isDirtyBox = true;\n        }\n        if (redraw !== false) {\n            chart.redraw();\n        }\n\n        fireEvent(series, showOrHide);\n    },\n\n    /**\n     * Show the graph\n     */\n    show: function () {\n        this.setVisible(true);\n    },\n\n    /**\n     * Hide the graph\n     */\n    hide: function () {\n        this.setVisible(false);\n    },\n\n\n    /**\n     * Set the selected state of the graph\n     *\n     * @param selected {Boolean} True to select the series, false to unselect. If\n     *                undefined, the selection state is toggled.\n     */\n    select: function (selected) {\n        var series = this;\n        // if called without an argument, toggle\n        series.selected = selected = (selected === undefined) ? !series.selected : selected;\n\n        if (series.checkbox) {\n            series.checkbox.checked = selected;\n        }\n\n        fireEvent(series, selected ? 'select' : 'unselect');\n    },\n\n    drawTracker: TrackerMixin.drawTrackerGraph\n});\n\n    return H;\n}(Highcharts));\n\n";
return s;;
func = new Function('build', s);
func({ classic: true });
</script></head><body></body></html>
